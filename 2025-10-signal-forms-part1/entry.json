{"slug":"2025-10-signal-forms-part1","html":"<p>Angular introduces Signal Forms with Version <a href=\"https://github.com/angular/angular/releases/tag/21.0.0\">21.0.0</a>, an experimental but promising approach to form handling that leverages Angular&#39;s reactive Signal primitive.\nThis new API offers a declarative way to build forms with full control over the data model and built-in schema validation.\nIn this first part of our four-part series, we&#39;ll cover the fundamentals you need to get started with Signal Forms.</p>\n<blockquote>\n<p>‚ö†Ô∏è <strong>Experimental Feature:</strong> Signal Forms are currently an experimental feature in Angular. The API and functionality may change in future releases.</p>\n</blockquote>\n<h2 id=\"related-blog-posts\">Related blog posts</h2>\n<p><strong>This blog post is part of our series about Signal Forms:</strong></p>\n<ul>\n<li><em>Part 1: Getting Started with Signal Forms</em> (this post)</li>\n<li><a href=\"/blog/2025-10-signal-forms-part2\">Part 2: Advanced Validation and Schema Patterns</a></li>\n<li><a href=\"/blog/2025-10-signal-forms-part3\">Part 3: Child Forms, Custom UI Controls and SignalFormsConfig</a></li>\n<li><a href=\"/blog/2025-12-signal-forms-part4\">Part 4: Metadata and Accessibility Handling</a></li>\n</ul>\n<h2 id=\"what-makes-signal-forms-different\">What Makes Signal Forms Different</h2>\n<p>Signal Forms represent a paradigm shift from Angular&#39;s existing form approaches of Template-Driven and Reactive Forms.\nThe new approach follows three core principles:</p>\n<ol>\n<li><strong>Full data model control</strong>:\nForm data is managed as a signal that we create, control, and can update directly at any time.</li>\n<li><strong>Declarative logic</strong>:\nValidation logic is described through code in a reusable schema.</li>\n<li><strong>Structural mapping</strong>:\nThe field structure mirrors the data structure 1:1. It is not necessary to create the form model manually, but it is automatically derived from the data model.</li>\n</ol>\n<h2 id=\"setting-up-the-data-model\">Setting up the Data Model</h2>\n<p>The first step in creating a Signal Form is to define our data model.\nFor this blog post, we will create a user registration form.\nA TypeScript interface defines all the fields we need:\nNew users can provide name and age, multiple email addresses, and choose whether to subscribe to a newsletter via a checkbox.\nFinally, they must agree to the terms and conditions.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">RegisterFormData</span> {\n  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-attr\">email</span>: <span class=\"hljs-built_in\">string</span>[];\n  <span class=\"hljs-attr\">newsletter</span>: <span class=\"hljs-built_in\">boolean</span>;\n  <span class=\"hljs-attr\">agreeToTermsAndConditions</span>: <span class=\"hljs-built_in\">boolean</span>;\n}\n</code></pre>\n<p>Next, we create a signal property containing our initial form state.\nIn this example, we keep the <code>initialState</code> as a separate constant before, so we can re-use it later for resetting the form data after submission.\nOf course, it is also possible to define the initial state directly inlined when creating the signal.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-title class_\">RegisterFormData</span> = {\n  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span>,\n  <span class=\"hljs-attr\">email</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],\n  <span class=\"hljs-attr\">newsletter</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">agreeToTermsAndConditions</span>: <span class=\"hljs-literal\">false</span>,\n};\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationForm</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> registrationModel = signal&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(initialState);\n}\n</code></pre>\n<p>This signal serves as our single source of truth for all form data.\nIt remains reactive and automatically synchronizes with any changes made through the form fields.</p>\n<h2 id=\"creating-the-field-structure\">Creating the Field Structure</h2>\n<p>Now that we have our data model defined, the next step is to create the field structure that connects our data to the form.\nAngular provides a <code>form()</code> function to create a field tree that derives its structure from the data.\nThe result is a <code>FieldTree</code> object that mirrors our data structure and maintains metadata for each field node.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { form } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationForm</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> registrationModel = signal&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(initialState);\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> registrationForm = <span class=\"hljs-title function_\">form</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">registrationModel</span>);\n}\n</code></pre>\n<h3 id=\"accessing-field-properties\">Accessing Field Properties</h3>\n<p>This form model structure allows us to navigate through our form field paths exactly like we would navigate through our data structure.\nUsing this object, we can access individual fields and their reactive properties:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// Access field value</span>\n<span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(this.registrationForm.username().value()); <span class=\"hljs-comment\">// current username value</span>\n\n<span class=\"hljs-comment\">// Access field states</span>\n<span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(this.registrationForm.username().valid()); <span class=\"hljs-comment\">// validation status</span>\n<span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(this.registrationForm.username().touched()); <span class=\"hljs-comment\">// interaction status</span>\n<span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(this.registrationForm.username().errors()); <span class=\"hljs-comment\">// validation errors</span>\n</code></pre>\n<p>Each nested call returns another <code>FieldTree</code> that represents the corresponding part of the form.\nWe can call each <code>FieldTree</code> as a function to receive a <code>FieldState</code> object.\nIt provides several reactive properties that we can use in our templates and component logic:</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>value</code></td>\n<td><code>WritableSignal&lt;TValue&gt;</code></td>\n<td>current value of this part of the field tree</td>\n</tr>\n<tr>\n<td><code>valid</code></td>\n<td><code>Signal&lt;boolean&gt;</code></td>\n<td><code>true</code> if the field passes all validations</td>\n</tr>\n<tr>\n<td><code>touched</code></td>\n<td><code>Signal&lt;boolean&gt;</code></td>\n<td><code>true</code> if the user has interacted with the field</td>\n</tr>\n<tr>\n<td><code>errors</code></td>\n<td><code>Signal&lt;ValidationError[]&gt;</code></td>\n<td>array of validation errors</td>\n</tr>\n<tr>\n<td><code>pending</code></td>\n<td><code>Signal&lt;boolean&gt;</code></td>\n<td><code>true</code> if async validations are running</td>\n</tr>\n<tr>\n<td><code>disabled</code></td>\n<td><code>Signal&lt;boolean&gt;</code></td>\n<td><code>true</code> if the field is disabled</td>\n</tr>\n<tr>\n<td><code>disabledReasons</code></td>\n<td><code>Signal&lt;string[]&gt;</code></td>\n<td>array of reasons about the disabled state</td>\n</tr>\n<tr>\n<td><code>hidden</code></td>\n<td><code>Signal&lt;boolean&gt;</code></td>\n<td><code>true</code> if the field is semantically hidden</td>\n</tr>\n</tbody></table>\n<p>It is important to stay aware of the difference between <code>FieldTree</code> and <code>FieldState</code>:\nWhile <code>FieldTree</code> represents the structure and metadata of the form, <code>FieldState</code> provides the current state and value of a specific field.\nOnce we call a <code>FieldTree</code> as a function, we get a <code>FieldState</code> as the result.</p>\n<h2 id=\"connecting-fields-to-the-template\">Connecting Fields to the Template</h2>\n<p>Now that we have our form structure in place, we need to connect it to our HTML template to create functional input fields with reactive data binding.\nSignal Forms use the <code>FormField</code> directive to bind form fields to HTML input elements.\nTo use the directive, we need to import it first.\nIn our example, we also import <code>JsonPipe</code> so we can use it in our template to display the current form value.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">JsonPipe</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, <span class=\"hljs-title class_\">FormField</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-registration-form&#x27;</span>,\n  <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">FormField</span>, <span class=\"hljs-title class_\">JsonPipe</span>],\n  <span class=\"hljs-attr\">templateUrl</span>: <span class=\"hljs-string\">&#x27;./registration-form.html&#x27;</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationForm</span> {\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>The <code>FormField</code> directive works directly with all standard HTML form elements like <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code>.\nLet&#39;s start with a basic template that connects some of our form fields: We apply the directive to the HTML element by using the <code>[formField]</code> property binding.\nOn the right side of the binding, we pass the corresponding <code>FieldTree</code> from our form structure.</p>\n<p>Notice, that we also use the form attribute <code>novalidate</code>: It disables the native browser field validation.\nWe will handle validation later by using a form schema.</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> (<span class=\"hljs-attr\">submit</span>)=<span class=\"hljs-string\">&quot;submitForm()&quot;</span> <span class=\"hljs-attr\">novalidate</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;username&quot;</span>&gt;</span>Username<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;username&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;registrationForm.username&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;age&quot;</span>&gt;</span>Age<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;age&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;number&quot;</span> [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;registrationForm.age&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;newsletter&quot;</span>&gt;</span>Subscribe to newsletter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;newsletter&quot;</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span>\n      [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;registrationForm.newsletter&quot;</span>\n    /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>Register<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Debug output to see current form data --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pre</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">registrationModel</span>() | json }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pre</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pre</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">registrationForm</span>().value() | json }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pre</span>&gt;</span></span>\n</code></pre>\n<p>We have now connected each input to its corresponding field in our form structure.\nThe <code>FormField</code> directive handles the two-way data binding automatically, keeping our data model synchronized with user input.\nThe form model automatically synchronizes with the data signal: To read the value, we can use the signal as well as the <code>FieldState</code> with its <code>value</code> property.</p>\n<h3 id=\"working-with-arrays\">Working with Arrays</h3>\n<p>For our email array, we need to handle dynamic addition and removal of fields:\nThe <code>registrationForm.email</code> field returns an array of <code>FieldTree</code> objects that we can iterate over using <code>@for()</code>.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">fieldset</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">legend</span>&gt;</span>\n    E-Mail Addresses\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">&quot;addEmail()&quot;</span>&gt;</span>+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">legend</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    @for (emailField of registrationForm.email; track $index) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;group&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n          <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;email&quot;</span>\n          [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;emailField&quot;</span>\n          [<span class=\"hljs-attr\">aria-label</span>]=<span class=\"hljs-string\">&quot;&#x27;E-Mail &#x27; + $index&quot;</span>\n        /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">&quot;removeEmail($index)&quot;</span>&gt;</span>-<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    }\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">fieldset</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n</code></pre>\n<p>As you may have noticed, we also added two buttons for adding and removing e-mail input fields.\nIn the corresponding methods, we access the <code>value</code> signal within the form model.\nThe signal&#39;s <code>update()</code> method allows us to to add or remove items on the <code>email</code> array.</p>\n<p>Please keep in mind that changes to signal values must be done immutably.\nInstead of directly manipulating the array, we always create a new array with the updated values.\nThis is why we use the spread operator (<code>...</code>) to create a new array when adding an email and the <code>filter()</code> method to create a new array when removing an email.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationForm</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-title function_\">addEmail</span>(): <span class=\"hljs-built_in\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">registrationForm</span>.<span class=\"hljs-property\">email</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">items</span>) =&gt;</span> [...items, <span class=\"hljs-string\">&#x27;&#x27;</span>]);\n  }\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-title function_\">removeEmail</span>(<span class=\"hljs-attr\">removeIndex</span>: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">registrationForm</span>.<span class=\"hljs-property\">email</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">items</span>) =&gt;</span>\n      items.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, index</span>) =&gt;</span> index !== removeIndex)\n    );\n  }\n}\n</code></pre>\n<h2 id=\"basic-form-submission\">Basic Form Submission</h2>\n<p>Now that we have connected our form to the template, we want to submit the form data.\nWe can simply use the form data and submit them or we can use the more powerful <code>submit()</code> function.</p>\n<p>Both approaches start with a form submission event handler: In the template, we already used the <code>(submit)</code> event binding on the <code>&lt;form&gt;</code> element.\nIt is necessary to prevent the default form submission behavior by synchronously returning <code>false</code> from our <code>submitForm()</code> handler method.\nOtherwise, the page will reload on form submission.</p>\n<h3 id=\"basic-synchronous-submission\">Basic Synchronous Submission</h3>\n<p>For basic cases where you want to process form data synchronously, you can directly access the current form values:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationForm</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-title function_\">submitForm</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// Access current form data</span>\n    <span class=\"hljs-keyword\">const</span> formData = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">registrationModel</span>();\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Form submitted:&#x27;</span>, formData);\n\n    <span class=\"hljs-comment\">// Prevent reloading (default browser behavior)</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n}\n</code></pre>\n<p>Since our data model signal is always kept in sync with the form fields, we can access the current form state at any time using <code>this.registrationModel()</code>.\nIt is also possible to access the form data via <code>this.registrationForm().value()</code>, which provides the same result.</p>\n<p>This approach is quite simple but not so effective once we want to validate the form data before submitting and when we want to give the user feedback about submission errors which may come from our connected backend service.</p>\n<h3 id=\"using-the-signal-forms-submit-function\">Using the Signal Forms <code>submit()</code> Function</h3>\n<p>For more complex scenarios involving asynchronous operations, loading states, and error handling, Signal Forms provide a dedicated <code>submit()</code> function.\nTo demonstrate this, we want to simulate a registration process that involves a fake asynchronous operation.\nThis service method returns a <code>Promise</code> that resolves after a two-second delay, simulating a network request.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Injectable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n@Injectable({ providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationService</span> {\n  registerUser(registrationData: Record&lt;string, any&gt;) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve)</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        resolve(registrationData);\n      }, <span class=\"hljs-number\">2000</span>);\n    });\n  }\n}\n</code></pre>\n<p>Back in the form component, we extend our <code>submitForm()</code> method to use the service.\nAngular&#39;s <code>submit()</code> function takes care of managing the submission state, including setting the <code>submitting</code> state to <code>true</code> during the operation and resetting it afterward.\nTo handle the actual submission, it accepts a callback function where we can perform our asynchronous logic.\nOnce we called our service to send the data, we call our own <code>resetForm()</code> method: It resets the data signal to the initial state and also clears form states like <code>touched</code> by calling <code>reset()</code>.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// ...</span>\nimport { <span class=\"hljs-comment\">/* ... */</span>, submit } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RegistrationForm</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-meta\">#registrationService = inject(RegistrationService);</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-title\">submitForm</span>()</span> {\n    submit(<span class=\"hljs-keyword\">this</span>.registrationForm, <span class=\"hljs-keyword\">async</span> (form) =&gt; {\n      <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-meta\">#registrationService.registerUser(form().value());</span>\n      console.log(<span class=\"hljs-string\">&#x27;Registration successful!&#x27;</span>);\n      <span class=\"hljs-keyword\">this</span>.resetForm();\n    });\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-title\">resetForm</span>()</span> {\n    <span class=\"hljs-keyword\">this</span>.registrationModel.<span class=\"hljs-keyword\">set</span>(initialState);\n    <span class=\"hljs-keyword\">this</span>.registrationForm().reset();\n  }\n}\n</code></pre>\n<p>It is important to know, that the <code>submit()</code> function not only sets the <code>submitting</code> signal.\nThe passed asynchronous callback function is only executed once the form is not in the state <code>invalid</code> (we will learn more about validation later on).\nAlso, once <code>submit()</code> is called, it marks all form fields as <code>touched</code>, which es very helpful, if we only show error messages related to a form field when a field has been touched.</p>\n<h3 id=\"handling-submission-state\">Handling Submission State</h3>\n<p>To see how the submission state actually changes, we can use it in our template to provide better user feedback.\nWhen submitting the form we can now see that the value of the <code>submitting()</code> signal switches to <code>true</code> as long as the form data is being submitted via our fake service.\nAfter the asynchronous operation is complete, it switches back to <code>false</code>.</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> (<span class=\"hljs-attr\">submit</span>)=<span class=\"hljs-string\">&quot;submitForm()&quot;</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n    <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>\n    [<span class=\"hljs-attr\">disabled</span>]=<span class=\"hljs-string\">&quot;registrationForm().submitting()&quot;</span>\n    [<span class=\"hljs-attr\">aria-busy</span>]=<span class=\"hljs-string\">&quot;registrationForm().submitting()&quot;</span>\n  &gt;</span>\n    @if (registrationForm().submitting()) </span><span class=\"hljs-template-variable\">{ Registering ... }</span><span class=\"language-xml\"> @else </span><span class=\"hljs-template-variable\">{ Register }</span><span class=\"language-xml\">\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></span>\n</code></pre>\n<h2 id=\"basic-schema-based-validation\">Basic Schema-Based Validation</h2>\n<p>One of the most powerful features of Signal Forms is schema-based validation.\nInstead of defining validation rules directly on form controls (as it was usual with Reactive Forms), we now create a declarative schema that describes all validation rules for our form.\nThe interesting part is that this schema is written as code. It is not just a static configuration but can involve additional logic if needed.</p>\n<p>In this first part of our article series, we will give you a very short introduction to schema-based validation.\nThe next part will cover more advanced and complex scenarios ‚Äì so stay tuned!</p>\n<h3 id=\"creating-a-basic-schema\">Creating a Basic Schema</h3>\n<p>Signal Forms use the <code>schema()</code> function to define validation rules.\nAngular comes with some very common rules by default, such as <code>required</code> and <code>minLength</code>.\nThe provided <code>path</code> parameter allows us to navigate through the form structure and apply validation rules to specific fields.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-built_in\">schema</span>,\n  required,\n  minLength,\n} from <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> const registrationSchema = <span class=\"hljs-built_in\">schema</span>&lt;RegisterFormData&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">(path</span>) =&gt;</span> {\n  required(path.username, { <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Username is required&#x27;</span> });\n  minLength(path.username, <span class=\"hljs-number\">3</span>, {\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;A username must be at least 3 characters long&#x27;</span>,\n  });\n  <span class=\"hljs-comment\">// ...</span>\n});\n</code></pre>\n<h3 id=\"applying-the-schema-to-our-form\">Applying the Schema to our Form</h3>\n<p>To actually use the schema, we pass it as the second parameter to the <code>form()</code> function:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// ...</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationForm</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> registrationModel = signal&lt;RegisterFormData&gt;(initialState);\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> registrationForm = form(\n    <span class=\"hljs-keyword\">this</span>.registrationModel,\n    registrationSchema\n  );\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Now our form will automatically validate fields according to the rules defined in our schema.</p>\n<p>It is not strictly necessary to define the schema in a separate variable.\nHowever, this approach makes the schema independent and reusable.</p>\n<h3 id=\"built-in-validator-functions\">Built-in Validator Functions</h3>\n<p>Signal Forms provide several built-in validation functions:</p>\n<table>\n<thead>\n<tr>\n<th>Validator</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>required(path, opts)</code></td>\n<td>Field must be filled. For boolean values, checks for <code>true</code></td>\n<td><code>required(path.username)</code></td>\n</tr>\n<tr>\n<td><code>minLength(path, length, opts)</code></td>\n<td>Minimum character count</td>\n<td><code>minLength(path.username, 3)</code></td>\n</tr>\n<tr>\n<td><code>maxLength(path, length, opts)</code></td>\n<td>Maximum character count</td>\n<td><code>maxLength(path.username, 10)</code></td>\n</tr>\n<tr>\n<td><code>min(path, value, opts)</code></td>\n<td>Minimum numeric value</td>\n<td><code>min(path.age, 18)</code></td>\n</tr>\n<tr>\n<td><code>max(path, value, opts)</code></td>\n<td>Maximum numeric value</td>\n<td><code>max(path.age, 120)</code></td>\n</tr>\n<tr>\n<td><code>email(path, opts)</code></td>\n<td>Valid email address format</td>\n<td><code>email(path.email)</code></td>\n</tr>\n<tr>\n<td><code>pattern(path, regex, opts)</code></td>\n<td>Regular expression match</td>\n<td><code>pattern(path.username, /^[a-zA-Z0-9]+$/)</code></td>\n</tr>\n</tbody></table>\n<p>Each validator function accepts an optional <code>opts</code> parameter where you can specify a custom error message.\nWe can use this message later to display it in the component template.</p>\n<p>A validation schema for our registration form could look like this:</p>\n<pre><code class=\"language-typescript\">export const registrationSchema = schema&lt;RegisterFormData&gt;((path) =&gt; {\n  <span class=\"hljs-comment\">// Username validation</span>\n  required(path.username, { <span class=\"hljs-variable language_\">message</span>: <span class=\"hljs-string\">&#x27;Username is required&#x27;</span> });\n  minLength(path.username, <span class=\"hljs-number\">3</span>, {\n    <span class=\"hljs-variable language_\">message</span>: <span class=\"hljs-string\">&#x27;A username must be at least 3 characters long&#x27;</span>,\n  });\n  maxLength(path.username, <span class=\"hljs-number\">12</span>, {\n    <span class=\"hljs-variable language_\">message</span>: <span class=\"hljs-string\">&#x27;A username can be max. 12 characters long&#x27;</span>,\n  });\n\n  <span class=\"hljs-comment\">// Age validation</span>\n  <span class=\"hljs-built_in\">min</span>(path.age, <span class=\"hljs-number\">18</span>, { <span class=\"hljs-variable language_\">message</span>: <span class=\"hljs-string\">&#x27;You must be &gt;=18 years old.&#x27;</span> });\n\n  <span class=\"hljs-comment\">// Terms and conditions</span>\n  required(path.agreeToTermsAndConditions, {\n    <span class=\"hljs-variable language_\">message</span>: <span class=\"hljs-string\">&#x27;You must agree to the terms and conditions.&#x27;</span>,\n  });\n});\n</code></pre>\n<h3 id=\"form-level-validation-state\">Form-Level Validation State</h3>\n<p>Each part of the form field tree provides a <code>valid()</code> signal with validation state of all field validations below this field tree branch.\nPractically, this means that we can check the overall form validity by calling <code>registrationForm().valid()</code>.</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n@if (!registrationForm().valid()) </span><span class=\"hljs-template-variable\">{\n  &lt;p&gt;The form is invalid. Please correct the errors.&lt;/p&gt;\n}</span><span class=\"language-xml\">\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span> [<span class=\"hljs-attr\">aria-busy</span>]=<span class=\"hljs-string\">&quot;registrationForm().submitting()&quot;</span>&gt;</span>\n  @if (registrationForm().submitting()) </span><span class=\"hljs-template-variable\">{\n    Registering ...\n  }</span><span class=\"language-xml\"> @else </span><span class=\"hljs-template-variable\">{\n    Register\n  }</span><span class=\"language-xml\">\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span></span>\n</code></pre>\n<h2 id=\"displaying-validation-errors\">Displaying Validation Errors</h2>\n<p>To display validation errors, we can access the <code>errors()</code> signal on each field.\nIt returns an array of <code>ValidationError</code> objects, each with a <code>kind</code> property that describes the type of error, e.g., <code>required</code> or <code>minLength</code>.\nThe object can also contain a <code>message</code> property with the error message defined in the schema.\nThese messages can be displayed directly in the template.</p>\n<p>To make the error display reusable, we can create a dedicated component for it:\nThe component can receive any <code>FieldTree</code> and checks for its errors when the field is already marked as touched.\nThis is the case, when either the user has entered the field and left it or when we called the <code>submit()</code> function for our form which marks all form fields as <code>touched</code>.\nIt displays all errors related to the field by iterating over the <code>errors()</code> signal.</p>\n<p>To get access to the <code>FieldState</code>, we have to call the <code>fieldRef</code> property twice: Once to get the <code>FieldTree</code> from the input signal, and a second time to get the <code>FieldState</code> with its reactive properties.</p>\n<pre><code class=\"language-typescript\">import { Component, input } <span class=\"hljs-keyword\">from</span> &#x27;@angular/core&#x27;;\nimport { FieldTree } <span class=\"hljs-keyword\">from</span> &#x27;@angular/forms/signals&#x27;;\n\n@Component({\n  selector: &#x27;app-form-error&#x27;,\n  template: `\n    @let <span class=\"hljs-keyword\">state</span> = fieldRef()();\n    @if (<span class=\"hljs-keyword\">state</span>.touched() &amp;&amp; <span class=\"hljs-keyword\">state</span>.errors().length) {\n      <span class=\"hljs-variable\">&lt;ul&gt;</span>\n        @<span class=\"hljs-keyword\">for</span> (error of <span class=\"hljs-keyword\">state</span>.errors(); track <span class=\"hljs-variable\">$index</span>) {\n          <span class=\"hljs-variable\">&lt;li&gt;</span>{{ error.message }}&lt;/li&gt;\n        }\n      &lt;/ul&gt;\n    }\n  `,\n})\nexport class FormError<span class=\"hljs-variable\">&lt;T&gt;</span> {\n  readonly fieldRef = input.required<span class=\"hljs-variable\">&lt;FieldTree&lt;T&gt;</span>&gt;();\n}\n</code></pre>\n<p>Now we can use this component in our form and pass any field to it.</p>\n<pre><code class=\"language-html\">&lt;<span class=\"hljs-keyword\">label</span>&gt;\n  Username\n  &lt;<span class=\"hljs-keyword\">input</span> <span class=\"hljs-keyword\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> [formField]=<span class=\"hljs-string\">&quot;registrationForm.username&quot;</span> /&gt;\n  &lt;<span class=\"hljs-keyword\">app</span>-<span class=\"hljs-keyword\">form</span>-<span class=\"hljs-keyword\">error</span> [fieldRef]=<span class=\"hljs-string\">&quot;registrationForm.username&quot;</span> /&gt;\n&lt;/<span class=\"hljs-keyword\">label</span>&gt;\n</code></pre>\n<p>We intentionally named the input <code>fieldRef</code> to avoid confusion with the <code>FormField</code> directive.\nWhenever we use the <code>[formField]</code> binding, it applies the directive to a form element.\nSince <code>&lt;app-form-error&gt;</code> is just a helper component, we cannot use the same name for the input property.</p>\n<h2 id=\"demo\">Demo</h2>\n<p>You can find a complete demo application for this blog series on GitHub and Stackblitz:</p>\n<ul>\n<li><strong>‚ö°Ô∏è Stackblitz:</strong> <a href=\"https://stackblitz.com/github/angular-buch/signal-forms-registration\">https://stackblitz.com/github/angular-buch/signal-forms-registration</a></li>\n<li><strong>‚öôÔ∏è Code on GitHub:</strong> <a href=\"https://github.com/angular-buch/signal-forms-registration\">https://github.com/angular-buch/signal-forms-registration</a></li>\n<li><strong>üíª Live Demo:</strong> <a href=\"https://angular-buch.github.io/signal-forms-registration/\">https://angular-buch.github.io/signal-forms-registration/</a></li>\n</ul>\n<h2 id=\"whats-next\">What&#39;s Next?</h2>\n<p>Signal Forms provide a modern and powerful way to handle forms in Angular applications.\nGetting started is straightforward and simple: Create a signal, derive the form structure and connect it to the template using the <code>FormField</code> directive.\nWith schema-based validation, we can define all validation rules in a clear and reusable way.</p>\n<p>In this first part, we&#39;ve covered the fundamentals of Signal Forms:</p>\n<ul>\n<li>Setting up data models and field structures</li>\n<li>Connecting forms to templates</li>\n<li>Basic form submission</li>\n<li>Schema-based validation with built-in validators</li>\n<li>Displaying validation errors</li>\n</ul>\n<p>In <strong>Part 2</strong>, we&#39;ll dive deeper into advanced validation scenarios, including custom validation functions, cross-field validation, asynchronous validation, and handling server-side errors.</p>\n<p>In <strong>Part 3</strong>, we&#39;ll dig into modularization and customization by using child forms and building custom UI controls that integrate seamlessly with Signal Forms. Also we&#39;ll have a look at how to provide a custom <code>SignalFormsConfig</code>.</p>\n<p>In <strong>Part 4</strong>, we&#39;ll explore field metadata and we&#39;ll create a directive which adds accessibility features that help create more inclusive and user-friendly forms.</p>\n<p>Ready to continue? Check out <a href=\"/blog/2025-10-signal-forms-part2\">Part 2: Advanced Validation and Schema Patterns</a>!</p>\n<p><small><strong>Cover image:</strong> Picture from <a href=\"https://pixabay.com/photos/journal-write-blank-pages-notes-2850091/\">Pixabay</a>, edited</small></p>\n","meta":{"title":"Angular Signal Forms Part 1: Getting Started with the Basics","author":"Danny Koppenhagen","mail":"mail@d-koppenhagen.de","author2":"Ferdinand Malcher","mail2":"mail@fmalcher.de","published":"2025-10-13T00:00:00.000Z","lastModified":"2026-01-14T00:00:00.000Z","keywords":["Angular","Signals","Forms","Angular 21","Signal Forms","Schema Validation"],"language":"en","header":{"url":"header-signalforms-part1.jpg","width":2000,"height":1133},"sticky":false}}
