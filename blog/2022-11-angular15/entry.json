{"slug":"2022-11-angular15","html":"<p>Am 16. November 2022 erschien die neue Major-Version von Angular: <strong>Angular 15.0.0</strong>!\nIm Fokus des neuen Releases standen vor allem diese drei Themen:</p>\n<ul>\n<li>Standalone Components gelten nun als <em>stable</em>.</li>\n<li>funktionale Guards, Resolver und Interceptors</li>\n<li>Vereinfachung der initial generierten Projektdateien</li>\n</ul>\n<p>In diesem Blogpost fassen wir wieder die wichtigsten Neuigkeiten zusammen.\nIm englischsprachigen <a href=\"https://blog.angular.io/angular-v15-is-now-available-df7be7f2f4c8\">Angular-Blog</a> finden Sie au√üerdem die offizielle Mitteilung des Angular-Teams.\nAu√üerdem empfehlen wir Ihnen einen Blick in die Changelogs von <a href=\"https://github.com/angular/angular/blob/master/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/master/CHANGELOG.md\">Angular CLI</a>.</p>\n<h2 id=\"projekt-updaten\">Projekt updaten</h2>\n<p>Um ein existierendes Projekt zu aktualisieren, nutzen Sie bitte den <a href=\"https://update.angular.io/?v=14.0-15.0\">Angular Update Guide</a>.\nDer Befehl <code>ng update</code> liefert au√üerdem Infos zu m√∂glichen Updates direkt im Projekt.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Projekt auf Angular 15 aktualisieren</span>\nng update <span class=\"hljs-variable\">@angular</span>/core<span class=\"hljs-variable\">@15</span> <span class=\"hljs-variable\">@angular</span>/cli<span class=\"hljs-variable\">@1</span>5\n</code></pre><p>Dadurch werden nicht nur die Pakete aktualisiert, sondern auch notwendige Migrationen im Code durchgef√ºhrt.\nPr√ºfen Sie danach am Besten mithilfe der Differenzansicht von Git die √Ñnderungen.</p>\n<h2 id=\"funktionale-guards-resolver-und-interceptors\">Funktionale Guards, Resolver und Interceptors</h2>\n<p>Guards, Resolver und Interceptors sind zus√§tzliche Features von Angular, mit denen wir Router und HttpClient steuern k√∂nnen:</p>\n<ul>\n<li>Ein Guard entscheidet, ob eine Navigation ausgef√ºhrt werden darf.</li>\n<li>Ein Resolver l√∂st (asynchrone) Daten auf, bevor eine Route geladen wird.</li>\n<li>Ein Interceptor verarbeitet einen HTTP-Request oder -Response, z. B. um Headerfelder f√ºr die Authentifizierung global hinzuzuf√ºgen.</li>\n</ul>\n<p>Alle drei Bausteine existieren seit vielen Jahren ‚Äì sie wurden aber bislang stets in Form einer Klasse implementiert.\nNun k√∂nnen Guards, Resolver und Interceptors auch als einfache Funktionen definiert werden.\nDer Code wird damit leichtgewichtiger und flexibler.\nWollen wir innerhalb der Funktion Abh√§ngigkeiten √ºber die Dependency Injection anfordern, m√ºssen wir die Funktion <code>inject()</code> nutzen.</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">const</span> authGuard: CanActivateFn = (<span class=\"hljs-keyword\">route</span>, <span class=\"hljs-keyword\">state</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> authService = inject(AuthService);\n  return authService.isAuthenticated;\n};\n</code></pre><pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">const</span> dataResolver: ResolveFn<span class=\"hljs-variable\">&lt;MyData&gt;</span> = (<span class=\"hljs-keyword\">route</span>, <span class=\"hljs-keyword\">state</span>) =&gt; {\n  return inject(MyDataService).getData();\n}\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">myInterceptor</span>: <span class=\"hljs-title class_\">HttpInterceptorFn</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  <span class=\"hljs-attr\">req</span>: <span class=\"hljs-title class_\">HttpRequest</span>&lt;<span class=\"hljs-built_in\">unknown</span>&gt;,\n  <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">HttpHandlerFn</span>\n</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// HTTP-Request weitergeben</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">next</span>(req).<span class=\"hljs-title function_\">pipe</span>(\n    <span class=\"hljs-comment\">// HTTP-Response verarbeiten</span>\n  );\n}\n</code></pre><p>Funktionale Guards und Resolver werden auf dieselbe Weise bereitgestellt wie die klassenbasierten Implementierungen.\nFunktionale Interceptors k√∂nnen derzeit nur mit der neuen Funktion <code>provideHttpClient()</code> genutzt werden, siehe der n√§chste Abschnitt.</p>\n<p>Voraussichtlich mit Angular 15.1 werden klassenbasierte Guards und Resolver als <em>deprecated</em> markiert.\nWir empfehlen also, den Code in Ihren Projekten auf die neuen Schnittstellen zu migrieren.</p>\n<p>In diesem <a href=\"https://twitter.com/Enea_Jahollari/status/1591433703678672896\">Twitter-Post von Enea Jahollari</a> finden Sie ein gelungenes Beispiel f√ºr \ndas Zusammenspiel von Functional Guard, <code>inject()</code>, <code>CanMatch</code> und <code>loadComponent</code>.</p>\n<h2 id=\"standalone-components\">Standalone Components</h2>\n<p>Die mit Angular 14 eingef√ºhrten Standalone Components sind nun als <em>stable</em> eingestuft und k√∂nnen ohne Einschr√§nkungen verwendet werden.\nIm Blog der Angular.Schule haben wir dieses Thema ausf√ºhrlich beleuchtet: <a href=\"https://angular.schule/blog/2022-05-standalone-components\">Standalone Components ‚Äì neu ab Angular 14 (von Ferdinand Malcher)</a>.</p>\n<h3 id=\"neue-standalone-apis\">Neue Standalone APIs</h3>\n<p>In diesem Zuge wurde ein alternativer Weg eingef√ºhrt, um den <code>HttpClient</code> in der Anwendung bereitzustellen.\nBisher mussten wir dazu das <code>HttpClientModule</code> importieren.\nIm Zusammenhang mit Standalone Components k√∂nnen wir die neue Funktion <code>provideHttpClient()</code> nutzen.</p>\n<p>Als Argumente k√∂nnen wir sogenannte <em>Features</em> √ºbergeben ‚Äì zus√§tzliche Funktionen des HttpClients, die einzeln aktiviert werden k√∂nnen.\nAuf diese Weise k√∂nnen wir z. B. funktionale Interceptors registrieren.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> {\n  provideHttpClient,\n  withInterceptors,\n  withInterceptorsFromDi\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideHttpClient(\n      withInterceptors([myInterceptor]),\n      withInterceptorsFromDi()       \n    )\n  ]\n});\n</code></pre><h3 id=\"routerlinkwithhref\">RouterLinkWithHref</h3>\n<p>Mit Standalone Components m√ºssen alle Abh√§ngigkeiten einer Komponente direkt importiert werden.\nDazu geh√∂ren auch die Direktiven des Routers.\nBislang existierten zwei Implementierungen f√ºr den RouterLink: die Direktiven <code>RouterLink</code> und <code>RouterLinkWithHref</code>.\nDiese beiden Implementierungen wurden nun zusammengef√ºhrt, sodass wir stets nur noch <code>RouterLink</code> importieren m√ºssen.</p>\n<pre><code class=\"language-diff\">@Component({\n  template: `<span class=\"language-javascript\">\n    &lt;ul&gt;\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">routerLink</span>=<span class=\"hljs-string\">&quot;/books/1&quot;</span>&gt;</span>Book 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">routerLink</span>=<span class=\"hljs-string\">&quot;/books/2&quot;</span>&gt;</span>Book 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n     &lt;/ul&gt;\n  </span>`,\n  standalone: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-regexp\">//</span> VORHER:\n  imports: [RouterLinkWithHref, RouterLink],\n\n  <span class=\"hljs-regexp\">//</span> NACHHER:\n  imports: [RouterLink],\n })\n <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookListComponent</span> {}\n</code></pre><h2 id=\"weniger-projektdateien\">Weniger Projektdateien</h2>\n<p>Ein neu erstelltes Projekt mit der Angular CLI beinhaltet viele Konfigurationsdateien, die f√ºr den Einstieg in das Framework zun√§chst nicht relevant sind.\nDeshalb hat das Angular-Team daran gearbeitet, die generierten Projektdateien zu reduzieren.\nF√ºr die im Folgenden aufgelisteten Konfigurationsdateien stellt Angular intern eine Standardkonfiguration bereit.\nWollen wir die Werte selbst anpassen, k√∂nnen wir die Dateien manuell anlegen ‚Äì es wird dann die eigene Konfiguration genutzt.</p>\n<ul>\n<li><code>.browserslistrc</code> wird nicht automatisch von <code>ng new</code> generiert.</li>\n<li>Die Karma-Konfiguration <code>karma.conf.js</code> und die Einstiegsdatei f√ºr die Testausf√ºhrung <code>src/test.ts</code> werden nun nicht mehr mit angelegt.</li>\n<li>Die bisher erzeugte Datei <code>polyfills.ts</code> wird nun nicht mehr mit angelegt. Stattdessen akzeptiert die Konfigurationsoption <code>polyfills</code> in der Datei <code>angular.json</code> nun alternativ ein Array von referenzierten Polyfills.</li>\n<li>Die Umgebungsdateien <code>environment.ts</code> und <code>environment.prod.ts</code> werden in neuen Projekten nicht generiert. Der Mechanismus der <code>fileReplacements</code> in der Datei <code>angular.json</code>, der daf√ºr sorgt, dass abh√§ngig vom Build-Target eine andere Datei geladen werden kann, bleibt jedoch weiterhin erhalten. Bei Bedarf k√∂nnen Sie die Environment-Dateien also selbst anlegen und konfigurieren.</li>\n</ul>\n<p>Beim Update auf die neue Angular-Version werden die genannten Dateien nicht entfernt, sondern bleiben bestehen.</p>\n<h2 id=\"komponenten-ohne-konstruktor-und-ngoninit\">Komponenten ohne Konstruktor und <code>ngOnInit()</code></h2>\n<p>Bei neu erzeugten Komponenten wird nun nicht mehr automatisch der Lifecycle-Hook <code>ngOnInit()</code> generiert.\nBen√∂tigen wir die Methode, k√∂nnen wir sie jederzeit manuell implementieren.\nAuch der leere Konstruktor wird f√ºr neue Komponenten nicht mehr automatisch erzeugt.</p>\n<h2 id=\"support-f√ºr-nodejs-18\">Support f√ºr Node.js 18</h2>\n<p>Mit Angular 15 wird nun Node.js in der Version 18 unterst√ºtzt, die am 25.10.2022 in den LTS-Status √ºbergegangen ist.\nDie von Angular offiziell unterst√ºtzten Node.js-Versionen sind damit:</p>\n<ul>\n<li><code>14.20.x</code></li>\n<li><code>16.13.x</code></li>\n<li><code>18.10.x</code></li>\n</ul>\n<p>H√∂here Nebenversionsnummern wie die aktuelle Version 18.12.1 (LTS) funktionieren nach unserer Erfahrung ebenso einwandfrei. Node.js 19 wird jedoch nicht offiziell unterst√ºtzt.</p>\n<h2 id=\"typescript-48-und-es2022\">TypeScript 4.8 und ES2022</h2>\n<p>Angular setzt nun auf TypeScript in der Version 4.8.\n√Ñltere Versionen als 4.8.2 werden nicht mehr unterst√ºtzt.\nAu√üerdem werden Projekte mit Angular 15 standardm√§√üig zu ES2022 kompiliert.\nIn der Datei <code>tsconfig.json</code> finden wir dazu die folgenden Angaben:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: {\n    <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span>\n    <span class=\"hljs-string\">&quot;useDefineForClassFields&quot;</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-string\">&quot;target&quot;</span>: <span class=\"hljs-string\">&quot;ES2022&quot;</span>,\n    <span class=\"hljs-string\">&quot;module&quot;</span>: <span class=\"hljs-string\">&quot;ES2022&quot;</span>,\n    <span class=\"hljs-string\">&quot;lib&quot;</span>: [<span class=\"hljs-string\">&quot;ES2022&quot;</span>, <span class=\"hljs-string\">&quot;dom&quot;</span>]\n  }\n}\n</code></pre><p>Die Option <code>useDefineForClassFields</code> ist notwendig, weil sich das Verhalten von TypeScript und nativem JavaScript bei der Initialisierung von Klassen-Propertys unterscheidet.\nAngular setzt die Option vorsorglich auf <code>false</code>, um das gewohnte Verhalten zu aktivieren und bestehenden Code nicht zu brechen.</p>\n<blockquote>\n<p>Wir haben die Hintergr√ºnde dieser Option ausf√ºhrlich in einem <a href=\"/blog/2022-11-use-define-for-class-fields\">separaten Blogartikel</a> erl√§utert.</p>\n</blockquote>\n<p>Derzeit sind an bestehenden Angular-Projekten keine √Ñnderungen notwendig.\nWir empfehlen Ihnen jedoch, schon jetzt den Code zukunftssicher zu implementieren.\nAbh√§ngigkeiten, die √ºber den Konstruktor mittels Dependency Injection angefordert werden, sollten nicht mehr bei der direkten Initialisierung eines Propertys verwendet werden:</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-comment\">// funktioniert NICHT in JavaScript!</span>\n  <span class=\"hljs-keyword\">data</span>$ = <span class=\"hljs-keyword\">this</span>.service.getData();\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-keyword\">private</span> service: MyDataService) {}\n}\n</code></pre><p>Um das Problem zu l√∂sen, gibt es zwei Ans√§tze:</p>\n<ul>\n<li>a) wir nutzen den Konstruktor oder</li>\n<li>b) wir setzen die Funktion <code>inject()</code> ein.</li>\n</ul>\n<p>Verschieben wir die Initialisierung vollst√§ndig in den Konstruktor, sind die Argumente bereits vorhanden, bevor wir das Property initialisieren.</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-keyword\">data</span>$: Observable&lt;MyData&gt;;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-keyword\">private</span> service: MyDataService) {\n    <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">data</span>$ = <span class=\"hljs-keyword\">this</span>.service.getData();\n  }\n}\n</code></pre><p>Mit der Funktion <code>inject()</code> k√∂nnen wir eine Abh√§ngigkeit direkt anfordern. Verwenden wir die Funktion bei der Initialisierung eines Propertys, steht die Serviceinstanz sofort zur Verf√ºgung:</p>\n<pre><code class=\"language-ts\">import { inject } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{\n  data$ = inject(MyDataService).getData();\n}\n</code></pre><p>Mit beiden Varianten ist der Code zukunftssicher und funktioniert sowohl in TypeScript als auch ES2022.\nEs ist davon auszugehen, dass in Angular irgendwann einmal die Einstellung <code>useDefineForClassFields</code> auf den Standardwert <code>true</code> gesetzt wird.\nWir empfehlen Ihnen also, Ihren Code schon heute m√∂glichst robust zu entwickeln.</p>\n<blockquote>\n<p>Mehr zur Option <code>useDefineForClassFields</code> finden Sie in unserem separaten Blogartikel: <a href=\"/blog/2022-11-use-define-for-class-fields\">TypeScript: useDefineForClassFields ‚Äì zuk√ºnftige Breaking Changes vermeiden (von Johannes Hoppe und Ferdinand Malcher)</a>.</p>\n</blockquote>\n<h2 id=\"directive-composition-api\">Directive Composition API</h2>\n<p>In Angular k√∂nnen wir Direktiven implementieren, um Elemente in den Templates mit weiteren Funktionalit√§ten zu versehen.\nDabei werden solche Direktiven aber stets von au√üen auf einem Element notiert, in der Regel als Attribut.</p>\n<p>Mit der neuen <em>Directive Composition API</em> k√∂nnen wir Direktiven auch von innen heraus anwenden:\nEine Direktive oder Komponente kann damit selbst deklarativ entscheiden, welche weiteren Direktiven auf ihrem Host-Element erzeugt werden.\nDadurch ist es m√∂glich, einzelne Funktionalit√§ten in Direktiven auszulagern und diese dann in Komposition zu verwenden.</p>\n<p>In den Metadaten von Direktiven und Komponenten wird daf√ºr die Eigenschaft <code>hostDirectives</code> verwendet.\nSetzen wir die folgende <code>MyComponent</code> in der Anwendung ein, so werden auf ihrem Host-Element automatisch Instanzen der <code>ToggleOnClickDirective</code> und <code>CoolDirective</code> erzeugt.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  hostDirectives: [ToggleOnClickDirective, CoolDirective]\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{}\n</code></pre><p>Um mit den erzeugten Direktiven zu interagieren, k√∂nnen wir die Klassen mittels Dependency Injection anfordern.\nWir erhalten Zugriff auf die Instanzen und k√∂nnen dort die Propertys und Methoden direkt verwenden.</p>\n<p>Au√üerdem k√∂nnen wir die Inputs und Outputs der Host-Direktiven deklarativ verf√ºgbar machen.\nF√ºr alle M√∂glichkeiten der neuen Schnittstelle m√∂chten wir Sie auf die <a href=\"https://angular.io/guide/directive-composition-api\">offizielle Angular-Dokumentation</a> verweisen.</p>\n<h2 id=\"image-directive-optimierte-verwendung-von-bildern\">Image Directive: optimierte Verwendung von Bildern</h2>\n<p>Die neue Direktive <code>NgOptimizedImage</code> ist nun offiziell stabil und kann uneingeschr√§nkt verwendet werden. \nSie wurde in Angular 14.2 eingef√ºhrt und erm√∂glicht es, das Laden von Bildern zu verbessern, indem sie verschiedene Best Practices durchsetzt.\nBitte beachten Sie, dass es mit Angular 15 eine √Ñnderung in der finalen API gibt:\nDie Direktive besitzt jetzt Inputs mit den Namen <code>ngSrc</code> und <code>ngSrcset</code> (statt urspr√ºnglich <code>rawSrc</code> und <code>rawSrcset</code>).</p>\n<p>Die Einbindung der neuen Direktive ist sehr einfach:\nWir k√∂nnen die Klasse entweder √ºber ein NgModule oder in einer Standalone Component importieren:</p>\n<pre><code class=\"language-ts\">import { NgOptimizedImage } from <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n    \n<span class=\"hljs-regexp\">//</span> einbinden in Standalone Component\n<span class=\"hljs-variable\">@Component</span>({\n  standalone: true\n  imports: [NgOptimizedImage],\n})\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyStandaloneComponent</span> </span>{}\n\n// einbinden in NgModule\n<span class=\"hljs-variable\">@NgModule</span>({\n  imports: [NgOptimizedImage],\n})\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{}\n</code></pre><p>Anschlie√üend k√∂nnen wir im Template der Angular-Komponenten das <code>src</code>-Attribut der Bilder durch <code>ngSrc</code> ersetzen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- VORHER: --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;angular-buch.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- NACHHER: --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">ngSrc</span>=<span class=\"hljs-string\">&quot;angular-buch.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>\n</code></pre><p>Die Direktive <code>NgOptimizedImage</code> wird automatisch aktiv, sobald dieses Attribut eingesetzt wird.\nSie hilft dabei, diverse Best Practices f√ºr Bilder anzuwenden.\nVergisst man etwa, die Attribute <code>width</code> und <code>height</code> f√ºr das <code>img</code>-Element zu verwenden (wie oben gezeigt), so erscheint eine hilfreiche Fehlermeldung:</p>\n<blockquote>\n<p>Error: NG02954: The NgOptimizedImage directive (activated on an <code>&lt;img&gt;</code> element with the <code>ngSrc=&quot;angular-buch.jpg&quot;</code>) has detected that these required attributes are missing: &quot;width&quot;, &quot;height&quot;. Including &quot;width&quot; and &quot;height&quot; attributes will prevent image-related layout shifts. To fix this, include &quot;width&quot; and &quot;height&quot; attributes on the image tag or turn on &quot;fill&quot; mode with the <code>fill</code> attribute.</p>\n</blockquote>\n<p>Wir bekommen ebenso eine Warnung, wenn wir versehentlich eine falsche <code>width</code> und <code>height</code> eintragen. Nat√ºrlich gibt die Direktive nicht nur Fehlermeldungen aus. \nEines der wichtigsten Features ist das &quot;faule&quot; (lazy) Laden von Bildern, sodass die Ladezeiten der einzelnen Routen deutlich verbessert werden k√∂nnen.\nIn diesem Beispiel wird keine Priorit√§t angegeben:</p>\n<pre><code class=\"language-html\">&lt;img <span class=\"hljs-attribute\">ngSrc</span>=<span class=\"hljs-string\">&quot;angular-buch.jpg&quot;</span>  <span class=\"hljs-attribute\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attribute\">width</span>=<span class=\"hljs-string\">&quot;800&quot;</span> <span class=\"hljs-attribute\">height</span>=<span class=\"hljs-string\">&quot;1152&quot;</span>&gt;\n</code></pre><p>Dadurch wird der Browser angewiesen, mit dem Laden des Bilds zu warten, bis der Browser sch√§tzt, dass es unmittelbar ben√∂tigt wird.\nDas Bild wird z. B. beim Scrollen erst dann geladen, wenn es kurz davor ist, im sichtbaren Bereich zu erscheinen.</p>\n<p>Im folgenden Beispiel wird die Priorit√§t gesetzt.\nDiese Option weist den Browser an, das Bild m√∂glichst schnell zu laden.\nDies bietet sich zum Beispiel beim Headerbild eines Blogs an, das wichtig f√ºr den ersten Eindruck ist.</p>\n<pre><code class=\"language-html\">&lt;img ngSrc<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;https://example.org/angular-buch.jpg&quot;</span> alt<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;&quot;</span> width<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;800&quot;</span> height<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;1152&quot;</span> priority&gt;\n</code></pre><p>Zus√§tzlich sollte man dann einen Preconnect-Link zum Header der Seite in der Datei <code>index.html</code> hinzuf√ºgen, wenn die Bilder von einer anderen Domain geladen werden.\nDies weist den Browser an, fr√ºhzeitig eine Netzwerkverbindung zum anderen Server aufzubauen.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;preconnect&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://example.org&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n</code></pre><p>Auch hier gibt die Direktive im Debug-Modus eine Warnung aus, wenn man diese Optimierung vergessen hat:</p>\n<blockquote>\n<p>NG02956: The NgOptimizedImage directive (activated on an <code>&lt;img&gt;</code> element with the <code>ngSrc=&quot;https://example.org/angular-buch.jpg&quot;</code>) has detected that there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <code>&lt;head&gt;</code> of the document:\n<code>&lt;link rel=&quot;preconnect&quot; href=&quot;https://angular-buch.com&quot;&gt;</code></p>\n</blockquote>\n<p>Moderne Browser akzeptieren mehrere Varianten f√ºr ein Bild (<code>srcset</code>), sodass f√ºr die jeweilige Aufl√∂sung das optimale Bild geladen wird.\nZusammen mit einem (vorkonfigurierten oder eigenen) Loader k√∂nnen wir dem Browser mitteilen, wo das optimale Bild f√ºr die aktuelle Aufl√∂sung zu finden ist. Angular bringt bereits Unterst√ºtzung f√ºr folgende kommerzielle Anbieter mit:</p>\n<ul>\n<li>Cloudflare</li>\n<li>Cloudinary</li>\n<li>ImageKit</li>\n<li>Imgix</li>\n</ul>\n<p>Diese Anbieter bereiten die bestehenden Bilder passend auf, sodass man dasselbe Bild nicht manuell in diversen Aufl√∂sungen abspeichern muss.\nIn der offiziellen <a href=\"https://angular.io/guide/image-directive\">Dokumentation zur Direktive</a> und in der <a href=\"https://angular.io/api/common/NgOptimizedImage\">dazugeh√∂rigen API-Dokumentation</a> wird detailliert beschrieben, wie Loader eingebunden werden k√∂nnen.\nEbenso werden dort noch weitere Details zu dem gro√üen Funktionsumfang der Direktive beschrieben.</p>\n<p>Probieren Sie die neue Direktive doch gleich einmal aus.\nWir haben hierf√ºr eine Stackblitz-Demo vorbereitet:<br><strong><a href=\"https://stackblitz.com/edit/angular-ivy-98yfkn?file=src%2Fapp%2Fapp.component.html\">üëâ Demo auf Stackblitz: NgOptimizedImage</a></strong></p>\n<h3 id=\"css-imports-ohne-tilde\">CSS-Imports ohne Tilde</h3>\n<p>Style-Imports aus dem Ordner <code>node_modules</code> wurden bisher mit einer vorangestellten Tilde (<code>~</code>) notiert.\nDieser Weg ist <em>deprecated</em>, und es ist nicht mehr notwendig, die Tilde anzugeben:</p>\n<pre><code class=\"language-diff\"><span class=\"hljs-comment\">/* VORHER: */</span>\n<span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&#x27;~foo/styles.css&#x27;</span>;\n\n<span class=\"hljs-comment\">/* NACHHER: */</span>\n<span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">&#x27;foo/styles.css&#x27;</span>;\n</code></pre><h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Neben den gro√üen neuen Features hat das neue Release viele kleine Verbesserungen und Bug Fixes an Bord.\nEine Auswahl haben wir hier zusammengestellt:</p>\n<ul>\n<li><strong>Utility-Funktionen f√ºr Reactive Forms:</strong> Das Paket <code>@angular/forms</code> exportiert nun die Hilfsfunktionen <code>isFormControl()</code>, <code>isFormGroup()</code> und <code>isFormArray()</code>. Diese Funktionen sind praktisch, wenn der Typ eines Controls im Code gepr√ºft werden muss, z. B. in einem Validator.</li>\n<li><strong>Optionen f√ºr Tree-Shakable Providers:</strong> Das Property <code>providedIn</code> im Decorator <code>@Injectable()</code> tr√§gt in den meisten F√§llen den Wert <code>root</code>. Zwei m√∂gliche andere Optionen wurden nun entfernt: Es ist <em>nicht</em> mehr m√∂glich, dort den Wert <code>any</code> oder eine Modulklasse anzugeben.</li>\n<li><strong>Import f√ºr Localize:</strong> Das Paket <code>@angular/localize</code> muss nicht mehr unter Polyfills eingetragen werden, sondern wird nun √ºber die <code>tsconfig.json</code> referenziert. Die Umstellung wird vom Migrationsskript automatisch vorgenommen.</li>\n<li><strong>Stylus-Support eingestellt:</strong> Angular unterst√ºtzt Style-Definitionen nicht nur in reinem CSS, sondern es k√∂nnen CSS-Pr√§prozessoren genutzt werden: Sass/SCSS und LESS. Der weniger bekannte Pr√§prozessor <em>Stylus</em> wird seit Angular 15 nicht mehr unterst√ºtzt.</li>\n</ul>\n<p>Die Roadmap f√ºr die zuk√ºnftige Entwicklung von Angular wird regelm√§√üig in der Dokumentation ver√∂ffentlicht: <a href=\"https://angular.io/guide/roadmap\">https://angular.io/guide/roadmap</a>.</p>\n<h2 id=\"neue-auflage-des-angular-buchs\">Neue Auflage des Angular-Buchs</h2>\n<p>Wir haben in den letzten Monaten intensiv an einer Neuauflage des deutschsprachigen Angular-Buchs gearbeitet! Das neue Buch erscheint im Februar 2023 in allen Buchhandlungen und Onlineshops.</p>\n<p>Wir haben das Buch neu strukturiert und alle Beispiele neu entwickelt.\nDie neuen Features von Angular 15 werden ebenfalls ausf√ºhrlich behandelt.\n<a href=\"/kaufen\">Bestellen Sie das neue Angular-Buch</a> am besten direkt!</p>\n<div style=\"text-align: center\">\n<img src=\"https://angular-buch.com/assets/img/book-cover-multiple-v4.png\" alt=\"Buchcover 4. Auflage\" style=\"width:500px\">\n</div>\n\n\n<hr>\n\n\n<p>Wir w√ºnschen Ihnen viel Spa√ü mit Angular 15!\nHaben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>\n<p><strong>Viel Spa√ü w√ºnschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Bornholm, D√§nemark, 2022. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 15 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2022-11-25T00:00:00.000Z","lastModified":"2024-11-19T00:00:00.000Z","keywords":["Angular","Angular 15","Update","Functional Guards","Functional Resolvers","Functional Interceptors","Standalone Components"],"language":"de","header":{"url":"angular15.jpg","width":2000,"height":961},"isUpdatePost":true,"hidden":false,"sticky":false,"darkenHeader":false}}
