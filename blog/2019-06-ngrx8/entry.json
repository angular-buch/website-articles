{"slug":"2019-06-ngrx8","html":"<p>Pünktlich zum Pfingstwochenende wurde am 7. Juni 2019 die neue Major-Version von NgRx veröffentlicht!\nDas neue Release 8.0.0 bringt einige Neuerungen mit sich, die vor allem die Produktivität des Entwicklers verbessern sollen.\nDas wahrscheinlich wichtigste Feature sind die neuen Creator-Funktionen für Actions, Reducer und Effects.\nDazu kommt eine Reihe von kleineren Features, die wir in diesem Blogartikel vorstellen möchten.</p>\n<p>Lesen Sie dazu auch den offiziellen <a href=\"https://ngrx.io/guide/migration/v8\">V8 Migration Guide</a> in der NgRx-Dokumentation.</p>\n<h2 id=\"update-auf-ngrx-8\">Update auf NgRx 8</h2>\n<p>Um eine bestehende Anwendung auf das neue NgRx 8 zu aktualisieren, wird ein Update-Skript für die Angular CLI bereitgestellt:</p>\n<pre><code class=\"language-bash\">ng update <span class=\"hljs-title\">@ngrx</span>/<span class=\"hljs-keyword\">store</span>\n</code></pre><p>Das Beispielprojekt <a href=\"https://github.com/angular-buch/book-monkey3-ngrx\"><code>book-monkey3-ngrx</code></a> aus dem Angular-Buch haben wir auf diese Weise ebenfalls aktualisiert.</p>\n<h2 id=\"creator-funktionen-für-actions-reducer-und-effects\">Creator-Funktionen für Actions, Reducer und Effects</h2>\n<p>Ein großer Kritikpunkt an NgRx war seine Verbosität: Um die Features der Bibliothek zu nutzen, musste verhältnismäßig viel Code geschrieben werden.\nEin Beispiel sind <em>Actions</em>, die stets aus einem String-Enum, einer Klasse und einem exportierten Union-Type bestehen:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">BookActionTypes</span> {\n  <span class=\"hljs-title class_\">LoadBooks</span> = <span class=\"hljs-string\">&#x27;[Book] Load Books&#x27;</span>,\n  <span class=\"hljs-title class_\">LoadBooksSuccess</span> = <span class=\"hljs-string\">&#x27;[Book] Load Books Success&#x27;</span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoadBooks</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Action</span> {\n  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-keyword\">type</span> = <span class=\"hljs-title class_\">BookActionTypes</span>.<span class=\"hljs-property\">LoadBooks</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoadBooksSuccess</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Action</span> {\n  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-keyword\">type</span> = <span class=\"hljs-title class_\">BookActionTypes</span>.<span class=\"hljs-property\">LoadBooksSuccess</span>;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">payload</span>: { books: Book[] }</span>) { }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">BookActions</span> = <span class=\"hljs-title class_\">LoadBooks</span> | <span class=\"hljs-title class_\">LoadBooksSuccess</span>;\n</code></pre><p>Bei der Umsetzung dieses Patterns kann man Fehler machen: Vergisst oder vertauscht man ein Detail, so gibt es später einen Fehler, der nicht immer leicht zu erkennen ist. Erstellt man z.B. eine weitere Action durch Copy &amp; Paste und versäumt, es den Type anzupassen – so ergibt sich ein schwer zu identifizierender Bug:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// vorher – Achtung Fehler!</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoadBookSuccess</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Action</span> {\n  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-keyword\">type</span> = <span class=\"hljs-title class_\">BookActionTypes</span>.<span class=\"hljs-property\">LoadBooksSuccess</span>;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">payload</span>: { book: Book }</span>) { }\n}\n</code></pre><p>Am meisten fällt aber die Menge an Code auf: Das Anlegen einer Action ist vergleichsweise aufwendig.</p>\n<p>Um dieses Problem zu lösen, wurden aus der Commmunity heraus verschiedene Bibliotheken entwickelt, um die Erzeugung von Actions (und Reducern und Effects) ausdrucksstärker zu gestalten – darunter die Projekte <a href=\"https://github.com/cartant/ts-action/blob/master/packages/ts-action/README.md\"><code>ts-action</code></a> und <a href=\"https://github.com/co-IT/ngrx-ducks\"><code>ngrx-ducks</code></a>.\nDie Ideen von <code>ts-action</code> wurden mit dem neuen Release schließlich fest in NgRx integriert.</p>\n<p>In Anlehnung an die Funktion <code>createSelector()</code> zum Erstellen von Selektoren kommen nun die neuen Funktionen <code>createAction()</code>, <code>createReducer()</code> und <code>createEffect()</code> hinzu, um die Implementierung von Actions, Reducern und Effects zu vereinfachen.\nWir möchten einmal alle Bausteine in alter und neuer Schreibweise gegenüberstellen.</p>\n<p>Das Beispielprojekt <code>book-monkey3-ngrx</code> haben wir <a href=\"https://github.com/angular-buch/book-monkey3-ngrx/tree/ng8creators\">auf dem separaten Branch <code>ng8creators</code></a> bereits auf die neue API migriert, sodass Sie den Code am Beispiel nachvollziehen können.</p>\n<h3 id=\"schematics-code-mit-creator-funktionen-generieren\">Schematics: Code mit Creator-Funktionen generieren</h3>\n<p>Obwohl die neuen Funktionen nun fest in NgRx integriert sind, müssen Sie keinesfalls sofort umsteigen – Sie können weiterhin den herkömmlichen Weg verwenden.\nAuch in den Schematics zu NgRx versteckt sich das neue Feature hinter einem Flag.\nMöchten Sie Code mit Creator-Funktionen erzeugen, können Sie die Option <code>--creators</code> einsetzen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-selector-tag\">g</span> action foo <span class=\"hljs-attr\">--creators</span>\nng <span class=\"hljs-selector-tag\">g</span> reducer foo <span class=\"hljs-attr\">--creators</span>\nng <span class=\"hljs-selector-tag\">g</span> effect foo <span class=\"hljs-attr\">--creators</span>\n\nng <span class=\"hljs-selector-tag\">g</span> feature foo <span class=\"hljs-attr\">--creators</span>\n</code></pre><h3 id=\"actions-mit-createaction\">Actions mit <code>createAction()</code></h3>\n<p>Zum Anlegen einer Action waren bisher stets ein Eintrag im Enum für den Action-Typen, eine Action-Creator-Klasse und ein Eintrag im exportierten Union-Type nötig:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// vorher</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Action</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@ngrx/store&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">BookActionTypes</span> {\n  <span class=\"hljs-title class_\">LoadBooks</span> = <span class=\"hljs-string\">&#x27;[Book] Load Books&#x27;</span>,\n  <span class=\"hljs-title class_\">LoadBooksSuccess</span> = <span class=\"hljs-string\">&#x27;[Book] Load Books Success&#x27;</span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoadBooks</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Action</span> {\n  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-keyword\">type</span> = <span class=\"hljs-title class_\">BookActionTypes</span>.<span class=\"hljs-property\">LoadBooks</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoadBooksSuccess</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Action</span> {\n  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-keyword\">type</span> = <span class=\"hljs-title class_\">BookActionTypes</span>.<span class=\"hljs-property\">LoadBooksSuccess</span>;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">payload</span>: { books: Book[] }</span>) { }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">BookActions</span> = <span class=\"hljs-title class_\">LoadBooks</span> | <span class=\"hljs-title class_\">LoadBooksSuccess</span>;\n</code></pre><p>Diese drei Bestandteile werden mit <code>createAction()</code> in einem einzigen Aufruf kombiniert.\nDie Struktur des Payloads wird mittels Typparameter über die Funktion <code>props()</code> definiert.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// nachher</span>\n<span class=\"hljs-keyword\">import</span> { createAction, props } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@ngrx/store&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> loadBooks = <span class=\"hljs-title function_\">createAction</span>(<span class=\"hljs-string\">&#x27;[Book] Load Books&#x27;</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> loadBooksSuccess = <span class=\"hljs-title function_\">createAction</span>(\n  <span class=\"hljs-string\">&#x27;[Book] Load Books Success&#x27;</span>,\n  props&lt;{ <span class=\"hljs-attr\">books</span>: <span class=\"hljs-title class_\">Book</span>[] }&gt;()\n);\n</code></pre><h4 id=\"struktur-des-payloads\">Struktur des Payloads</h4>\n<p>Bitte beachten Sie, dass die Payload-Propertys direkt in das Action-Objekt integriert werden – die Daten werden nicht automatisch in ein Unterproperty <code>payload</code> geschachtelt.\nDie Action <code>LoadBooksSuccess</code> hat also in diesem Beispiel die folgende Struktur:</p>\n<pre><code class=\"language-typescript\">{\n  <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">&#x27;[Book] Load Books Success&#x27;</span>,\n  books: Book[]\n}\n</code></pre><p>Womöglich haben Sie den <code>payload</code> mittlerweile lieb gewonnen – oder Sie haben bestehenden Code, der aufwendig migriert werden müsste.\nNatürlich können Sie auch weiterhin mit dem alten Property arbeiten, wenn Sie den Type entsprechend definieren:</p>\n<pre><code class=\"language-typescript\">export <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">loadBooksSuccess</span> = <span class=\"hljs-title function_ invoke__\">createAction</span>(\n  <span class=\"hljs-string\">&#x27;[Book] Load Books Success&#x27;</span>,\n  props&lt;{ <span class=\"hljs-attr\">payload</span>: { <span class=\"hljs-attr\">books</span>: Book[] } }&gt;()\n);\n</code></pre><h4 id=\"action-dispatchen\">Action dispatchen</h4>\n<p>Um eine Action zu dispatchen, musste bisher eine Instanz der Action-Klasse erstellt werden.\nMit <code>createAction()</code> verkürzt sich diese Schreibweise zu einem einfachen Funktionsaufruf:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// vorher</span>\n<span class=\"hljs-keyword\">this</span>.store.dispatch(new LoadBook(isbn));\n\n<span class=\"hljs-comment\">// nachher</span>\n<span class=\"hljs-keyword\">this</span>.store.dispatch(loadBook(isbn));\n</code></pre><h3 id=\"reducer-mit-createreducer\">Reducer mit <code>createReducer()</code></h3>\n<p>Ein Reducer entscheidet anhand einer eintreffenden Action, in welcher Weise der aktuelle State neu berechnet werden muss.\nFür diese Unterscheidung wird traditionell im Reducer ein <em>switch/case</em>-Statement eingesetzt, um auf bestimmte Action-Typen zu reagieren.\nDiese Lösung ist pragmatisch, erfordert aber einiges an Aufmerksamkeit und Vorwissen: Wir können nicht die Action-Klasse zur Unterscheidung verwenden, sondern nur den Action-<em>Typ</em>.\nWichtig ist hier besonders, nicht den <code>default</code>-Fall zu vergessen, da sonst das System nicht korrekt funktioniert.</p>\n<pre><code class=\"language-typescript\">// vorher – Achtung Fehler!\nexport function reducer(<span class=\"hljs-keyword\">state</span> = initialState, action: BookActions): State {\n  switch (action.type) {\n\n    case BookActionTypes.LoadBooks: {\n      return { ...<span class=\"hljs-keyword\">state</span>, loading: true };\n    }\n\n    case BookActionTypes.LoadBooksSuccess: {\n      return {\n        ...<span class=\"hljs-keyword\">state</span>,\n        books: action.payload.books,\n        loading: false\n      };\n    }\n    \n    // <span class=\"hljs-keyword\">default</span> vergessen! :-(\n}\n</code></pre><p>Mit NgRx 8 und der neuen Funktion <code>createReducer()</code> wird diese Schreibweise verkürzt und auf die wesentlichen Bestandteile reduziert:</p>\n<pre><code class=\"language-typescript\">// nachher\nimport { createReducer, <span class=\"hljs-keyword\">on</span> } <span class=\"hljs-keyword\">from</span> &#x27;@ngrx/store&#x27;;\nimport * as BookActions <span class=\"hljs-keyword\">from</span> &#x27;../actions/book.actions&#x27;;\n\n<span class=\"hljs-keyword\">const</span> bookReducer = createReducer(\n  initialState,\n\n  <span class=\"hljs-keyword\">on</span>(BookActions.<span class=\"hljs-built_in\">load</span>Books, <span class=\"hljs-keyword\">state</span> =&gt; {\n    return { ...<span class=\"hljs-keyword\">state</span>, loading: true };\n  }),\n\n  <span class=\"hljs-keyword\">on</span>(BookActions.<span class=\"hljs-built_in\">load</span>BooksSuccess, (<span class=\"hljs-keyword\">state</span>, action) =&gt; {\n    return {\n      ...<span class=\"hljs-keyword\">state</span>,\n      books: action.books,\n      loading: false\n    };\n  })\n);\n\nexport function reducer(<span class=\"hljs-keyword\">state</span>: State | undefined, action: Action): State {\n  return bookReducer(<span class=\"hljs-keyword\">state</span>, action);\n}\n</code></pre><p>Der Import <code>BookActions</code> stellt alle exportierten Actions zur Verfügung, die zuvor mithilfe von <code>createAction()</code> definiert wurden.\nBeachten Sie auch, dass wir aufgrund der neuen Struktur den Payload der Action nicht mehr aus dem Property <code>payload</code> beziehen, sondern direkt aus dem Action-Objekt.</p>\n<h3 id=\"effects-mit-createeffect\">Effects mit <code>createEffect()</code></h3>\n<p>Der Vollständigkeit halber wird auch für Effects eine Creator-Funktion bereitgestellt.\nDamit wird im Wesentlichen der Decorator <code>@Effect()</code> eingespart.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// vorher</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Actions</span>, ofType, <span class=\"hljs-title class_\">Effect</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@ngrx/effects&#x27;</span>;\n\n<span class=\"hljs-meta\">@Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookEffects</span> {\n  \n  <span class=\"hljs-meta\">@Effect</span>()\n  loadBooks$ = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">actions$</span>.<span class=\"hljs-title function_\">pipe</span>(\n    <span class=\"hljs-title function_\">ofType</span>(<span class=\"hljs-title class_\">BookActionTypes</span>.<span class=\"hljs-property\">LoadBooks</span>),\n    <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\">() =&gt;</span>\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getAll</span>().<span class=\"hljs-title function_\">pipe</span>(\n        <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">books</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LoadBooksSuccess</span>({ books })),\n        <span class=\"hljs-title function_\">catchError</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LoadBooksFailure</span>({ error }))))\n    )\n  );\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">actions$</span>: <span class=\"hljs-title class_\">Actions</span>&lt;<span class=\"hljs-title class_\">BookActions</span>&gt;,\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">bs</span>: <span class=\"hljs-title class_\">BookStoreService</span>,\n  </span>) {}\n}\n</code></pre><pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// nachher</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Actions</span>, ofType, createEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@ngrx/effects&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">BookActions</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../actions/book.actions&#x27;</span>;\n\n<span class=\"hljs-meta\">@Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookEffects</span> {\n  \n  loadBooks$ = <span class=\"hljs-title function_\">createEffect</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">actions$</span>.<span class=\"hljs-title function_\">pipe</span>(\n    <span class=\"hljs-title function_\">ofType</span>(<span class=\"hljs-title class_\">BookActions</span>.<span class=\"hljs-property\">loadBooks</span>),\n    <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\">() =&gt;</span>\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getAll</span>().<span class=\"hljs-title function_\">pipe</span>(\n        <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">books</span> =&gt;</span> <span class=\"hljs-title class_\">BookActions</span>.<span class=\"hljs-title function_\">loadBooksSuccess</span>({ books })),\n        <span class=\"hljs-title function_\">catchError</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-title class_\">BookActions</span>.<span class=\"hljs-title function_\">loadBooksFailure</span>({ error }))))\n    )\n  ));\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">actions$</span>: <span class=\"hljs-title class_\">Actions</span>,\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">bs</span>: <span class=\"hljs-title class_\">BookStoreService</span>,\n  </span>) {}\n}\n</code></pre><p>Bitte beachten Sie, dass die Actions hier wieder als Funktionen verwendet werden, nicht mehr als Klassen (ähnlich wie beim Dispatchen).\nDurch das neue Action-Format erübrigt sich auch die Typisierung für das <code>Actions</code>-Observable, das in den Constructor injiziert wird.</p>\n<h4 id=\"einstellungen-für-effects\">Einstellungen für Effects</h4>\n<p>Die Option <code>{ dispatch: false }</code>, die bisher als Argument an den Decorator übergeben wurde, kann nun im zweiten Argument von <code>createEffect()</code> notiert werden.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// vorher</span>\n<span class=\"hljs-variable\">@Effect</span>({ <span class=\"hljs-attribute\">dispatch</span>: false }) loadBooks$ = <span class=\"hljs-comment\">/* ... */</span>\n\n<span class=\"hljs-comment\">// nachher</span>\nloadBooks$ = <span class=\"hljs-built_in\">createEffect</span>(\n  () =&gt; <span class=\"hljs-comment\">/* ... */</span>,\n  { <span class=\"hljs-attribute\">dispatch</span>: false }\n);\n</code></pre><h2 id=\"effects-wiederaufnahme-bei-fehlern\">Effects: Wiederaufnahme bei Fehlern</h2>\n<p>Ein Datenstrom aus einem Observable wird bei Fehlern beendet – das ist eine der grundlegenden Eigenschaften eines Observables.\nDas gilt auch für Effects; hier allerdings kann es zu Problemen führen, wenn ein Fehler in einem Effect nicht korrekt gefangen wird.\nWird das Observable beendet, ist der Effect inaktiv und kann nicht wiederbelebt werden.</p>\n<p>Dieses Problem ließ sich bisher nur mit Disziplin oder unschönen Hilfsmitteln lösen, z.B. ein Operator, der Fehler verschluckt und damit das Observable am Leben hält (<a href=\"https://gist.github.com/JohannesHoppe/6c52f721c42f19b8c63cf563f5665a81\">siehe Beispiel</a>).</p>\n<p>Mit NgRx in Version 8 wurde dieses Verhalten geändert: Tritt ein Fehler im Effect auf, so wird automatisch eine neue Subscription erzeugt, sodass der Effect weiter aktiv ist.\nDiese Änderung ist ein Breaking Change!\nBenötigen Sie einen Effect ohne Resubscribe, so können Sie die Einstellung deaktivieren:</p>\n<pre><code class=\"language-typescript\">loadBooks$ = createEffect(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-comment\">/* ... */</span>,\n  { <span class=\"hljs-attr\">resubscribeOnError</span>: <span class=\"hljs-literal\">false</span> }\n);\n</code></pre><h2 id=\"runtime-checks-immutability-und-serialisierbarkeit\">Runtime Checks: Immutability und Serialisierbarkeit</h2>\n<p>Zwei wichtige Eigenschaften von NgRx sind <em>Immutability</em> und <em>Serialisierbarkeit</em>.\nDas bedeutet, dass Actions und Zustände niemals verändert werden dürfen.\nStattdessen müssen wir z.B. im Reducer stets einen <em>neuen</em> State erzeugen, anstatt den aktuellen zu ändern.</p>\n<p>Das Thema Serialisierbarkeit von Actions und State sorgt schließlich dafür, dass diese Objekte stets problemlos in JSON serialisiert werden können, ohne dass Informationen verloren gehen.</p>\n<p>Die Einhaltung dieser beiden &quot;Auflagen&quot; ist essentiell für NgRx.\nBeide Regeln sind allerdings nicht immer offensichtlich.\nDas Paket <code>ngrx-store-freeze</code> half deshalb bisher dabei, unbeabsichtigte Mutationen zu entdecken.\nDiese Funktionalität und weitere Prüfungen wurden nun direkt in NgRx integriert, und es werden <em>Runtime Checks</em> durchgeführt.\nDabei können vier verschiedene Regeln geprüft werden:</p>\n<ul>\n<li><code>strictStateImmutability</code>: State muss immutable behandelt werden</li>\n<li><code>strictActionImmutability</code>: Actions müssen immutable behandelt werden</li>\n<li><code>strictStateSerializability</code>: State muss serialisierbar sein</li>\n<li><code>strictActionSerializability</code>: Actions müssen serialisierbar sein</li>\n</ul>\n<p>Die Einstellungen werden einzeln aktiviert:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// Runtime Checks aktivieren</span>\n@<span class=\"hljs-title function_ invoke__\">NgModule</span>({\n  <span class=\"hljs-attr\">imports</span>: [\n    // ...\n    StoreModule.<span class=\"hljs-title function_ invoke__\">forRoot</span>(reducers, {\n      <span class=\"hljs-attr\">runtimeChecks</span>: {\n        <span class=\"hljs-attr\">strictStateImmutability</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">strictActionImmutability</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">strictStateSerializability</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">strictActionSerializability</span>: <span class=\"hljs-literal\">true</span>,\n      },\n      metaReducers\n    })\n  ]\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{ }\n</code></pre><p>Voraussichtlich mit Version 9 werden die Immutability-Checks im Entwicklungsmodus standardmäßig aktiviert.\nMehr Infos zu den Runtime Checks und Beispiele finden Sie in der <a href=\"https://ngrx.io/guide/store/configuration/runtime-checks\">Dokumentation von NgRx</a>.</p>\n<h2 id=\"router-store-selektoren-und-forroot\">Router Store: Selektoren und <code>forRoot()</code></h2>\n<p>Das Modul <code>@ngrx/router-store</code> ermöglicht es, den Zustand des Routers ebenfalls über NgRx zu verwalten.\nHier gibt es im neuen Release zwei wichtige Änderungen.</p>\n<h3 id=\"modul-import-mit-forroot\">Modul-Import mit <code>forRoot()</code></h3>\n<p>Das <code>StoreRouterConnectingModule</code> muss ab sofort mit der Methode <code>forRoot()</code> importiert werden.\nDamit wird dieser Import an die herrschende Konvention angeglichen, dass ein gemeinsam genutztes Modul nur Providers mitbringt, wenn es mit <code>forRoot()</code> aufgerufen wird.</p>\n<pre><code class=\"language-typescript\">// vorher\n<span class=\"hljs-variable\">@NgModule</span>({\n  imports: [\n    StoreRouterConnectingModule\n  ],\n  <span class=\"hljs-regexp\">//</span> ...\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{ }\n</code></pre><pre><code class=\"language-typescript\">// nachher\n<span class=\"hljs-variable\">@NgModule</span>({\n  imports: [\n    StoreRouterConnectingModule.forRoot()\n  ],\n  <span class=\"hljs-regexp\">//</span> ...\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{ }\n</code></pre><h3 id=\"selektoren-für-router-state\">Selektoren für Router-State</h3>\n<p>Zusätzlich werden ab sofort einige Selektoren mitgeliefert, um den Router-State effizient auszulesen.\nSo können mit den neuen Selektoren unter anderem die URL und Routenparameter erfasst werden, um sie in Selektoren und Komponenten zu verwenden.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { getSelectors, <span class=\"hljs-title class_\">RouterReducerState</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@ngrx/router-store&#x27;</span>;\n    \n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> selectRouter =\n  createFeatureSelector&lt;<span class=\"hljs-title class_\">State</span>, <span class=\"hljs-title class_\">RouterReducerState</span>&lt;<span class=\"hljs-built_in\">any</span>&gt;&gt;(<span class=\"hljs-string\">&#x27;router&#x27;</span>);\n    \n<span class=\"hljs-keyword\">const</span> {\n  selectRouteParams,\n  selectQueryParams,\n  selectRouteData,\n  selectUrl\n} = <span class=\"hljs-title function_\">getSelectors</span>(selectRouter);\n</code></pre><h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Das neue Release bringt noch einige weitere Änderungen und Neuigkeiten mit sich.\nWir möchten deshalb auf den <a href=\"https://ngrx.io/guide/migration/v8\">offiziellen Migrationsleitfaden</a> und auf den <a href=\"https://github.com/ngrx/platform/blob/master/CHANGELOG.md\">Changelog von NgRx</a> verweisen, wo Sie stets Informationen zu neuen Features erhalten.</p>\n<p><small>Vielen Dank an <strong>Johannes Hoppe</strong> für Review und Ergänzungen!</small><br>\n<small><strong>Titelbild:</strong> Zabriskie Point, Death Valley National Park, California, 2019. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"NgRx v8 – das neue Major-Release ist da","author":"Ferdinand Malcher","mail":"mail@fmalcher.de","published":"2019-06-07T00:00:00.000Z","lastModified":"2019-06-07T00:00:00.000Z","keywords":["NgRx","Redux","Angular","State Management"],"language":"de","header":{"url":"ngrx8.jpg","width":2000,"height":549},"sticky":false,"hidden":false,"darkenHeader":false}}
