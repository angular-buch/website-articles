{"slug":"2023-05-angular16","html":"<p>Am 4. Mai 2023 erschien die neue Major-Version von Angular: <strong>Angular 16</strong>!\nDas Angular-Team hat einige neue Features und Konzepte in diesem Release verpackt.\nDie größte Neuerung sind die <em>Signals</em>, die als erste Developer Preview in der neuen Version ausprobiert werden können.</p>\n<p>Wir fassen in diesem Blogpost die wichtigsten Neuigkeiten in Angular 16 zusammen.\nIm englischsprachigen <a href=\"https://blog.angular.io/angular-v16-is-here-4d7a28ec680d\">Angular-Blog</a> finden Sie die offiziellen Informationen des Angular-Teams.\nAußerdem empfehlen wir Ihnen einen Blick in die Changelogs von <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/main/CHANGELOG.md\">Angular CLI</a>.</p>\n<h2 id=\"projekt-updaten\">Projekt updaten</h2>\n<p>Wenn Sie mit unserem Angular-Buch das Beispielprojekt <em>BookMonkey</em> entwickeln, haben wir gute Nachrichten für Sie:\nEs sind keine Anpassungen am Code notwendig. Die Inhalte des Buchs sind auch mit Angular 16 noch aktuell.</p>\n<p>Um ein existierendes Projekt zu aktualisieren, nutzen Sie bitte den <a href=\"https://update.angular.io/?v=15.0-16.0\">Angular Update Guide</a>.\nDer Befehl <code>ng update</code> liefert außerdem Informationen zu möglichen Updates direkt im Projekt.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Projekt auf Angular 16 aktualisieren</span>\nng update <span class=\"hljs-variable\">@angular</span>/core<span class=\"hljs-variable\">@16</span> <span class=\"hljs-variable\">@angular</span>/cli<span class=\"hljs-variable\">@1</span>6\n</code></pre><p>Dadurch werden nicht nur die Pakete aktualisiert, sondern auch notwendige Migrationen im Code durchgeführt.\nPrüfen Sie danach am Besten mithilfe der Differenzansicht von Git die Änderungen.</p>\n<h2 id=\"unterstützte-versionen-von-typescript-und-nodejs\">Unterstützte Versionen von TypeScript und Node.js</h2>\n<p>Um Angular 16 zu nutzen, sind die folgenden Versionen von TypeScript und Node.js notwendig:</p>\n<ul>\n<li><strong>TypeScript 4.9 oder 5.0</strong>. Der Support für TypeScript 4.8 wurde eingestellt.</li>\n<li><strong>Node.js 16 oder 18</strong>. Node.js in Version 14 wird nicht mehr unterstützt.</li>\n</ul>\n<h2 id=\"reaktivität-mit-signals\">Reaktivität mit Signals</h2>\n<p>Die Change Detection von Angular ist dafür verantwortlich, die angezeigten Daten in der View stets aktuell zu halten.\nDieser Prozess ist aufwendig: Angular erfasst mithilfe der Bibliothek Zone.js alle Ereignisse, die im Browser stattfinden, z. B. DOM-Events, HTTP-Responses, Timer, usw.\nBei jedem dieser Ereignisse werden <em>alle</em> Bindings in <em>allen</em> Komponenten neu evaluiert.\nAngular kann nicht ermitteln, <em>welche</em> Daten sich geändert haben, sondern nur, <em>dass</em> etwas passiert ist.\nDie aktuelle Implementierung der Change Detection funktioniert gut, arbeitet aber nicht gezielt.</p>\n<p>Ab Angular 16 sind die sogenannten <em>Signals</em> als Developer Preview verfügbar!\nEin Signal ist eine &quot;Reactive Primitive&quot;, also ein neuer Grundbaustein für Angular-Apps.\nEs ist ein Objekt, das einen Wert besitzt.\nIm Gegensatz zu einer Variable informiert das Signal alle Interessierten darüber, dass sich der Wert geändert hat.\nAuf diese Weise wird es möglich sein, eine gezielte Change Detection an den Stellen durchzuführen, an denen sich <em>tatsächlich</em> Daten geändert haben.</p>\n<p>Signals sind keine vollständig neue Erfindung von Angular, sondern sind in ähnlicher Form auch in anderen Frameworks wie <a href=\"https://vuejs.org/api/reactivity-core.html\">Vue.js</a> oder <a href=\"https://www.solidjs.com/guides/reactivity\">Solid.js</a> zu finden.\nDas Design der neuen Signals in Angular wird durch <a href=\"https://github.com/angular/angular/discussions/49685\">eine Reihe anspruchsvoller RFCs</a> begleitet.</p>\n<p>Um ein Signal zu erstellen, können wir die Funktion <code>signal()</code> verwenden.\nEs muss immer ein Startwert übergeben werden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{\n  myCounter = signal(<span class=\"hljs-number\">0</span>);\n  \n  <span class=\"hljs-regexp\">//</span> Wir können auch den Datentyp als Generic explizit mit angeben, z. B. bei komplexeren Datentypen.\n  myBook = signal&lt;Book&gt;({ title: <span class=\"hljs-string\">&#x27;Angular&#x27;</span>, <span class=\"hljs-regexp\">/* ... */</span> });\n}\n</code></pre><p>Um den Wert im Template zu lesen, muss das Signal wie eine Funktion aufgerufen werden.\nEs gibt dann synchron den Wert zur Anzeige zurück:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Counter: </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">myCounter</span>() }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre><p>Um den Wert zu aktualisieren, bietet das Signal-Objekt die Methoden <code>set()</code> und <code>update()</code> an.\nMit <code>set()</code> kann der Wert direkt überschrieben werden.\n<code>update()</code> führt eine Aktualisierung auf Basis des aktuellen Werts durch.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">this</span>.myCounter.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-keyword\">this</span>.myCounter.update(c =&gt; c + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 2</span>\n</code></pre><p>Eine Besonderheit dieses neuen Ansatzes sind sogenannte <em>Computed Signals</em>:\nDamit können wir einen Zustand auf der Basis anderer Signals berechnen.\nÄndern sich die Eingabewerte, wird die Berechnung automatisch erneut angestoßen.\nIm folgenden Beispiel wird der Wert für <code>seconds</code> also nur neu berechnet, wenn das Signal <code>milliSeconds</code> seinen Wert ändert.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  milliSeconds = <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>());\n  seconds = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">milliSeconds</span> / <span class=\"hljs-number\">1000</span>);\n\n  <span class=\"hljs-title function_\">updateTime</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">milliSeconds</span>.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>());\n  }\n}\n</code></pre><p>Neben diesen Grundbausteinen soll es später auch möglich sein, Input-Propertys und die Kommunikation mit der Direktive <code>ngModel</code> mit Signals abzubilden.\nAußerdem bieten Signals sogenannte <em>Effects</em> an, mit denen wir auf die Aktualisierung der Werte reagieren können, um Seiteneffekte auszuführen.</p>\n<p>Signals sind außerdem kompatibel mit den bereits etablierten Observables von RxJS, die ebenso eine reaktive Programmierung ermöglichen.\nSignals und Observables können dabei ineinander umgewandelt werden.\nMithilfe von <code>toSignal()</code> werden also die emittierten Werte eines Observables in ein Signal verpackt.\nMit <code>toObservable()</code> können wir die Wertänderungen eines Signals als Observable-Datenstrom ausgeben.</p>\n<pre><code class=\"language-ts\">books = toSignal(inject(BookStoreService).getAllBooks());\n\nmyCounter = <span class=\"hljs-keyword\">signal</span><span class=\"hljs-string\"></span>(<span class=\"hljs-number\">0</span>);\nmyCounter$ = toObservable(<span class=\"hljs-keyword\">this</span>.myCounter);\n</code></pre><p>Im Template können wir die Werte dann wie gewohnt binden:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">books</span>() }}</span><span class=\"language-xml\">\n</span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">myCounter$</span> | async }}</span>\n</code></pre><p>Bitte beachten Sie, dass die Implementierung von Signals noch nicht vollständig ist und mit Angular 16 nur die ersten Aspekte des Konzepts veröffentlicht wurden.\nDie Schnittstellen und Ideen werden sich in den nächsten Monaten formen und weiterentwickeln.\nWir empfehlen Ihnen, die RFC-Dokumente ausführlich zu lesen, und sich so in das Thema aktiv einzuarbeiten.</p>\n<h2 id=\"non-destructive-hydration\">Non-Destructive Hydration</h2>\n<p>Angular bietet mit dem Paket <em>Angular Universal</em> die Möglichkeit, die Anwendung auf dem Server zu rendern.\nDabei erzeugt ein Serverprozess das HTML der angefragten Seite und liefert es an den Browser aus.\nDie Seite wird also schon sichtbar, ohne dass Angular im Browser gestartet werden muss.</p>\n<p>Damit die Anwendung interaktiv wird, muss Angular die bereits angezeigte Seite anschließend &quot;übernehmen&quot;.\nBisher funktioniert dieser Prozess destruktiv, das bedeutet:\nDas HTML vom Server wird gerendert, danach erzeugt Angular im Client alle Elemente erneut!\nDieser Ablauf führt zu einem Flackern (die Seite wird schließlich zweimal geladen) und ist vergleichsweise ineffizient.</p>\n<p>Mit Angular 16 gibt es ein neues Konzept zur <em>Non-Desteructive Hydration</em>. Anstatt die Anwendung vollständig neu zu rendern, übernimmt Angular die bereits sichtbaren DOM-Elemente und fügt nur noch die nötige Interaktivität hinzu, z. B. Event Listener und Bindings.\nDie servergerenderte Seite bleibt also bestehen und wird nach dem Start nur noch erweitert, ohne komplett neu erzeugt zu werden.</p>\n<p>Um die Hydration zu aktivieren, muss die passende Funktion bei den Providers der Anwendung registriert werden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// main.ts</span>\n<span class=\"hljs-keyword\">import</span> { bootstrapApplication, provideClientHydration } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n\nbootstrapApplication(AppComponent, {\n  providers: [provideClientHydration()]\n});\n</code></pre><p>In diesem Zusammenhang möchten wir auf eine kleine Änderung gegenüber dem gedruckten Buchtext hinweisen:\nFür das <code>BrowserModule</code> ist es beim Server-Side Rendering nicht mehr notwendig, die Methode <code>withServerTransition()</code> separat aufzurufen.\nIm <code>AppModule</code> ist also keine Änderung mehr notwendig. Die aktualisierte Datei für den BookMonkey finden Sie <a href=\"https://github.com/book-monkey5/16f-ssr/blob/main/src/app/app.module.ts\">auf GitHub</a>.</p>\n<h2 id=\"standalone-components\">Standalone Components</h2>\n<p>Bereits seit dem <a href=\"/blog/2022-11-angular15\">letzten Major-Release von Angular 15</a> sind die Standalone Components ein stabiler Bestandteil von Angular.\nSeit Angular 16 können neue Projekte vollständig standalone generiert werden.\nDas Projekt besitzt dann kein <code>AppModule</code>, sondern in der Datei <code>main.ts</code> wird direkt die Root-Komponente <code>AppComponent</code> gebootstrappt.</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> &lt;project&gt; <span class=\"hljs-comment\">--standalone</span>\n</code></pre><p>Wir empfehlen Ihnen, neue Anwendungen und neue Features bestehender Anwendungen mit Standalone Components zu entwickeln.\nIm Angular-Buch finden Sie in Kapitel 25 einen ausführlichen Einstieg in Standalone Components.</p>\n<h3 id=\"schematics-zur-migration\">Schematics zur Migration</h3>\n<p>Für eine vereinfachte Migration von modulbasierten Anwendungen zu Standalone Components bietet Angular jetzt ein Migrationsskript an.</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:standalone\n</code></pre><p>Das Skript migriert die Komponenten im Projekt automatisch und importiert dabei alle notwendigen Abhängigkeiten aus dem Template.\nAußerdem ist es möglich, unnötige Module automatisch zu entfernen und die gesamte Anwendung mithilfe der Standalone-APIs zu bootstrappen.</p>\n<h3 id=\"auto-vervollständigungen-für-imports-visual-studio-code\">Auto-Vervollständigungen für Imports (Visual Studio Code)</h3>\n<p>Verwenden wir Standalone Components, müssen wir alle Komponenten, Pipes und Direktiven einzeln importieren, die wir im Template verwenden möchten.\nDie neueste Version des <em>Angular Language Service</em> für Visual Studio Code unterstützt uns dabei: Wenn wir eine Komponente, Pipe oder Direktive im Template einer Komponente verwenden, die noch nicht im Imports-Array aufgeführt ist, wird uns angeboten, diese automatisch hinzuzufügen.</p>\n<h2 id=\"required-inputs\">Required Inputs</h2>\n<p>Inputs von Komponenten und Direktiven waren bislang in Angular immer optional:\nSetzte man eine Komponente im Template ein, war es niemals verpflichtend, Daten mittels Property Bindings auch tatsächlich zu übergeben.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- Vorgesehene Verwendung --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-book</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;myBook&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">app-book</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Property Binding &quot;vergessen&quot; --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-book</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">app-book</span>&gt;</span>\n</code></pre><p>Mit Angular 16 wurde ein lang ersehntes Feature in Angular umgesetzt: Required Inputs.\nDamit können wir angeben, dass ein Input beim Start der Komponente verpflichtend von außen durch ein Property Binding gesetzt werden muss.\nEs ist nicht mehr möglich, das Property versehentlich auszulassen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">@Input</span>({ required: true }) book?: Book;\n</code></pre><p>Verwenden wir die Komponente nun, ohne das Property Binding zu benutzen, wird ein eindeutiger Compile-Fehler ausgegeben:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- Meldung: Required input &#x27;book&#x27; from component BookComponent must be specified --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-book</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">app-book</span>&gt;</span>\n</code></pre><p>Bitte beachten Sie, dass die Inputs weiterhin im Lifecycle der Komponente aufgelöst werden.\nDas bedeutet, dass die übergebenen Daten im Konstruktor noch nicht zur Verfügung stehen!\nDie Initialisierung der Inputs erfolgt erst nach dem Konstruktor.\nWenn wir auf die Initialisierung und Änderung der Input-Propertys reagieren wollen, hilft uns der Lifecycle-Hook <code>ngOnChanges()</code>.</p>\n<pre><code class=\"language-ts\">@Component(<span class=\"hljs-comment\">{ /* ... */ }</span>)\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> BookComponent <span class=\"hljs-keyword\">implements</span> OnChanges <span class=\"hljs-comment\">{\n  @Input({ required: true }</span>) book?: Book;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">constructor</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">{\n    // ⚠️ Ergebnis: undefined\n    console.log(this.book);\n  }</span>\n\n  <span class=\"hljs-title\">ngOnChanges</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">{\n    // wird ausgeführt, wenn Input von außen initialisiert oder geändert wird\n  }</span>\n}</span>\n</code></pre><p>Für die Behandlung von Klassen-Propertys gelten die gleichen Regeln wie bisher:\nJedes Property sollte standardmäßig direkt mit einem Startwert initialisiert werden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Input</span>({ <span class=\"hljs-keyword\">required</span>: <span class=\"hljs-keyword\">true</span> }) isActive = <span class=\"hljs-keyword\">false</span>;\n</code></pre><p>Ist das nicht möglich oder sind die Daten tatsächlich optional, sollte das Property optional gesetzt werden.\nDamit wird auch <code>undefined</code> ein gültiger Wert für das Property.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Input</span>({ <span class=\"hljs-keyword\">required</span>: <span class=\"hljs-keyword\">true</span> }) book?: Book; <span class=\"hljs-comment\">// Book | undefined</span>\n</code></pre><p>Die Non-Null Assertion (<code>!</code>) sollten wir im Regelfall nicht verwenden!\nDas Problem: Der Compiler nimmt an, dass <em>immer</em> ein Wert vom Typ <code>Book</code> vorhanden sei. Da die Inputs aber erst nach dem Konstruktor initialisiert werden und vorher tatsächlich mit <code>undefined</code> belegt sind, entsteht hier eine potenzielle Fehlerquelle.\nWenn wir versuchen, die Daten im Konstruktor zu lesen, tritt der Fehler erst zur Laufzeit auf.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Input()</span> book!: Book; <span class=\"hljs-comment\">// Achtung: nicht verwenden! (schlechte Praxis)</span>\n</code></pre><p>In der Praxis ändert sich also nicht viel an der Verwendung der Propertys.\nWir können nun aber leichter sicherstellen, dass Pflichtwerte auch tatsächlich übergeben werden.</p>\n<h2 id=\"routen-paramater-als-component-inputs\">Routen-Paramater als Component Inputs</h2>\n<p>Um Parameter einer Route auszulesen, verwenden wir üblicherweise den Service <code>ActivatedRoute</code>.\nBesitzt die Route z. B. einen Parameter <code>isbn</code>, können wir den Wert in der Komponente wie folgt auslesen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-keyword\">private</span> route: ActivatedRoute) {\n  <span class=\"hljs-comment\">// Pull</span>\n  <span class=\"hljs-keyword\">const</span> isbn = <span class=\"hljs-keyword\">this</span>.route.snapshot.paramMap.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">&#x27;isbn&#x27;</span>);\n\n  <span class=\"hljs-comment\">// Push</span>\n  <span class=\"hljs-keyword\">this</span>.route.paramMap.subscribe(params =&gt; {\n    <span class=\"hljs-keyword\">const</span> isbn = params.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">&#x27;isbn&#x27;</span>);\n  });\n}\n</code></pre><p>Um diesen Ablauf zu vereinfachen, wurde ein neues Router-Feature eingeführt:\nDer Router kann Parameter, Query-Parameter und Routen-Daten automatisch als Inputs an eine Komponente übergeben.</p>\n<p>Dazu müssen wir in der gerouteten Komponente ein Input-Property definieren, das den gleichen Namen trägt wie der Parameter:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-symbol\">@Input</span>() isbn?: <span class=\"hljs-built_in\">string</span><span class=\"hljs-comment\">;</span>\n</code></pre><p>Dabei werden Path-Parameter, Query-Parameter und Routen-Daten gleichermaßen verarbeitet.\nTragen die verschiedenen Parameter-Typen den gleichen Namen, so ist nur einer der Werte verfügbar.\nSie können die Implementierung im <a href=\"https://github.com/angular/angular/blob/16.0.2/packages/router/src/directives/router_outlet.ts#L414\">Quellcode von Angular</a> nachvollziehen.</p>\n<p>Um das neue Feature des <em>Component Input Binding</em> zu nutzen, müssen wir es im Router aktivieren.\nDies funktioniert nur mit der neuen Funktion <code>provideRouter()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { provideRouter, withComponentInputBinding } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/router&#x27;</span>;\n\nbootstrapApplication(AppComponent,\n  {\n    providers: [\n      provideRouter(routes, withComponentInputBinding())\n    ]\n  }\n);\n</code></pre><h2 id=\"subscriptions-beenden-mit-takeuntildestroyed\">Subscriptions beenden mit <code>takeUntilDestroyed()</code></h2>\n<p>Bei der Arbeit mit Observables müssen wir stets darauf achten, die aufgebauten Subscriptions auch wieder sauber zu entfernen.\nTun wir das nicht, können Memory Leaks entstehen.</p>\n<p>In der Regel verwenden wir in Angular die <code>AsyncPipe</code> direkt im Template: Die Pipe kümmert sich automatisch um Aufräumarbeiten, sobald die Komponente zerstört wird.</p>\n<p>Erstellen wir die Subscription hingegen direkt in der TypeScript-Klasse, mussten wir das Subscription Handling bislang selbst implementieren.\nDafür haben sich eine Reihe unterschiedlicher Patterns etabliert, unter anderem dieses:\nWir nutzen den Operator <code>takeUntil()</code>, um den Datenstrom zu beenden, wenn der übergebene <em>Notifier</em> uns dies signalisiert.\nAls Notifier erstellen wir ein Subject, das wir beim Beenden der Komponente (<code>ngOnDestroy()</code>) einmalig auslösen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">OnDestroy</span> {\n  <span class=\"hljs-keyword\">private</span> destroy$ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Subject</span>&lt;<span class=\"hljs-built_in\">void</span>&gt;();\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    myObservable$.<span class=\"hljs-title function_\">pipe</span>(\n      <span class=\"hljs-title function_\">takeUntil</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">destroy$</span>)\n    ).<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-comment\">/* ... */</span>);\n  }\n\n  <span class=\"hljs-title function_\">ngOnDestroy</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">destroy$</span>.<span class=\"hljs-title function_\">next</span>();\n  }\n}\n</code></pre><p>Wir haben dieses Muster im Angular-Buch in Kapitel 15.9 ausführlich besprochen.\nDer Ansatz funktioniert zwar problemlos, jedoch ist die Anzahl der Codezeilen erstaunlich hoch.\nDie Lesbarkeit des Quellcodes leidet darunter.</p>\n<p>Angular bietet deshalb seit Version 16 einen eigenen Operator <a href=\"https://angular.io/api/core/rxjs-interop/takeUntilDestroyed\"><code>takeUntilDestroyed</code></a> an.\nEr beendet den gegebenen Datenstrom automatisch, sobald die Komponente zerstört wird.\nDas Beispiel kann also elegant verkürzt werden:</p>\n<pre><code class=\"language-ts\">import { takeUntilDestroyed } from <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n\n<span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{\n\n  constructor() {\n    myObservable<span class=\"hljs-variable\">$.</span><span class=\"hljs-keyword\">pipe</span>(\n      takeUntilDestroyed()\n    ).subscribe(<span class=\"hljs-regexp\">/* ... */</span>);\n  }\n}\n</code></pre><p>Bitte beachten Sie, dass der Operator nur in einem <em>Injection Context</em> funktioniert, also bei der Property-Initialisierung oder im Konstruktor.\nEs ist nicht möglich, den Operator in einer anderen Methode der Komponente zu nutzen.</p>\n<p>Unter der Haube des Operators wird die neue Klasse <a href=\"https://angular.io/api/core/DestroyRef\"><code>DestroyRef</code></a> verwendet.\nMit diesem Service können wir Funktionen registrieren, die beim Beenden des aktuellen Kontexts ausgeführt werden.\nDieser Ansatz ermöglicht eine höhere Flexibilität als das altbekannte <code>ngOnDestroy()</code>.</p>\n<h2 id=\"esbuild\">ESBuild</h2>\n<p>Mit Angular 16 wurde ein neues experimentelles Build-System auf Basis von <a href=\"https://esbuild.github.io/\">ESBuild</a> bereitgestellt.\nESBuild soll deutlich schneller ausführen als das alte System.\nWährend der Entwicklung mit <code>ng serve</code> wird dabei der Webserver von <a href=\"https://vitejs.dev/\">Vite</a> genutzt.</p>\n<p>Um den neuen Build auszuprobieren, können wir den passenden Builder in der Datei <code>angular.json</code> aktivieren:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span>\n  <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n    <span class=\"hljs-string\">&quot;build&quot;</span>: {\n      <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;@angular-devkit/build-angular:browser-esbuild&quot;</span>,\n    }\n  }\n}\n</code></pre><p>Bitte beachten Sie, dass das Feature derzeit als <em>Developer Preview</em> veröffentlicht wird.\nDie Entwicklung ist also noch nicht ausgereift, und es sind noch nicht alle Features von Angular vollständig umgesetzt.\nBeispielsweise wird das Tooling zur Internationalisierung bisher noch nicht unterstützt.</p>\n<h2 id=\"jest-test-runner\">Jest Test Runner</h2>\n<p>Für Unit-Tests setzt Angular standardmäßig auf den Test-Runner <em>Karma</em> und das Framework <em>Jasmine</em>.\nEine in der Community beliebte Alternative ist <em>Jest</em>.\nMit Angular 16 wird Jest erstmals direkt out-of-the-box unterstützt.</p>\n<p>Dazu müssen wir Jest zunächst im Projekt installieren:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> i -D jest\n</code></pre><p>Anschließend konfigurieren wir in der Datei <code>angular.json</code> das Test-Target, sodass der neue offizielle Builder für Jest verwendet wird:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;my-app&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>-devkit/build-angular:jest&quot;</span>,\n          <span class=\"hljs-string\">&quot;options&quot;</span>: {\n            <span class=\"hljs-string\">&quot;tsConfig&quot;</span>: <span class=\"hljs-string\">&quot;tsconfig.spec.json&quot;</span>,\n            <span class=\"hljs-string\">&quot;polyfills&quot;</span>: [<span class=\"hljs-string\">&quot;zone.js&quot;</span>, <span class=\"hljs-string\">&quot;zone.js/testing&quot;</span>]\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre><p>Im Angular-Buch (4. Auflage) geben wir in Kapitel 26.6 eine fundierte Einführung in das Framework Jest.</p>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<ul>\n<li>Guards und Resolver werden nun standardmäßig als Funktionen generiert. Die klassenbasierten Guards und Resolver sind deprecated. Siehe <a href=\"22fdd7da97c832048410ca89622712d097490c5d\">22fdd7da</a>. Im Angular-Buch behandeln wir funktionale Guards bereits ausführlich.</li>\n<li>Der NGCC (Angular Compatibility Compiler) wurde entfernt. Dieses Tool war notwendig, um ältere Bibliotheken, die mit der veralteten View Engine kompiliert wurden, mit dem neuen Ivy-Compiler kompatibel zu machen. Da Ivy seit Angular 9.0.0 verfügbar ist, ist davon auszugehen, dass eine Abwärtskompatibilität nicht länger notwendig ist. Siehe <a href=\"https://github.com/angular/angular-cli/commit/c8ac660d8b13922be7ebcc92dfd5b18392602c40\">c8ac660d</a></li>\n</ul>\n<hr>\n\n\n<p>Wir wünschen Ihnen viel Spaß mit Angular 16!\nHaben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß wünschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Blick vom Zellerhorn auf die Burg Hohenzollern, Schwäbische Alb. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 16 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2023-05-22T00:00:00.000Z","lastModified":"2024-11-19T00:00:00.000Z","keywords":["Angular","Angular 16","Update","Signals","Hydration","Standalone Components"],"language":"de","header":{"url":"angular16.jpg","width":2000,"height":992},"isUpdatePost":true,"hidden":false,"sticky":false,"darkenHeader":false}}
