{"slug":"2025-12-signal-forms-part4","html":"<p>In the previous parts of this series, we&#39;ve covered the fundamentals of Signal Forms, advanced validation patterns, and modular form architecture. In this final part, we&#39;ll explore the power of assigning field metadata. We&#39;ll also have a look at how we can automatically add helpful ARIA attributes based on a field state to make our forms even more inclusive and accessible.</p>\n<blockquote>\n<p>‚ö†Ô∏è <strong>Experimental Feature:</strong> Signal Forms are currently an experimental feature in Angular. The API and functionality may change in future releases.</p>\n</blockquote>\n<h2 id=\"related-blog-posts\">Related blog posts</h2>\n<p><strong>This blog post is part of our series about Signal Forms:</strong></p>\n<ul>\n<li><a href=\"/blog/2025-10-signal-forms-part1\">Part 1: Getting Started with Signal Forms</a></li>\n<li><a href=\"/blog/2025-10-signal-forms-part2\">Part 2: Advanced Validation and Schema Patterns</a></li>\n<li><a href=\"/blog/2025-10-signal-forms-part3\">Part 3: Child Forms, Custom UI Controls and SignalFormsConfig</a></li>\n<li><em>Part 4: Metadata and Accessibility Handling</em> (this post)</li>\n</ul>\n<h2 id=\"assigning-field-metadata\">Assigning Field Metadata</h2>\n<p>Signal Forms provide a powerful metadata system that allows you to attach additional information to form fields beyond validation rules.\nThis metadata can be used to provide helpful descriptions, tooltips, or contextual information that enhances the user experience.</p>\n<p>In our example, we want to display hints for users about how to fill the form.\nIn comparison to an error message, this information should be displayed always and not only when the field value is invalid.</p>\n<h3 id=\"creating-metadata-keys\">Creating Metadata Keys</h3>\n<p>Form metadata is stored in keys that we have to define before using them.\nWe create a metadata key by using the <code>createMetadataKey()</code> function.\nThis key acts as a type-safe identifier for different types of metadata.\nTo re-use it in several places, we will put this in a separate file.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// form-props.ts</span>\n<span class=\"hljs-keyword\">import</span> { createMetadataKey } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">FIELD_INFO</span> = createMetadataKey&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n</code></pre><h3 id=\"adding-metadata-to-fields\">Adding Metadata to Fields</h3>\n<p>Next, we assign the metadata to a form field.\nThis happens within the form schema which we pass into the <code>form()</code> function at initialization.\nHere we use the <code>metadata()</code> function which takes three parameters:\nthe schema path, the metadata key (which we just created before), and a function that returns the metadata value.\nIn our case, the metadata value is the string that should be presented to the user as info text for the field.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { metadata } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">FIELD_INFO</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./form-props&#x27;</span>;\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> formSchema = schema&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">path</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// Username validation and metadata</span>\n  <span class=\"hljs-title function_\">required</span>(path.<span class=\"hljs-property\">username</span>, { <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Username is required.&#x27;</span> });\n  <span class=\"hljs-title function_\">minLength</span>(path.<span class=\"hljs-property\">username</span>, <span class=\"hljs-number\">3</span>, { <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;A username must be at least 3 characters long.&#x27;</span> });\n  <span class=\"hljs-title function_\">metadata</span>(path.<span class=\"hljs-property\">username</span>, <span class=\"hljs-variable constant_\">FIELD_INFO</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-string\">&#x27;A username must consist of 3-12 characters.&#x27;</span>);\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// Email metadata</span>\n  <span class=\"hljs-title function_\">metadata</span>(path.<span class=\"hljs-property\">email</span>, <span class=\"hljs-variable constant_\">FIELD_INFO</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-string\">&#x27;Please enter at least one valid e-mail address&#x27;</span>);\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// Password metadata</span>\n  <span class=\"hljs-title function_\">metadata</span>(path.<span class=\"hljs-property\">password</span>, <span class=\"hljs-variable constant_\">FIELD_INFO</span>, <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-string\">&#x27;Please enter a password with min 8 characters and a special character.&#x27;</span>);\n  <span class=\"hljs-comment\">// ...</span>\n});\n<span class=\"hljs-comment\">// ...</span>\n</code></pre><h3 id=\"accessing-metadata-in-components\">Accessing Metadata in Components</h3>\n<p>Once the metadata has been assigned, we can access it in our components.\nWe can check if a field has metadata for the passed metadata key.\nTo retrieve the actual value, we use the <code>metadata()</code> method.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// Check if field has metadata</span>\n<span class=\"hljs-symbol\">if</span> (<span class=\"hljs-meta\">field</span>.metadata(FIELD_INFO)) {\n  const <span class=\"hljs-meta\">info</span> = <span class=\"hljs-meta\">field</span>.metadata(FIELD_INFO)?.()<span class=\"hljs-comment\">;</span>\n  console.log(<span class=\"hljs-meta\">info</span>)<span class=\"hljs-comment\">; // &quot;A username must consist of 3-12 characters.&quot;</span>\n}\n</code></pre><h2 id=\"creating-a-generic-info-display-component\">Creating a generic Info Display Component</h2>\n<p>To create a better user experience, we want to build a unified component that displays field information, validation errors, and loading states.\nThis component replaces the basic <code>FormError</code> component from previous parts with a more comprehensive solution.</p>\n<h3 id=\"the-formfieldinfo-component\">The <code>FormFieldInfo</code> Component</h3>\n<p>Our new component handles multiple types of field states and displays appropriate messages and CSS classes for styling.\nThe component uses a computed signal to determine what messages to display based on the field&#39;s current state:</p>\n<ol>\n<li><strong>Pending state</strong>: Shows loading messages during async validation.</li>\n<li><strong>Error state</strong>: Displays validation error messages when the field is touched and has errors.</li>\n<li><strong>Info state</strong>: Shows helpful metadata information when the field is valid or untouched.</li>\n</ol>\n<p>To get access to the field, we use an input property <code>fieldRef</code> of type <code>FieldTree&lt;T&gt;</code> ‚Äì just like in the previous <code>FormError</code> component.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// form-field-info.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, computed, input } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">FieldTree</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">FIELD_INFO</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../form-props&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-form-field-info&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    @if (messages().length) {\n    &lt;ul&gt;\n      @for (message of messages(); track $index) {\n      &lt;li [class]=&quot;message.cssClass&quot;&gt;\n        &lt;small&gt;{{ message.info }}&lt;/small&gt;\n      &lt;/li&gt;\n      }\n    &lt;/ul&gt;\n    }\n  `</span>,\n  <span class=\"hljs-attr\">styleUrl</span>: <span class=\"hljs-string\">&#x27;./form-field-info.scss&#x27;</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FormFieldInfo</span>&lt;T&gt; {\n  <span class=\"hljs-keyword\">readonly</span> fieldRef = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-title class_\">FieldTree</span>&lt;T&gt;&gt;();\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> messages = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> field = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fieldRef</span>()();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">messages</span>: { <span class=\"hljs-attr\">info</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">cssClass</span>: <span class=\"hljs-string\">&#x27;info&#x27;</span> | <span class=\"hljs-string\">&#x27;pending&#x27;</span> | <span class=\"hljs-string\">&#x27;valid&#x27;</span> | <span class=\"hljs-string\">&#x27;invalid&#x27;</span> }[] = [];\n\n    <span class=\"hljs-keyword\">if</span> (field.<span class=\"hljs-title function_\">pending</span>()) {\n      <span class=\"hljs-comment\">// Show loading state for async validation</span>\n      messages = [{ <span class=\"hljs-attr\">info</span>: <span class=\"hljs-string\">&#x27;Checking validity ...&#x27;</span>, <span class=\"hljs-attr\">cssClass</span>: <span class=\"hljs-string\">&#x27;pending&#x27;</span> }];\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (field.<span class=\"hljs-title function_\">touched</span>() &amp;&amp; field.<span class=\"hljs-title function_\">errors</span>().<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-comment\">// Show validation errors</span>\n      messages = field.<span class=\"hljs-title function_\">errors</span>().<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> ({\n        <span class=\"hljs-attr\">info</span>: e.<span class=\"hljs-property\">message</span> || <span class=\"hljs-string\">&#x27;Invalid&#x27;</span>,\n        <span class=\"hljs-attr\">cssClass</span>: <span class=\"hljs-string\">&#x27;invalid&#x27;</span>\n      }));\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (field.<span class=\"hljs-title function_\">metadata</span>(<span class=\"hljs-variable constant_\">FIELD_INFO</span>)) {\n      <span class=\"hljs-comment\">// Show helpful information when field is valid or untouched</span>\n      messages = [{\n        <span class=\"hljs-attr\">info</span>: field.<span class=\"hljs-title function_\">metadata</span>(<span class=\"hljs-variable constant_\">FIELD_INFO</span>)?.()!,\n        <span class=\"hljs-attr\">cssClass</span>: field.<span class=\"hljs-title function_\">valid</span>() ? <span class=\"hljs-string\">&#x27;valid&#x27;</span> : <span class=\"hljs-string\">&#x27;info&#x27;</span>\n      }];\n    }\n    <span class=\"hljs-keyword\">return</span> messages;\n  });\n}\n</code></pre><h3 id=\"using-the-component\">Using the Component</h3>\n<p>As the final step, we replace the old <code>FormError</code> component with the new <code>FormFieldInfo</code> component in your templates.\nTo make things work, we have to adjust the <code>imports</code> section of the component accordingly.\nAlso we can now remove the <code>pending()</code> check here since it will be handled by our <code>FormFieldInfo</code> component.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>\n  Username\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n    <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span>\n    [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;registrationForm.username&quot;</span>\n  /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-form-field-info</span>\n    <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;username-info&quot;</span>\n    [<span class=\"hljs-attr\">fieldRef</span>]=<span class=\"hljs-string\">&quot;registrationForm.username&quot;</span>\n  /&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Remove the following --&gt;</span>\n  @if (registrationForm.username().pending()) {\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">small</span>&gt;</span>Checking availability ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">small</span>&gt;</span>\n  }\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n</code></pre><p>This unified approach provides users with contextual information at all times, improving the overall form experience by offering guidance before errors occur.\nWith additional metadata, we can display more than errors. All necessary information about the form is defined within the schema.</p>\n<h2 id=\"creating-a-directive-for-adding-aria-attributes-to-form-fields\">Creating a Directive for Adding ARIA Attributes to Form Fields</h2>\n<p>Accessibility is crucial for creating inclusive web applications.\nCurrently we show field-related information close to the field itself by using the <code>FormFieldInfo</code> component we just created.\nThis is great but with the current solution it is not accessible for screen readers: The form field itself and the message aren&#39;t linked semantically.\nTo solve this, we want to create a directive that automatically adds appropriate ARIA attributes to form fields based on their state, making our forms more accessible to users with assistive technologies.</p>\n<h3 id=\"the-fieldariaattributes-directive\">The <code>FieldAriaAttributes</code> Directive</h3>\n<p>This directive automatically manages ARIA attributes based on the field&#39;s current state.\nWith this approach, it replaces also our current solution where we called <code>[aria-invalid]=&quot;ariaInvalidState(...)&quot;</code>.\nWe use a dedicated selector <code>[formFieldAria]</code> for the directive.\nThis way, the directive has its own input binding and can be applied independently alongside the <code>FormField</code> directive.</p>\n<p>The directive receives the field via the <code>formFieldAria</code> input.\nIt also accepts another input with the ID of the HTML element that contains the related messages (info, errors, loading).\nWe will need this ID for the attributes <code>aria-describedby</code> or <code>aria-errormessage</code>, to connect the field with the related messages.\nWe link the id with <code>aria-errormessage</code> when the field is currently invalid and touched.\nOtherwise we link it with <code>aria-describedby</code>.</p>\n<p>To write to the ARIA attributes, we use Host Bindings in the directive&#39;s metadata.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// field-aria-attributes.ts</span>\n<span class=\"hljs-keyword\">import</span> { computed, <span class=\"hljs-title class_\">Directive</span>, input } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">FieldTree</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-meta\">@Directive</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;[formFieldAria]&#x27;</span>,\n  <span class=\"hljs-attr\">host</span>: {\n    <span class=\"hljs-string\">&#x27;[aria-invalid]&#x27;</span>: <span class=\"hljs-string\">&#x27;ariaInvalid()&#x27;</span>,\n    <span class=\"hljs-string\">&#x27;[aria-busy]&#x27;</span>: <span class=\"hljs-string\">&#x27;ariaBusy()&#x27;</span>,\n    <span class=\"hljs-string\">&#x27;[aria-describedby]&#x27;</span>: <span class=\"hljs-string\">&#x27;ariaDescribedBy()&#x27;</span>,\n    <span class=\"hljs-string\">&#x27;[aria-errormessage]&#x27;</span>: <span class=\"hljs-string\">&#x27;ariaErrorMessage()&#x27;</span>,\n  },\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FieldAriaAttributes</span>&lt;T&gt; {\n  <span class=\"hljs-keyword\">readonly</span> formFieldAria = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-title class_\">FieldTree</span>&lt;T&gt;&gt;();\n  <span class=\"hljs-keyword\">readonly</span> fieldDescriptionId = input&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  <span class=\"hljs-keyword\">readonly</span> ariaInvalid = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> state = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">formFieldAria</span>()();\n    <span class=\"hljs-keyword\">return</span> state.<span class=\"hljs-title function_\">touched</span>() &amp;&amp; !state.<span class=\"hljs-title function_\">pending</span>() ? state.<span class=\"hljs-title function_\">errors</span>().<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span> : <span class=\"hljs-literal\">undefined</span>;\n  });\n\n  <span class=\"hljs-keyword\">readonly</span> ariaBusy = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> state = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">formFieldAria</span>()();\n    <span class=\"hljs-keyword\">return</span> state.<span class=\"hljs-title function_\">pending</span>();\n  });\n\n  <span class=\"hljs-keyword\">readonly</span> ariaDescribedBy = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fieldDescriptionId</span>();\n    <span class=\"hljs-keyword\">return</span> !id || <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">ariaInvalid</span>() ? <span class=\"hljs-literal\">null</span> : id;\n  });\n\n  <span class=\"hljs-keyword\">readonly</span> ariaErrorMessage = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fieldDescriptionId</span>();\n    <span class=\"hljs-keyword\">return</span> !id || !<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">ariaInvalid</span>() ? <span class=\"hljs-literal\">null</span> : id;\n  });\n}\n</code></pre><p>We can now remove our method <code>ariaInvalidState()</code> from the <code>RegistrationForm</code> component.\nWe can now remove our method <code>ariaInvalidState()</code> from the <code>RegistrationForm</code> component.\nAlso we remove the manual bindings for <code>aria-invalid</code> from the template of the <code>RegistrationForm</code> since this and other attributes will now be applied by our directive which manages four key ARIA attributes:</p>\n<ul>\n<li><strong><code>aria-invalid</code></strong>: set to <code>true</code> when the field has been touched and contains validation errors.</li>\n<li><strong><code>aria-busy</code></strong>: set to <code>true</code> during async validation to indicate loading state.</li>\n<li><strong><code>aria-describedby</code></strong>: references the ID of the element containing helpful information (when field is valid).</li>\n<li><strong><code>aria-errormessage</code></strong>: references the ID of the element containing error messages (when field is invalid).</li>\n</ul>\n<h3 id=\"using-the-directive\">Using the Directive</h3>\n<p>Since the directive uses its own selector <code>[formFieldAria]</code>, we apply it explicitly alongside <code>[formField]</code> in the template.\nTo use it, we need to import it in our component holding the form in the component&#39;s decorator.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-variable\">@Component</span>({\n  selector: <span class=\"hljs-string\">&#x27;app-registration-form&#x27;</span>,\n  imports: [FormField, FormFieldInfo, FieldAriaAttributes, <span class=\"hljs-regexp\">/* other imports */</span>],\n  <span class=\"hljs-regexp\">//</span> ...\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RegistrationForm</span> </span>{\n  // ...\n}\n</code></pre><p>In the template, we add the <code>[formFieldAria]</code> binding to each form field alongside the existing <code>[formField]</code> directive.\nWe also pass the ID of the targeting message element as the <code>fieldDescriptionId</code> input to connect the field with its description element:</p>\n<pre><code class=\"language-html\">&lt;label&gt;\n  Username\n  &lt;input\n    type<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;text&quot;</span>\n    [formField]<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;registrationForm.username&quot;</span>\n    [formFieldAria]<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;registrationForm.username&quot;</span>\n    fieldDescriptionId<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;username-info&quot;</span>\n  /&gt;\n  &lt;app-form-field-info\n    id<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;username-info&quot;</span>\n    [fieldRef]<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;registrationForm.username&quot;</span>\n  /&gt;\n&lt;/label&gt;\n</code></pre><p>The directive ensures that your Signal Forms automatically provide excellent accessibility support without requiring manual ARIA attribute management.</p>\n<p>You may have noticed, we now used our new Directive and Component only in the main <code>RegistrationForm</code>.\nOf course we should also update our child component <code>IdentityForm</code>.</p>\n<blockquote>\n<p><strong>Outlook:</strong> Instead of using a separate <code>[formFieldAria]</code> selector, we could also combine both directives using Angular&#39;s <a href=\"https://angular.dev/guide/directives/directive-composition-api\">Directive Composition API</a>.\nWith <code>hostDirectives</code> in the decorator, the <code>FieldAriaAttributes</code> directive could automatically include the <code>FormField</code> directive, so only a single binding would be needed in the template.\nWe chose the explicit approach here for clarity, but the Directive Composition API is a great alternative for reducing template verbosity.</p>\n</blockquote>\n<blockquote>\n<p>üí° <strong>Tip:</strong> Besides Signal-Forms-specific accessibility features, don&#39;t forget about native HTML attributes like <code>autocomplete</code>. Setting appropriate <code>autocomplete</code> values (e.g. <code>autocomplete=&quot;username&quot;</code>, <code>autocomplete=&quot;new-password&quot;</code>) helps browsers and password managers fill in fields automatically. This improves usability for all users and is especially helpful for people with motor impairments or cognitive disabilities.</p>\n</blockquote>\n<h2 id=\"handling-invalid-form-submission\">Handling Invalid Form Submission</h2>\n<p>When a user tries to submit an invalid form, we want to provide a good user experience by guiding them to the first field that needs attention.\nWe can leverage the <code>onInvalid</code> callback in the submission configuration for this purpose.</p>\n<h3 id=\"focusing-the-first-invalid-field\">Focusing the First Invalid Field</h3>\n<p>The <code>onInvalid</code> callback is triggered when the user attempts to submit the form while it still contains validation errors.\nWe use the <code>errorSummary()</code> method to get a list of all current errors across the whole form.\nEach error entry provides access to the associated <code>fieldTree</code>.\nInvoking it as a function returns the corresponding <code>FieldState</code>, which exposes the <code>focusBoundControl()</code> method.\nBy calling <code>focusBoundControl()</code> on the first error&#39;s <code>FieldState</code>, the browser focus is moved directly to the first invalid input element in DOM order.</p>\n<p>At the same time, all invalid fields are automatically marked as touched, so their error messages become visible immediately.</p>\n<pre><code class=\"language-typescript\">protected readonly registrationForm = form(\n  <span class=\"hljs-name\">this</span>.registrationModel,\n  formSchema,\n  {\n    submission: {\n      action: async (<span class=\"hljs-name\">form</span>) =&gt; {\n        // ... submission logic\n      },\n      onInvalid: (<span class=\"hljs-name\">form</span>) =&gt; {\n        const errors = form().errorSummary()<span class=\"hljs-comment\">;</span>\n        errors.at(<span class=\"hljs-number\">0</span>)?.fieldTree().focusBoundControl()<span class=\"hljs-comment\">;</span>\n      }\n    },\n  }\n)<span class=\"hljs-comment\">;</span>\n</code></pre><p>With this addition, the form becomes much more user-friendly:\nWhen the user clicks &quot;Register&quot; with invalid data, the focus jumps to the first problematic field and all validation errors are displayed at once.\nSince our <code>FieldAriaAttributes</code> directive links each field to its description element via <code>aria-errormessage</code>, a screen reader will also read out the associated error message as soon as the field receives focus.</p>\n<h2 id=\"demo\">Demo</h2>\n<p>You can find a complete demo application for this blog series on GitHub and Stackblitz:</p>\n<ul>\n<li><strong>‚ö°Ô∏è Stackblitz:</strong> <a href=\"https://stackblitz.com/github/angular-buch/signal-forms-registration\">https://stackblitz.com/github/angular-buch/signal-forms-registration</a></li>\n<li><strong>‚öôÔ∏è Code on GitHub:</strong> <a href=\"https://github.com/angular-buch/signal-forms-registration\">https://github.com/angular-buch/signal-forms-registration</a></li>\n<li><strong>üíª Live Demo:</strong> <a href=\"https://angular-buch.github.io/signal-forms-registration/\">https://angular-buch.github.io/signal-forms-registration/</a></li>\n</ul>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>In this four-part series, we&#39;ve explored the full spectrum of Angular Signal Forms:</p>\n<p><strong><a href=\"/blog/2025-10-signal-forms-part1/\">Part 1</a></strong> covered the fundamentals:</p>\n<ul>\n<li>Data models and field structures</li>\n<li>Template connections with the <code>FormField</code> directive</li>\n<li>Basic form submission and validation</li>\n<li>Built-in validators and error display</li>\n</ul>\n<p><strong><a href=\"/blog/2025-10-signal-forms-part2/\">Part 2</a></strong> dove into schema validation patterns:</p>\n<ul>\n<li>Custom validation functions</li>\n<li>Cross-field and conditional validation</li>\n<li>Asynchronous validation</li>\n<li>Server-side error handling</li>\n</ul>\n<p><strong><a href=\"/blog/2025-10-signal-forms-part3/\">Part 3</a></strong> explored specialized topics:</p>\n<ul>\n<li>Creating modular child forms and combining schemas with <code>apply()</code></li>\n<li>Building custom UI controls with <code>FormValueControl</code></li>\n<li>Providing custom <code>SignalFormsConfig</code> for CSS class management</li>\n</ul>\n<p><strong>Part 4</strong> covers metadata and accessibility:</p>\n<ul>\n<li>Assigning and accessing field metadata for enhanced user guidance</li>\n<li>Creating a unified component for displaying field information, errors, and loading states</li>\n<li>Building a directive that automatically adds ARIA attributes for better accessibility</li>\n<li>Handling invalid form submissions by focusing the first invalid field</li>\n</ul>\n<p>Signal Forms are the third major approach of form handling in Angular.\nAfter Template-Driven Forms and Reactive Forms, Signal Forms aim to make form handling more type-safe, reactive, and declarative.\nAs the new approach continues to evolve from its experimental status, Signal Forms promise to become a cornerstone of modern Angular application development!</p>\n<p><small><strong>Cover image:</strong> Picture from <a href=\"https://pixabay.com/photos/journal-write-blank-pages-notes-2850091/\">Pixabay</a>, edited</small></p>\n","meta":{"title":"Angular Signal Forms Part 4: Metadata and Accessibility Handling","author":"Danny Koppenhagen","mail":"mail@d-koppenhagen.de","author2":"Ferdinand Malcher","mail2":"mail@fmalcher.de","published":"2025-12-08T00:00:00.000Z","lastModified":"2026-02-23T00:00:00.000Z","keywords":["Angular","Signals","Forms","Angular 21","Signal Forms","Metadata","ARIA","a11y","accessibility","Focus Handling"],"language":"en","header":{"url":"header-signalforms-part4.jpg","width":2000,"height":1133},"sticky":false,"hidden":false,"darkenHeader":false}}
