{"slug":"2020-02-angular9","html":"<p>Am 6. Februar 2020 wurde bei Google in Kalifornien der rote Knopf gedrückt: Das lang erwartete neue Release ist da – die neue Major-Version <strong>Angular 9.0</strong>! Wir werden Ihnen in diesem Artikel die wichtigsten Neuerungen vorstellen.</p>\n<p>Durch eine Reihe von Bugs und offene Features hatte sich das Release um einige Wochen verzögert – ursprünglich angestrebt war das Release im November.\nDer wohl wichtigste Punkt ist die Umstellung auf den neuen Renderer <em>Ivy</em>, der einige Features und vor allem Verbesserungen in der Performance mit sich bringt.\nEs gibt auch wieder kleinere Breaking Changes, doch das Update auf die neue Version ist undramatisch und geht leicht von der Hand.</p>\n<p>Die offizielle Ankündigung zum neuen Release mit allen Features finden Sie im <a href=\"https://blog.angular.io/23c97b63cfa3\">Angular Blog</a>.</p>\n<p><strong>Inhalt</strong></p>\n<ul>\n<li><a href=\"/blog/2020-02-angular9#update-auf-angular-9\">Update auf Angular 9</a></li>\n<li><a href=\"/blog/2020-02-angular9#der-neue-ivy-renderer\">Der neue Ivy-Renderer</a><ul>\n<li><a href=\"/blog/2020-02-angular9#bundle-sizes\">Bundle Sizes</a></li>\n<li><a href=\"/blog/2020-02-angular9#aot-per-default\">AOT per Default</a></li>\n<li><a href=\"/blog/2020-02-angular9#change-detection\">Change Detection</a></li>\n<li><a href=\"/blog/2020-02-angular9#testing\">Testing</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2020-02-angular9#server-side-rendering-und-pre-rendering\">Server-Side Rendering und Pre-Rendering</a></li>\n<li><a href=\"/blog/2020-02-angular9#testbedinject-abh%C3%A4ngigkeiten-im-test-anfordern\"><code>TestBed.inject&lt;T&gt;</code>: Abhängigkeiten im Test anfordern <a name=\"testbed-inject\"></a></a></li>\n<li><a href=\"/blog/2020-02-angular9#i18n-mit-angularlocalize\">i18n mit <code>@angular/localize</code> <a name=\"i18n-localize\"></a></a></li>\n<li><a href=\"/blog/2020-02-angular9#viewchild-und-contentchild\"><code>@ViewChild()</code> und <code>@ContentChild()</code> <a name=\"viewchild-contentchild\"></a></a></li>\n<li><a href=\"/blog/2020-02-angular9#weitere-neuigkeiten\">Weitere Neuigkeiten</a><ul>\n<li><a href=\"/blog/2020-02-angular9#verbesserte-typpr%C3%BCfung-in-templates\">Verbesserte Typprüfung in Templates <a name=\"template-checks\"></a></a></li>\n<li><a href=\"/blog/2020-02-angular9#schematics-f%C3%BCr-interceptoren\">Schematics für Interceptoren <a name=\"schematics-interceptor\"></a></a></li>\n<li><a href=\"/blog/2020-02-angular9#providedin-f%C3%BCr-services-any-und-platform\"><code>providedIn</code> für Services: <code>any</code> und <code>platform</code> <a name=\"provided-in\"></a></a></li>\n<li><a href=\"/blog/2020-02-angular9#optional-chaining-mit-typescript\">Optional Chaining mit TypeScript</a></li>\n<li><a href=\"/blog/2020-02-angular9#nullish-coalescing-mit-typescript\">Nullish Coalescing mit TypeScript</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"update-auf-angular-9\">Update auf Angular 9</h2>\n<p>Das Update zur neuen Angular-Version ist in wenigen Schritten getan.\nFalls Ihr Projekt noch nicht in der letzten Version von Angular 8 vorliegt, sollten Sie zunächst das folgende Update erledigen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">update</span> <span class=\"hljs-variable\">@angular</span><span class=\"hljs-operator\">/</span>cli<span class=\"hljs-variable\">@8</span> <span class=\"hljs-variable\">@angular</span><span class=\"hljs-operator\">/</span>core<span class=\"hljs-variable\">@8</span>\n</code></pre><p>Anschließend kann das Update auf Angular 9 erfolgen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">update</span> <span class=\"hljs-variable\">@angular</span><span class=\"hljs-operator\">/</span>cli<span class=\"hljs-variable\">@9</span> <span class=\"hljs-variable\">@angular</span><span class=\"hljs-operator\">/</span>core<span class=\"hljs-variable\">@9</span>\n</code></pre><p>Die Angular CLI führt automatisch alle nötigen Anpassungen am Code der Anwendung durch, sofern notwendig.\nHier zeigt sich bereits die erste Neuerung: Beim <code>ng update</code> werden ab sofort ausführliche Informationen zu neuen Features ausgegeben, die Ihnen beim Update helfen.\nAußerdem verwendet die Angular CLI zur Durchführung des Updates unter der Haube jetzt immer die Version, auf die Sie updaten wollen.</p>\n<p>Auf <a href=\"https://update.angular.io/#8.0:9.0\">update.angular.io</a> können Sie übrigens wie üblich alle Migrationsschritte im Detail nachvollziehen und die Migration vorbereiten.</p>\n<h2 id=\"der-neue-ivy-renderer\">Der neue Ivy-Renderer</h2>\n<p>Die wohl größte Neuerung in Angular 9.0 ist der neue Renderer und Compiler <em>Ivy</em> – also der Baustein, der die Templates mit Angular-Ausdrücken in JavaScript-Anweisungen umsetzt, die im Browser den DOM generieren.\nDer neue Ivy-Renderer löst die vorherige <em>View Engine</em> vollständig ab.\nIvy konnte bereits mit Angular 8 als Opt-In genutzt werden, ist ab sofort aber standardmäßig aktiv.</p>\n<p>Ivy soll vollständig abwärtskompatibel sein. Für die meisten Nutzer ändert sich also nichts, in wenigen Ausnahmefällen könnte es zu Problemen mit der Kompatibilität mit alten Anwendungen kommen.</p>\n<p>Das Projekt Ivy hat das Angular-Team nun fast zwei Jahre beschäftigt – doch das Ergebnis kann sich sehen lassen.\nIvy verspricht vor allem <strong>kleinere Bundles</strong>, was den Download beschleunigt und damit die <strong>generelle Performance</strong> der Anwendung deutlich erhöht.\nEbenso bringt Ivy deutlich bessere Performance beim Kompilieren, verbessertes Tree Shaking, Template Checks und aufschlussreichere Fehlermeldungen mit sich.\nIvy wurde sehr lange und intensiv getestet, um in den meisten Projekten eine nahtlose Umstellung zu ermöglichen.\nSollten Sie bei der Migration zu Angular 9 dennoch unerwartet Probleme haben, so besteht noch immer die Möglichkeit, Ivy durch ein Opt-Out wieder zu deaktivieren:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-comment\">// tsconfig.json</span>\n<span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;angularCompilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;enableIvy&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">false</span></span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre><p>Nachfolgend wollen wir noch etwas konkreter auf ein paar wichtige Features und Verbesserungen von Ivy eingehen.</p>\n<h3 id=\"bundle-sizes\">Bundle Sizes</h3>\n<p>Das Entfernen von ungenutztem Code (&quot;Tree Shaking&quot;) wurde mit dem Ivy-Compiler weiter verbessert.\nVon den Verbesserungen profitieren vor allem kleine und große Anwendungen.</p>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2020-02-angular9/bundle-sizes.png\" alt=\"\"></p>\n<blockquote>\n<p>Bei kleinen Anwendungen konnte die Paketgröße um etwa 30 %, bei großen Anwendungen um 25-40 % und bei mittleren Anwendungen nur minimal reduziert werden. (<a href=\"https://blog.angular.io/23c97b63cfa3\">Quelle</a>)</p>\n</blockquote>\n<p>Da die Anwendung insgesamt kleiner ist, kann sie schneller heruntergeladen und ausgeführt werden.\nDadurch startet die Anwendung auch deutlich schneller.</p>\n<h3 id=\"aot-per-default\">AOT per Default</h3>\n<p>Mit Ivy wird standardmäßig die <em>Ahead-of-Time Compilation (AOT)</em> eingesetzt – auch bei der Entwicklung.\nDas bedeutet, dass die Templates bereits zur Buildzeit in JavaScript umgesetzt werden und nicht erst zur Laufzeit im Browser.</p>\n<p>Bisher wurde beim Ausführen von <code>ng serve</code> (Development Server) und auch bei der Ausführung der Tests die <em>Just-in-Time Compilation (JIT)</em> genutzt – die Anwendung wird also zur Laufzeit im Browser kompiliert.\nDas lag vor allem daran, dass JIT mit dem alten Renderer deutlich schneller arbeitet als AOT, wenn häufige Rebuilds zur Entwicklungszeit durchgeführt werden mussten.\nFür den Produktiv-Build wurde auch bisher schon die AOT-Kompilierung verwendet.</p>\n<p>Durch die zwei verschiedenen Compiler-Modi konnte es vereinzelt zu unerwünschten Nebeneffekten kommen: Bei der Entwicklung lief die Anwendung reibungslos und alle Tests waren grün.\nIm Produktivmodus mit AOT tauchten dann plötzlich Fehler auf, die vorher nicht erkennbar waren.</p>\n<p>Mit Ivy hat sich die Performance beim Kompilieren massiv verbessert, so dass der AOT-Modus nun standardmäßig immer aktiv sein kann.\nSomit kann man sichergehen, dass bei der Entwicklung und im Produktivbetrieb stets derselbe Modus eingesetzt wird und Fehler bereits frühzeitig erkannt werden können.</p>\n<h3 id=\"change-detection\">Change Detection</h3>\n<p>Wer sich einen Überblick über den Prozess der Change Detection mit Ivy machen will, sollte einen Blick auf die <a href=\"https://alexzuza.github.io/angular-9-ivy-change-detection-preview/\">Visualierung von Alexey Zuev</a> werfen.</p>\n<h3 id=\"testing\">Testing</h3>\n<p>Mit Ivy wird nicht nur die Anwendung performanter, sondern auch die Ausführung der Tests.\nBis einschließlich Angular 8 wurden vor jedem Testschritt alle Komponenten neu kompiliert.\nAb Angular 9 werden die Komponenten und Module bei der Verwendung von <code>TestBed</code> gecachet.\nSomit können die Tests erheblich schneller ausgeführt werden.</p>\n<h2 id=\"server-side-rendering-und-pre-rendering\">Server-Side Rendering und Pre-Rendering</h2>\n<p>Mit Version 9 wurde das Tooling für Server-Side Rendering mit Angular Universal verbessert.</p>\n<p>Angular Universal bringt nun eigene Builder mit, die den Buildprozess erledigen.\nEs ist nicht mehr notwendig, die Webpack-Config für den Serverprozess oder das Pre-Rendering selbst zu pflegen.</p>\n<p>Mithilfe von <code>ng add</code> können wir alles Nötige einrichten, um Angular Universal zu verwenden:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> @nguniversal/express-engine</span>\n</code></pre><p>Es wird automatisch die Konfiguration für den Universal Builder in die <code>angular.json</code> eingefügt.\nDie Datei <code>server.ts</code> enthält den Code für den Node.js-Server, der die Anwendung später ausliefert.\nNeu mit Angular 9 ist, dass für die Serverseite nur noch ein einziges Bundle erstellt wird, das die Angular-Anwendung und den Node.js-Server zusammen beinhaltet.</p>\n<p>Für Pre-Rendering vereinfacht sich der Workflow enorm.\nWährend wir bisher immer ein eigenes Skript erstellen mussten, um statische HTML-Seiten aus der Anwendung zu generieren, übernimmt das Angular-Tooling all das ab sofort automatisch.\nIn der <code>angular.json</code> befindet sich dazu der folgende neue Abschnitt:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-string\">&quot;prerender&quot;</span>: {\n  <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;@nguniversal/builders:prerender&quot;</span>,\n  <span class=\"hljs-string\">&quot;options&quot;</span>: {\n    <span class=\"hljs-string\">&quot;routes&quot;</span>: [\n      <span class=\"hljs-string\">&quot;/&quot;</span>,\n      <span class=\"hljs-string\">&quot;/books&quot;</span>\n    ]\n    <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span>\n  },\n  <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span>\n}\n</code></pre><p>Hier müssen wir lediglich die Routen eintragen, für die das Pre-Rendering ausgeführt werden soll.\nDer folgende Befehl startet dann den Build-Prozess:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-built_in\">run</span> book-rating:prerender\nnpm <span class=\"hljs-built_in\">run</span> prerender <span class=\"hljs-comment\"># Alternativ: Kurzform als NPM-Skript</span>\n</code></pre><p>Die notwendigen Schritte erledigt die Angular CLI bzw. der Universal Builder nun für uns.\nDamit verringert sich die Fehleranfälligkeit, die es bisher mit selbst konfigurierten Skripten gab.</p>\n<h2 id=\"testbedinject-abhängigkeiten-im-test-anfordern\"><code>TestBed.inject&lt;T&gt;</code>: Abhängigkeiten im Test anfordern <a name=\"testbed-inject\"></a></h2>\n<p>Bisher wurden Abhängigkeiten in Tests mittels <code>Testbed.get&lt;any&gt;()</code> angefordert.\nMit Angular 9 wurde diese Methode als <em>deprecated</em> markiert – stattdessen sollte nun <code>TestBed.inject&lt;T&gt;</code> genutzt werden.\nDer Unterschied liegt hier in der Typsicherheit:\nMit <code>TestBed.inject()</code> ist der Rückgabewert mittels Typinferenz korrekt typisiert, und wir können auf die Propertys der Klasse zugreifen.\nDas alte <code>TestBed.get()</code> lieferte hingegen stets <code>any</code> zurück.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// book-store.service.spec.ts</span>\nit(<span class=\"hljs-string\">&#x27;infers dependency types&#x27;</span>, () =&gt; {\n  <span class=\"hljs-comment\">// `service` ist vom Typ `BookStoreService`</span>\n  <span class=\"hljs-keyword\">const</span> service = TestBed.inject(BookStoreService);\n});\n</code></pre><p>Grundsätzlich können beide Methoden synonym verwendet werden.\nTechnisch handelt es sich dennoch um einen Breaking Change, deshalb war es nötig, die Änderung über eine neue Methode anzubieten.</p>\n<h2 id=\"i18n-mit-angularlocalize\">i18n mit <code>@angular/localize</code> <a name=\"i18n-localize\"></a></h2>\n<p>Ein neues Paket mit dem Namen <code>@angular/localize</code> wurde mit Angular 9 eingeführt.\nDieses Paket ist ab sofort die Grundlage für die Internationalisierung (i18n) in Angular.</p>\n<p>Bei einem bestehenden Projekt mit Internationalisierung wird der Update-Prozess einige Änderungen an der <code>angular.json</code> durchführen.\nBeim Start der Applikation werden Sie anschließend folgende Nachricht in der Konsole sehen:</p>\n<blockquote>\n<p>ERROR Error: Uncaught (in promise): Error: It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global <code>$localize()</code> function that needs to be loaded.\nPlease run <code>ng add @angular/localize</code> from the Angular CLI.</p>\n</blockquote>\n<p>Wie in der Nachricht bereits vorgeschlagen müssen wir folgenden Befehl ausführen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> @angular/localize</span>\n</code></pre><p>Die Datei <code>polyfills.ts</code> wird um einen neuen Import ergänzt, der die Funktion <code>$localize()</code> verfügbar macht.\nSchon ist das Update prinzipiell durchgeführt.\nDie Syntax zur Übersetzung von Templates wurde nicht verändert.\nWeiterhin markieren wir die zu übersetzenden Stellen im HTML durch das <code>i18n</code>-Attribut:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">i18n</span>=<span class=\"hljs-string\">&quot;@@HelloWorld&quot;</span>&gt;</span>Hello World!!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n</code></pre><p>Eine Übersetzung von Strings im TypeScript-Code war bislang nicht möglich.\nDieses dringend benötigte Feature ist nun endlich verfügbar:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> test = $localize`@<span class=\"hljs-symbol\">@HelloWorld`</span><span class=\"hljs-comment\">;</span>\n</code></pre><p>Wir sehen hier den Einsatz der neuen global verfügbaren Funktion <code>$localize()</code>.\nDiese Methode muss nicht importiert werden und kann als <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\">&quot;Tagged Template&quot;</a> verwendet werden.</p>\n<p>In dem obigen Beispiel fehlt noch die Standard-Übersetzung – im Template-Beispiel lautete diese <code>Hello World!!</code>.\nDas entsprechende Äquivalent können wir mit zwei zusätzlichen Doppelpunkten ausdrücken:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> test = $localize`:@<span class=\"hljs-symbol\">@HelloWorld</span>:Hello World!!`<span class=\"hljs-comment\">;</span>\n</code></pre><p>Eine weitere stark nachgefragte Funktionalität sind Übersetzungen zur Laufzeit.\nDamit kann Angular leider immer noch nicht (ganz) aufwarten.\nAngular unterstützt nun aber die Möglichkeit, zum Start der Applikation (also vor dem &quot;Boostrapping&quot;) die notwendigen Übersetzungen bereitzustellen.\nDadurch muss man die Applikation nicht mehr langwierig in diverse Sprachen kompilieren.\nHierfür gibt es die neue Funktion <code>loadTranslations()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// main.ts</span>\n<span class=\"hljs-keyword\">import</span> { loadTranslations } from <span class=\"hljs-string\">&#x27;@angular/localize&#x27;</span>;\n\nloadTranslations({\n  <span class=\"hljs-attr\">HelloWorld</span>: <span class=\"hljs-string\">&#x27;Hallo Welt!!&#x27;</span>\n});\n\nplatformBrowserDynamic()\n  .bootstrapModule(AppModule)\n  .<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n</code></pre><p>Wir können auch einen Schritt weitergehen und die Übersetzungen aus einer JSON-Datei nachladen.\nWichtig ist dabei nur, dass <code>loadTranslations()</code> vor <code>bootstrapModule()</code> ausgeführt werden muss.\nHierfür stellt Angular derzeit keinen Helfer bereit.\nDiese Lücke füllt das Projekt <a href=\"https://github.com/loclapp/locl\"><code>locl</code></a> vom ehemaligen Angular-Teammitglied Olivier Combe.\nFolgendes Beispiel demonstriert das Nachladen von Übersetzungen vor dem &quot;Bootstrapping&quot;:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// main.ts</span>\n<span class=\"hljs-keyword\">import</span> { loadTranslations } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/localize&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { getTranslations, <span class=\"hljs-title class_\">ParsedTranslationBundle</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@locl/core&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> messages = <span class=\"hljs-string\">&#x27;/assets/i18n/messages.de.json&#x27;</span>;\n<span class=\"hljs-title function_\">getTranslations</span>(messages).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">data: ParsedTranslationBundle</span>) =&gt;</span> {\n  <span class=\"hljs-title function_\">loadTranslations</span>(data.<span class=\"hljs-property\">translations</span>);\n  <span class=\"hljs-title function_\">platformBrowserDynamic</span>()\n    .<span class=\"hljs-title function_\">bootstrapModule</span>(<span class=\"hljs-title class_\">AppModule</span>)\n    .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err));\n});\n</code></pre><p>Mehr zu der Methode <code>getTranslations()</code> erfahren Sie auf der <a href=\"https://github.com/loclapp/locl/tree/master/libs/core#usage\">GitHub-Seite des Projekts</a>.</p>\n<h2 id=\"viewchild-und-contentchild\"><code>@ViewChild()</code> und <code>@ContentChild()</code> <a name=\"viewchild-contentchild\"></a></h2>\n<p>Mit Angular 8 gab es einen Breaking Change bei den Dekoratoren <code>@ViewChild()</code> und <code>@ContentChild()</code>: Es wurde das Flag <code>static</code> eingeführt, mit dem eine solche Query als statisch oder dynamisch markiert werden muss.\nDie Änderung war notwendig, weil sich das Standardverhalten der beiden Dekoratoren mit Angular 9 ändern sollte.\nIn unserem <a href=\"https://angular-buch.com/blog/2019-06-angular8#breaking-change-viewchild-und-contentchild-\">Artikel zum Update auf Angular 8</a>, haben wir die Thematik im Detail beschrieben.</p>\n<p>Mit Angular 9 ist die Änderung final umgesetzt: Alle Querys sind nun grundsätzlich dynamisch, falls nicht anders angegeben.\nEs ist also nicht länger notwendig, das <code>static</code>-Flag für <code>@ViewChild()</code> und <code>@ContentChild()</code> explizit auf <code>false</code> zu setzen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Dynamische Query ab Angular 9:</span>\n<span class=\"hljs-variable\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>) <span class=\"hljs-attribute\">foo</span>: ElementRef;\n<span class=\"hljs-variable\">@ContentChild</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>) <span class=\"hljs-attribute\">bar</span>: ElementRef;\n\n<span class=\"hljs-comment\">// Statische Query ab Angular 8:</span>\n<span class=\"hljs-variable\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: true }) <span class=\"hljs-attribute\">foo</span>: ElementRef;\n<span class=\"hljs-variable\">@ContentChild</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: true }) <span class=\"hljs-attribute\">bar</span>: ElementRef;\n\n<span class=\"hljs-comment\">// Dynamische Query in Angular 8:</span>\n<span class=\"hljs-comment\">// Das Ergebnis ist im LifeCycle-Hook `ngAfterViewInit()` verfügbar</span>\n<span class=\"hljs-comment\">// `{ static: false }` musste explizit gesetzt werden</span>\n<span class=\"hljs-variable\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: false }) <span class=\"hljs-attribute\">foo</span>: ElementRef;\n<span class=\"hljs-variable\">@ContentChild</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: false }) <span class=\"hljs-attribute\">bar</span>: ElementRef;\n</code></pre><h2 id=\"weitere-neuigkeiten\">Weitere Neuigkeiten</h2>\n<p>Wir haben in diesem Artikel nur die wichtigsten Änderungen und Neuigkeiten erwähnt.\nDas neue Major-Release bringt dazu eine Vielzahl von Bugfixes, Optimierungen unter der Haube und kleinere Features, die für die meisten Entwicklerinnen und Entwickler zunächst nicht relevant sind.</p>\n<p>Eine detaillierte Liste aller Änderungen finden Sie im offiziellen <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md#900-2020-02-06\">Changelog von Angular</a> und <a href=\"https://github.com/angular/angular-cli/releases/tag/v9.0.0\">der Angular CLI</a> zum Release 9.0.</p>\n<h3 id=\"verbesserte-typprüfung-in-templates\">Verbesserte Typprüfung in Templates <a name=\"template-checks\"></a></h3>\n<p>Angular 9 bringt zwei neue Optionen zur Typprüfung mit:</p>\n<ul>\n<li><code>fullTemplateTypeCheck</code>: Wenn das Flag aktiviert ist, wird nicht nur der TypeScript-Code auf Typen geprüft, sondern auch die Expressions in den Templates (z. B. die Direktiven <code>ngIf</code> und <code>ngFor</code>). Diese Option ist in einem neuen Angular-Projekt standardmäßig aktiviert.</li>\n<li><code>strictTemplates</code>: Wird dieses Flag gesetzt, werden zusätzliche Typprüfungen für Templates aktiv.</li>\n</ul>\n<p>Wir können die Optionen in der Datei <code>tsconfig.json</code> im Abschnitt <code>angularCompilerOptions</code> aktivieren:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;angularCompilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;fullTemplateTypeCheck&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;strictTemplates&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre><p>Im Strict Mode wird beispielsweise geprüft, ob der übergebene Typ eines Property Bindings auch zu dem dazugehörigen <code>@Input()</code> passt.\nMehr Informationen dazu finden Sie in der <a href=\"https://angular.io/guide/template-typecheck#strict-mode\">Angular-Dokumentation</a>.</p>\n<h3 id=\"schematics-für-interceptoren\">Schematics für Interceptoren <a name=\"schematics-interceptor\"></a></h3>\n<p>Neu hinzugekommen ist auch ein Generator zur Erstellung von HTTP-Interceptoren.\nBisher musste man die Interceptor-Klasse per Hand erstellen, ab sofort unterstützt die Angular CLI uns dabei mit folgendem Befehl:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> interceptor\n</code></pre><h3 id=\"providedin-für-services-any-und-platform\"><code>providedIn</code> für Services: <code>any</code> und <code>platform</code> <a name=\"provided-in\"></a></h3>\n<p>Für Services wird ab Angular 6.0.0 standardmäßig die Option <code>providedIn: &#39;root&#39;</code> verwendet (wir haben dazu im <a href=\"https://angular-buch.com/blog/2018-05-angular6\">Update-Artikel zu Angular 6</a> berichtet).\nMit Angular 9 kommen neben <code>root</code> zwei neue Optionen für die Sichtbarkeit eines Providers hinzu: <code>any</code> und <code>platform</code>.</p>\n<ul>\n<li><code>root</code>: Die Anwendung erhält <em>eine einzige Instanz</em> des Services.</li>\n<li><code>any</code>: Jedes Modul der Anwendung erhält eine <em>eigene Instanz</em> des Services.</li>\n<li><code>platform</code>: Alle Anwendungen auf der Seite teilen sich <em>dieselbe Instanz</em>. Das ist vor allem im Kontext von <a href=\"https://angular.io/guide/elements\">Angular Elements</a> interessant, wenn mehrere Anwendungen auf einer Seite &quot;gebootstrappt&quot; (gestartet) werden.</li>\n</ul>\n<h3 id=\"optional-chaining-mit-typescript\">Optional Chaining mit TypeScript</h3>\n<p>Die von Angular verwendete Version von TypeScript wurde auf 3.7 aktualisiert. Damit ist auch ein neues interessantes Sprachfeature im Code verwendbar: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\">Optional Chaining</a>.</p>\n<p>Bei der Arbeit mit verschachtelten Objekten musste man bisher jeden Schritt im Objektpfad einzeln auf Existenz prüfen, um Fehler zu vermeiden.\nWollen wir beispielsweise die Thumbnail-URL eines Buchs ermitteln, müssen wir so vorgehen, wenn nicht sicher ist, ob das Thumbnail existiert:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> book = {\n  <span class=\"hljs-attribute\">title</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n  <span class=\"hljs-attribute\">header</span>: { <span class=\"hljs-attribute\">url</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-attribute\">title</span>: <span class=\"hljs-string\">&#x27;&#x27;</span> },\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">url</span> = book.thumbnail &amp;&amp; book.thumbnail.url;\n</code></pre><p>Mit Optional Chaining vereinfacht sich das Vorgehen. Wir verwenden den <code>?</code>-Operator, um die Evaluierung des Ausdrucks abzubrechen, falls ein Teilstück des Objekts nicht existiert:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">url</span> = book.thumbnail?.url;\n</code></pre><h3 id=\"nullish-coalescing-mit-typescript\">Nullish Coalescing mit TypeScript</h3>\n<p>Ein weiteres neues Feature von TypeScript ist <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator\">Nullish Coalescing</a>.\nDamit kann in einem Ausdruck ein Fallback-Wert definiert werden, der eingesetzt wird, wenn der geprüfte Wert ungültig ist.</p>\n<p>Für diese Semantik konnte bisher der <code>||</code>-Operator verwendet werden.\nIst der Wert von <code>foo</code> <em>falsy</em> (also <code>null</code>, <code>undefined</code>, <code>0</code>, <code>NaN</code>, <code>false</code> oder leerer String), wird stattdessen der Wert <code>default</code> eingesetzt:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-attribute\">const value</span> = foo || <span class=\"hljs-string\">&#x27;default&#x27;</span>;\n</code></pre><p>Mit dem neuen <em>Nullish Coalescing</em> gelten <code>0</code>, <code>false</code>, <code>NaN</code> oder leerer String als gültige Werte.\nDer Rückfall mit dem <code>??</code>-Operator greift im Gegensatz zu <code>||</code> also ausschließlich bei den Werten <code>null</code> oder <code>undefined</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-comment\">// Prüfung auf falsy values (null, undefined, &#x27;&#x27;, 0, false, NaN)</span>\n<span class=\"hljs-keyword\">const</span> value = foo || <span class=\"hljs-string\">&#x27;default&#x27;</span>;\n<span class=\"hljs-comment\">// value = &#x27;default&#x27;</span>\n\n<span class=\"hljs-comment\">// Zuweisung eines Standardwerts ohne Nullish Coalescing (&#x27;&#x27;, 0, false und NaN sind erlaubt)</span>\n<span class=\"hljs-keyword\">const</span> value = foo !== <span class=\"hljs-literal\">null</span> &amp;&amp; foo !== <span class=\"hljs-literal\">undefined</span> ? foo : <span class=\"hljs-string\">&#x27;default&#x27;</span>;\n<span class=\"hljs-comment\">// value = 0</span>\n\n<span class=\"hljs-comment\">// Zuweisung eines Standardwerts mit Nullish Coalescing (&#x27;&#x27;, 0, false und NaN sind erlaubt)</span>\n<span class=\"hljs-keyword\">const</span> value = foo ?? <span class=\"hljs-string\">&#x27;default&#x27;</span>;\n<span class=\"hljs-comment\">// value = 0</span>\n</code></pre><hr>\n\n<p>Wir wünschen Ihnen viel Spaß mit Angular 9!\nHaben Sie Fragen zur neuen Version, zum Update oder zu Angular? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß wünschen\nJohannes, Danny und Ferdinand</strong></p>\n<p><small><strong>Titelbild:</strong> Yosemite National Park, California, 2019. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 9 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2020-02-10T00:00:00.000Z","lastModified":"2020-02-10T00:00:00.000Z","keywords":["Angular","Angular 9","Ivy","TestBed","i18n","SSR","TypeScript"],"language":"de","header":{"url":"angular9.jpg","width":2000,"height":660},"isUpdatePost":true,"hidden":false,"sticky":false,"darkenHeader":false}}
