{"slug":"2025-11-ai-mcp-vibe-coding","html":"<p>Auf der Google I/O 2025 hat das Angular-Team die neue Ressource <a href=\"https://angular.dev/ai\">angular.dev/ai</a> vorgestellt.\nSie bietet umfassende Anleitungen und Beispiele für die Entwicklung von KI-gestützten Anwendungen mit Angular.\nDazu gehören etwa Chatbots, KI-Editoren oder agentenbasierte Workflows.\nDie Seite zeigt konkrete Integrationsmöglichkeiten mit Genkit, Firebase AI Logic und der Gemini API, inklusive Starter-Kits und Best Practices für sichere API-Nutzung und Fehlerbehandlung.</p>\n<p>Bei der Diskussion sollte man immer unterscheiden zwischen: &quot;AI in Apps einbauen&quot; vs. &quot;AI hilft beim Coden&quot;.\nBeide Richtungen sind spannend.\nAls Angular-Buch-Team interessiert uns jedoch natürlich besonders, wie AI-Assistenten uns beim Schreiben von Angular-Code unterstützen können.</p>\n<p>Angular bietet hierfür zwei konkrete Ansätze: die <code>AGENTS.md</code>-Dateien mit Coding-Richtlinien und den MCP-Server für strukturierten Zugriff auf aktuelle Best Practices und Dokumentation.</p>\n<h3 id=\"agentsmd-best-practices-für-ai-tools\">AGENTS.md: Best Practices für AI-Tools</h3>\n<p>Beim Anlegen einer neuen Anwendung fragt der interaktive Prompt jetzt, ob du eine Config für ein bestimmtes KI-Werkzeug generieren möchtest.\nDie zugehörige Kommandozeilenoption lautet <code>--ai-config</code>:</p>\n<pre><code><span class=\"hljs-comment\">--ai-config     Specifies which AI tools to generate</span>\n                configuration <span class=\"hljs-built_in\">files</span> <span class=\"hljs-keyword\">for</span>. These <span class=\"hljs-built_in\">file</span> are used <span class=\"hljs-built_in\">to</span>\n                improve <span class=\"hljs-keyword\">the</span> outputs <span class=\"hljs-keyword\">of</span> AI tools <span class=\"hljs-keyword\">by</span> following <span class=\"hljs-keyword\">the</span>\n                best practices.\n  [array] [choices: <span class=\"hljs-string\">&quot;agents&quot;</span>, <span class=\"hljs-string\">&quot;claude&quot;</span>, <span class=\"hljs-string\">&quot;copilot&quot;</span>, <span class=\"hljs-string\">&quot;cursor&quot;</span>,\n                <span class=\"hljs-string\">&quot;gemini&quot;</span>, <span class=\"hljs-string\">&quot;jetbrains&quot;</span>, <span class=\"hljs-string\">&quot;none&quot;</span>, <span class=\"hljs-string\">&quot;windsurf&quot;</span>]\n</code></pre>\n<p>Dadurch wird eine dedizierte Markdown-Datei generiert, die eine kleine Sammlung von Regeln und Best Practices für deinen KI-Agenten enthält.\nDiese Datei dient als Leitfaden, um sicherzustellen, dass AI-Tools konsistenten hochwertigen Code erzeugen, der den aktuellen Angular-Standards entspricht.\nJe nach ausgewähltem Tool variiert der Dateiname und der Speicherort, etwa <code>.claude/CLAUDE.md</code> für Claude, <code>.gemini/GEMINI.md</code> für Gemini oder <code>AGENTS.md</code> nach dem <a href=\"https://agents.md/\">neuen Standard</a>.\nDiese Datei dient als Custom Prompt, der ohne Zutun der Entwickler*innen sehr früh in die Session eingelesen wird.\nDer Inhalt bleibt jedoch über alle Varianten hinweg identisch und ist in klare Abschnitte unterteilt, wie TypeScript Best Practices, Angular Best Practices, Components, State Management, Templates und Services.\n<a href=\"https://github.com/angular/angular/blob/890414245ff313841c30759cbd193f72f3a89297/packages/core/resources/best-practices.md\">Hier</a> kannst du den aktuellen Text der <code>AGENTS.md</code> nachlesen:</p>\n<pre><code class=\"language-md\">You are an expert in TypeScript, Angular, and scalable web application development. You write functional, maintainable, performant, and accessible code following Angular and TypeScript best practices.\n\n<span class=\"hljs-section\">## TypeScript Best Practices</span>\n\n<span class=\"hljs-bullet\">-</span> Use strict type checking\n<span class=\"hljs-bullet\">-</span> Prefer type inference when the type is obvious\n<span class=\"hljs-bullet\">-</span> Avoid the <span class=\"hljs-code\">`any`</span> type; use <span class=\"hljs-code\">`unknown`</span> when type is uncertain\n\n<span class=\"hljs-section\">## Angular Best Practices</span>\n\n<span class=\"hljs-bullet\">-</span> Always use standalone components over NgModules\n<span class=\"hljs-bullet\">-</span> Must NOT set <span class=\"hljs-code\">`standalone: true`</span> inside Angular decorators. It&#x27;s the default in Angular v20+.\n<span class=\"hljs-bullet\">-</span> Use signals for state management\n<span class=\"hljs-bullet\">-</span> Implement lazy loading for feature routes\n<span class=\"hljs-bullet\">-</span> Do NOT use the <span class=\"hljs-code\">`@HostBinding`</span> and <span class=\"hljs-code\">`@HostListener`</span> decorators. Put host bindings inside the <span class=\"hljs-code\">`host`</span> object of the <span class=\"hljs-code\">`@Component`</span> or <span class=\"hljs-code\">`@Directive`</span> decorator instead\n<span class=\"hljs-bullet\">-</span> Use <span class=\"hljs-code\">`NgOptimizedImage`</span> for all static images.\n<span class=\"hljs-bullet\">  -</span> <span class=\"hljs-code\">`NgOptimizedImage`</span> does not work for inline base64 images.\n\n<span class=\"hljs-section\">## Accessibility Requirements</span>\n\n<span class=\"hljs-bullet\">-</span> It MUST pass all AXE checks.\n<span class=\"hljs-bullet\">-</span> It MUST follow all WCAG AA minimums, including focus management, color contrast, and ARIA attributes.\n\n<span class=\"hljs-section\">### Components</span>\n\n<span class=\"hljs-bullet\">-</span> Keep components small and focused on a single responsibility\n<span class=\"hljs-bullet\">-</span> Use <span class=\"hljs-code\">`input()`</span> and <span class=\"hljs-code\">`output()`</span> functions instead of decorators\n<span class=\"hljs-bullet\">-</span> Use <span class=\"hljs-code\">`computed()`</span> for derived state\n<span class=\"hljs-bullet\">-</span> Set <span class=\"hljs-code\">`changeDetection: ChangeDetectionStrategy.OnPush`</span> in <span class=\"hljs-code\">`@Component`</span> decorator\n<span class=\"hljs-bullet\">-</span> Prefer inline templates for small components\n<span class=\"hljs-bullet\">-</span> Prefer Reactive forms instead of Template-driven ones\n<span class=\"hljs-bullet\">-</span> Do NOT use <span class=\"hljs-code\">`ngClass`</span>, use <span class=\"hljs-code\">`class`</span> bindings instead\n<span class=\"hljs-bullet\">-</span> Do NOT use <span class=\"hljs-code\">`ngStyle`</span>, use <span class=\"hljs-code\">`style`</span> bindings instead\n<span class=\"hljs-bullet\">-</span> When using external templates/styles, use paths relative to the component TS file.\n\n<span class=\"hljs-section\">## State Management</span>\n\n<span class=\"hljs-bullet\">-</span> Use signals for local component state\n<span class=\"hljs-bullet\">-</span> Use <span class=\"hljs-code\">`computed()`</span> for derived state\n<span class=\"hljs-bullet\">-</span> Keep state transformations pure and predictable\n<span class=\"hljs-bullet\">-</span> Do NOT use <span class=\"hljs-code\">`mutate`</span> on signals, use <span class=\"hljs-code\">`update`</span> or <span class=\"hljs-code\">`set`</span> instead\n\n<span class=\"hljs-section\">## Templates</span>\n\n<span class=\"hljs-bullet\">-</span> Keep templates simple and avoid complex logic\n<span class=\"hljs-bullet\">-</span> Use native control flow (<span class=\"hljs-code\">`@if`</span>, <span class=\"hljs-code\">`@for`</span>, <span class=\"hljs-code\">`@switch`</span>) instead of <span class=\"hljs-code\">`*ngIf`</span>, <span class=\"hljs-code\">`*ngFor`</span>, <span class=\"hljs-code\">`*ngSwitch`</span>\n<span class=\"hljs-bullet\">-</span> Use the async pipe to handle observables\n<span class=\"hljs-bullet\">-</span> Do not assume globals like (<span class=\"hljs-code\">`new Date()`</span>) are available.\n<span class=\"hljs-bullet\">-</span> Do not write arrow functions in templates (they are not supported).\n<span class=\"hljs-bullet\">-</span> Do not write Regular expressions in templates (they are not supported).\n\n<span class=\"hljs-section\">## Services</span>\n\n<span class=\"hljs-bullet\">-</span> Design services around a single responsibility\n<span class=\"hljs-bullet\">-</span> Use the <span class=\"hljs-code\">`providedIn: &#x27;root&#x27;`</span> option for singleton services\n<span class=\"hljs-bullet\">-</span> Use the <span class=\"hljs-code\">`inject()`</span> function instead of constructor injection\n</code></pre>\n<p>Dieser Text ist auch auf der Seite <a href=\"https://angular.dev/ai/develop-with-ai\">LLM prompts and AI IDE setup</a>\nzu finden.\nJe nachdem, wie optimiert das Modell ist, wie viele Inputs es verarbeiten kann, wie groß sein Kontextfenster ist, ob es über ausgeprägte Fähigkeiten zum logischen Schlussfolgern (Reasoning) verfügt und vor allem, wie aktuell seine Trainingsdaten sind, wird es mehr oder weniger brauchbare Ergebnisse liefern.\nEin schwächeres Modell wird höchstwahrscheinlich hilflos raten und dabei selbstbewusst völlig falsche Informationen halluzinieren.</p>\n<p>Ein starkes Modell hingegen kann die Instruktionen präzise interpretieren und tatsächlich fundierte Vorschläge machen.\nUnserer Meinung nach ist die erzeugte Datei ein guter Anfang, sie müsste aber deutlich mehr konkrete und kontextspezifische Anweisungen beinhalten. Ein Weg, solche Informationen bereitzustellen, ist der MCP-Server (siehe unten), der im Kern eine Sammlung strukturierter Prompts und aktueller Best Practices enthält.</p>\n<h3 id=\"mcp-server-strukturiertes-wissen-für-ai-agenten\">MCP-Server: Strukturiertes Wissen für AI-Agenten</h3>\n<p>Angular bietet einen eigenen <a href=\"https://angular.dev/ai/mcp\">MCP-Server</a> an, der in AI-Agenten integriert werden kann.\nDie Unterstützung wurde bereits in Angular 20.2 als experimentelles Feature eingeführt und ist mit Angular 21 nun stabil.\nDer MCP-Server kann mit verschiedenen Agenten genutzt werden, darunter Claude Desktop, Claude Code, GitHub Copilot (VS Code), Cursor und viele weitere.</p>\n<p>Damit wird die &quot;Wissenslücke&quot; zwischen dem trainierten Modell und den aktuellen Best Practices geschlossen: \nLLMs können so auch brandneue Features wie Signal Forms und Angular Aria nutzen, obwohl sie zum Zeitpunkt des Trainings noch nicht existierten.</p>\n<p>Die Kommunikation erfolgt über das standardisierte Model Context Protocol (MCP). Der Server wird in der Regel lokal auf dem eigenen Rechner gestartet (z. B. mit <code>ng mcp</code>) und stellt seine Funktionen in Form sogenannter &quot;Tools&quot; bereit.\nDer MCP-Server bietet aktuell sieben Tools an:</p>\n<ol>\n<li>Mit einem interaktiven KI-Tutor Angular kennenlernen (<code>ai_tutor</code>). Siehe auch die Dokumentation unter <a href=\"https://angular.dev/ai/ai-tutor\">&quot;Angular AI Tutor&quot;</a>.</li>\n<li>Moderne Angular-Pattern-Beispiele finden (<code>find_examples</code>).</li>\n<li>Best Practices bereitstellen (<code>get_best_practices</code>).</li>\n<li>Alle Projekte im Workspace auflisten (<code>list_projects</code>).</li>\n<li>Die Anwendung auf Zoneless Change Detection migrieren (<code>onpush_zoneless_migration</code>).</li>\n<li>Die Dokumentation durchsuchen (<code>search_documentation</code>).</li>\n<li>Code-Migrationen mit Schematics durchführen (<code>modernize</code>, <strong>experimentell</strong>).</li>\n</ol>\n<p>Der MCP-Server wird kontinuierlich weiterentwickelt, um noch bessere Unterstützung bei der Entwicklung zu ermöglichen.</p>\n<p><strong>Wie funktioniert das konkret?</strong> Am Beispiel des <a href=\"https://github.com/angular/angular-cli/blob/26719451c35288c0b5342eceda3460ed24bd3171/packages/angular/cli/src/commands/mcp/tools/best-practices.ts#L11\"><code>get_best_practices</code></a>-Tools wird das Zusammenspiel deutlich:\nEin<em>e Entwickler</em>in möchte eine neue Funktionalität zur Anwendung hinzufügen, zum Beispiel ein reaktives Formular mit Validierung.\nDie Person beschreibt dem AI-Assistenten die gewünschte Funktionalität.\nDie KI analysiert die Anfrage, erkennt, dass Angular-Code geschrieben werden muss, und führt <strong>autonom</strong> einen Aufruf des <code>get_best_practices</code>-Tools vom MCP-Server durch.\nSo werden die aktuellen Coding-Richtlinien abgerufen und fließen direkt in die Code-Generierung ein.\nDie Person erhält Code, der den neuesten Standards entspricht.\nJe nach Agent werden die Tool-Aufrufe transparent in Statusmeldungen angezeigt oder laufen vollständig im Hintergrund ab.\nEs gibt keine spezielle Syntax zum manuellen Aufrufen der Tools.\nDie KI entscheidet vollständig eigenständig, wann welches Tool hilfreich ist.</p>\n<p>Wichtig ist: Der MCP-Server liefert Inhalte, trifft aber <strong>keine kontextabhängige Auswahl</strong>. Die Integration und Nutzung dieser Inhalte obliegt dem jeweiligen AI-Agenten. Dieser kann den Server lokal starten, per JSON-RPC abfragen und bei Bedarf passende Informationen aus den verfügbaren Tools gezielt in den eigenen Prompt einfügen.</p>\n<p>Damit diese Kommunikation funktioniert, muss der MCP-Server jedoch erst korrekt im jeweiligen Agenten konfiguriert werden. Dies geschieht zum Beispiel durch eine Datei wie <code>mcp.json</code>. Angular generiert solche Konfigurationsdateien (leider) nicht automatisch. Sie müssen aktuell manuell angelegt werden.</p>\n<p>Wird der übermittelte Text vom MCP-Server zu umfangreich, kann er das Kontextfenster des Modells überschreiten.\n<strong>Dies ist aktuell einer der größten Schmerzpunkte bei der Entwicklung mit AI-Assistenten:</strong>\nDie Limitierung tritt schnell bei längeren Sessions auf, insbesondere bei umfangreichen Projekten oder komplexen Fragestellungen.\nIn der Praxis bedeutet das: Der AI-Agent verliert den Überblick über frühere Teile der Konversation, kann nicht mehr auf alle relevanten Informationen zugreifen oder muss wichtige Best Practices weglassen, weil der verfügbare Platz erschöpft ist.\nEs ist ein Phänomen, das du bei der Arbeit mit AI-Assistenten bestimmt schon einmal erlebt hast: Die AI scheint alles zu &quot;vergessen&quot;, und man muss alle wichtigen Informationen noch einmal vorkauen.\nDas führt zu inkonsistenten Antworten, veralteten Code-Vorschlägen oder der Notwendigkeit, Konversationen neu zu starten und den Kontext manuell wiederherzustellen.</p>\n<p><strong>Hinzu kommt:</strong> Viele AI-Agenten tendieren dazu, Custom Prompts wie die AGENTS.md im Laufe der Konversation zu vergessen und nur noch auf den ursprünglichen System-Prompt zurückzufallen.\nDas führt zu einer kompromittierten Konversation, auf die man als Entwickler*in keinen Einfluss hat.</p>\n<p>Ein möglicher Ansatz zur Lösung dieses Problems ist der Einsatz von Vektordatenbanken, die projektbezogenes Wissen semantisch indizieren.\nSolche Systeme sind aktuell noch nicht Teil der Angular-Toolchain, zeigen aber die Richtung, in die sich die Integration von strukturiertem Wissen und generativer KI entwickeln könnte.</p>\n<p><strong>Das ist allerdings noch Zukunftsmusik.</strong> Wir sind gespannt, wie das Angular-Team es in zukünftigen Versionen schaffen wird, möglichst präzise und kontextsensitive Instruktionen bereitzustellen – idealerweise dynamisch, skalierbar und abgestimmt auf die jeweiligen Werkzeuge.</p>\n","meta":{"title":"Vibe-Coding mit Angular 21","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2025-11-20T00:00:00.000Z","lastModified":"2025-11-20T00:00:00.000Z","keywords":["Angular","Angular 21","MCP","Model Context Protocol","MCP-Server","Vibe","Vibe-Coding"],"language":"de","header":{"url":"angular21.jpg","width":2000,"height":1009},"hidden":true}}
