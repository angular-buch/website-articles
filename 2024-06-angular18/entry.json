{"slug":"2024-06-angular18","html":"<p>Und schon wieder ist ein halbes Jahr vergangen:\nAngular Version 18 ist jetzt verf√ºgbar!</p>\n<p>In den letzten Versionen wurden viele neue Funktionen und Verbesserungen eingef√ºhrt.\nDiesmal lag der Fokus darauf, die bereits ausgelieferten APIs zu stabilisieren, diverse Feature Requests zu bearbeiten und eines der am meisten nachgefragten Projekte auf der Roadmap experimentell zu ver√∂ffentlichen: die <strong>Zoneless Change Detection</strong>.</p>\n<p>Im offiziellen <a href=\"https://blog.angular.dev/angular-v18-is-now-available-e79d5ac0affe\">Angular-Blog</a> finden Sie alle offiziellen Informationen direkt vom Angular-Team.\nAu√üerdem empfehlen wir Ihnen einen Blick in die Changelogs von <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md#1800-2024-05-22\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/main/CHANGELOG.md#1800-2024-05-22\">Angular CLI</a>.</p>\n<p>Wenn Sie sich einen kurzweiligen Gesamt√ºberblick verschaffen wollen, so lohnt es sich, das hervorragende Video aus dem Release-Event anzuschauen:\n<a href=\"https://www.youtube.com/watch?v=DK8M-ZFjaMw\">What‚Äôs new in Angular v18</a> </p>\n<p>Und f√ºr eine Zusammenfassung in deutscher Sprache lesen Sie jetzt einfach weiter. üôÇ</p>\n<h2 id=\"neue-offizielle-website\">Neue Offizielle Website</h2>\n<p>Das Angular Team hat mit Angular 17 die neue Website <a href=\"https://angular.dev/\">angular.dev</a> ver√∂ffentlicht und damit die &quot;Angular Renaissance&quot; aufgerufen.\nDie Website ist die neue offizielle Dokumentationsseite f√ºr Angular und bietet einen intuitiven, praxisorientierten Einstieg sowie viele hervorragende Artikel. Die alte Website <a href=\"https://angular.io/\">angular.io</a> wird nicht mehr weiterentwickelt und leitet jetzt auf die neue Domain um.</p>\n<p><img src=\"https://website-articles.angular-buch.com/2024-06-angular18/angular_dev.gif\" alt=\"Screenshot von angular.dev\"></p>\n<h2 id=\"zoneless-change-detection-experimentell\">Zoneless Change Detection (experimentell)</h2>\n<p>Seit dem Beginn von Angular ist die Bibliothek <a href=\"https://github.com/angular/angular/tree/main/packages/zone.js\">zone.js</a> f√ºr das Ausl√∂sen der √Ñnderungs√ºberpr√ºfung (Change Detection) in Angular verantwortlich.\nzone.js hat den Umgang mit Angular massiv gepr√§gt:\n√Ñnderungen an den angezeigten Daten werden scheinbar wie durch Magie erkannt.\nAber leider hat diese Magie auch eine Reihe von technischen Nachteilen mit sich gebracht.\nVor allem die Performance und die Handhabung beim Debugging werden schon seit der Integration von zone.js kritisiert.</p>\n<p>Angular v18 f√ºhrt eine neue Methode zur Ausl√∂sung der √Ñnderungs√ºberpr√ºfung ein. \nAnstatt sich auf ausschlie√ülich auf zone.js zu verlassen, \num zu erkennen, wann sich etwas m√∂glicherweise ge√§ndert hat, \nkann Angular jetzt selbst eine √Ñnderungs√ºberpr√ºfung planen.</p>\n<h3 id=\"die-standardeinstellung-beide-scheduler-sind-aktiv\">Die Standardeinstellung: beide Scheduler sind aktiv</h3>\n<p>Dazu wurde dem Framework ein neuer Scheduler hinzugef√ºgt (genannt <code>ChangeDetectionScheduler</code>), \nund dieser Scheduler wird intern verwendet, um die √Ñnderungs√ºberpr√ºfung auszul√∂sen. \nLangfristiges Ziel ist es, sich schrittweise von zone.js zu entfernen und ausschlie√ülich den neuen Scheduler einzusetzen.</p>\n<p>Dieser neue Scheduler ist in v18 standardm√§√üig aktiviert, auch wenn Sie zone.js verwenden.\nSo sieht die Datei <code>app.config.ts</code> aus, wenn mit der Angular CLI v18 eine neue Anwendung generiert wird.\nBeide Scheduler sind hier aktiv:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-type\">const</span> appConfig: ApplicationConfig = {\n  providers: [\n    <span class=\"hljs-comment\">// beide Scheduler sind aktiv</span>\n    <span class=\"hljs-built_in\">provideZoneChangeDetection</span>({ eventCoalescing: <span class=\"hljs-literal\">true</span> }),\n};\n</code></pre>\n<p>Die Option <code>eventCoalescing</code> ist ebenso neu hinzugekommen.\nDiese verhindert, das in bestimmten F√§llen mehrfach unn√∂tig eine Change Detection durchgef√ºhrt wird.\nDas genaue Verhalten ist <a href=\"https://angular.dev/api/core/NgZoneOptions#eventCoalescing\">in der Dokumentation</a> beschrieben. </p>\n<h3 id=\"abmeldung-vom-neuen-scheduler\">Abmeldung vom neuen Scheduler</h3>\n<p>Der neue Scheduler ist somit in v18 standardm√§√üig aktiviert. \nDas bedeutet, dass Angular potenzielle √Ñnderungen sowohl von zone.js (wie bisher) als auch vom neuen Scheduler (wenn ein Signal gesetzt wird, eine AsyncPipe einen neuen Wert erh√§lt usw.) benachrichtigt wird. \nDiese √Ñnderung sollte Ihre Anwendung nicht negativ beeinflussen: \nAngular f√ºhrt die Change Detection nur einmal durch, \nauch wenn es von mehreren Quellen eine Benachrichtigung gibt.</p>\n<p>Wenn Sie sich dennoch vom neuen Scheduler abmelden m√∂chten, \nk√∂nnen Sie hierzu bei der Funktion <code>provideZoneChangeDetection()</code> den Wert von <code>ignoreChangesOutsideZone</code> auf <code>true</code> setzen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-type\">const</span> appConfig: ApplicationConfig = {\n  providers: [\n    <span class=\"hljs-comment\">// dies stellt das Verhalten von Angular vor v18 wieder her</span>\n    <span class=\"hljs-comment\">// und ignoriert die Benachrichtigungen des neuen Schedulers</span>\n    <span class=\"hljs-built_in\">provideZoneChangeDetection</span>({ ignoreChangesOutsideZone: <span class=\"hljs-literal\">true</span> }),\n};\n</code></pre>\n<p>Die Option <code>eventCoalescing</code> haben wir hier nicht erneut aufgef√ºhrt, da diese Einstellung unabh√§ngig von <code>ignoreChangesOutsideZone</code> ist.</p>\n<h3 id=\"experimentelle-zonenlose-√§nderungs√ºberpr√ºfung\">Experimentelle zonenlose √Ñnderungs√ºberpr√ºfung</h3>\n<p>Sie k√∂nnen auch versuchen, sich nur auf den neuen Scheduler zu verlassen und nicht mehr auf zone.js, um die √Ñnderungs√ºberpr√ºfung auszul√∂sen.\nDies ist eine experimentelle Funktion, die Sie aktivieren k√∂nnen, indem Sie die Provider-Funktion <code>provideExperimentalZonelessChangeDetection()</code> in Ihrer Anwendung verwenden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-type\">const</span> appConfig: ApplicationConfig = {\n  providers: [\n    <span class=\"hljs-comment\">// ausschlie√ülich der neue Scheduler ist aktiv</span>\n    <span class=\"hljs-built_in\">provideExperimentalZonelessChangeDetection</span>()\n};\n</code></pre>\n<p>Wenn Sie dies tun, wird sich Angular nicht mehr auf zone.js verlassen, \num die √Ñnderungs√ºberpr√ºfung auszul√∂sen. \nSie k√∂nnen nun zone.js aus Ihrer Anwendung entfernen, um die Gr√∂√üe des Bundles zu verringern ‚Äì sofern keine Abh√§ngigkeiten davon abh√§ngen.\nHierzu muss der Polyfills-Eintrag in der Datei <code>angular.json</code> entfernt werden:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-comment\">// vorher</span>\n<span class=\"hljs-attr\">&quot;polyfills&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n  <span class=\"hljs-string\">&quot;zone.js&quot;</span>\n<span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n\n<span class=\"hljs-comment\">// nachher</span>\n<span class=\"hljs-attr\">&quot;polyfills&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n</code></pre>\n<p>Die Anwendung sollte weiterhin funktionieren,\nwenn alle Ihre Komponenten bereits mit der <code>OnPush</code>-Strategie kompatibel sind und/oder √ºberall Signals eingesetzt werden!</p>\n<h3 id=\"vorteile-durch-die-zonenlose-√§nderungs√ºberpr√ºfung\">Vorteile durch die zonenlose √Ñnderungs√ºberpr√ºfung</h3>\n<p>Das Angular-Team verspricht folgende Vorteile durch die Zoneless Change Detection:</p>\n<ul>\n<li>verbesserte Kombinierbarkeit f√ºr Micro Frontends und Interoperabilit√§t mit anderen Frameworks</li>\n<li>schnellere Initialisierung und Laufzeit der Angular-App</li>\n<li>kleinere Bundle-Gr√∂√üe und schnellere Seitenladezeiten</li>\n<li>lesbarere Stack-Traces</li>\n<li>einfacheres Debugging</li>\n</ul>\n<p>Allerdings bekommen wir all diese Vorteile nicht einfach umsonst.\nDer &quot;alte Angular-Stil&quot; mit der Default Change Detection, bei dem prinzipiell alle Objekte direkt ver√§ndert (mutiert) werden k√∂nnen, ist mit dem zonenlosen Ansatz nicht direkt kompatibel.\nIm Kern geht es darum, nach M√∂glichkeit auf die neuen Signals umzusteigen, die seit <a href=\"https://angular-buch.com/blog/2023-05-angular16#reaktivit%C3%A4t-mit-signals\">Angular 16</a> verf√ºgbar sind. \nWir haben √ºber diesen modernen Ansatz in unserem letzten Blogpost berichtet:\n<a href=\"/blog/2024-05-modern-angular-bm\">Modern Angular: den BookMonkey migrieren</a></p>\n<p>Diese simple Komponente ‚Ä¶</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Alter Stil</span>\n<span class=\"hljs-meta\">@Component({\n  // ...\n  template: `\n    &lt;h1&gt;Hallo von {{ name }}!&lt;/h1&gt;\n    &lt;button (click)=<span class=\"hljs-string\">&quot;handleClick()&quot;</span>&gt;Mit zone.js&lt;/button&gt;\n  `,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> {\n  name = <span class=\"hljs-string\">&#x27;Angular&#x27;</span>;\n\n  handleClick() {\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">&#x27;Klassisches Angular&#x27;</span>;\n  }\n}\n</code></pre>\n<p>‚Ä¶ w√ºrden wir jetzt mit Signals folgenderma√üen umsetzen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Neuer Stil mit Signals</span>\n<span class=\"hljs-meta\">@Component({\n  // ...\n  template: `\n    &lt;h1&gt;Hallo von {{ name() }}!&lt;/h1&gt;\n    &lt;button (click)=<span class=\"hljs-string\">&quot;handleClick()&quot;</span>&gt;Ohne zone.js&lt;/button&gt;\n  `,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> {\n  name = signal(<span class=\"hljs-string\">&#x27;Angular&#x27;</span>);\n\n  handleClick() {\n    <span class=\"hljs-keyword\">this</span>.name.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&#x27;Zoneless Angular&#x27;</span>);\n  }\n}\n</code></pre>\n<p>Im obigen Beispiel wird beim Klicken auf den Button das <em>Signal</em> mit der Bezeichnung <code>name</code> aktualisiert und anschlie√üend die Oberfl√§che aktualisiert.\nDies funktioniert genauso zuverl√§ssig wie bei einer Anwendung mit zone.js, jedoch begrenzt Angular die internen √úberpr√ºfungen auf ganz wenige Ausl√∂ser ‚Äì wie den Aktualisierungen der Signals.\nDie Performance ist hierbei deutlich h√∂her, wenn viele Komponenten gleichzeitig angezeigt werden.</p>\n<h3 id=\"auf-zoneless-updaten\">Auf &quot;zoneless&quot; updaten</h3>\n<p>Angular entwickelt sich stetig weiter, und &quot;zoneless&quot; ist ein zentraler Bestandteil davon.\nW√§hrend das Framework weiterentwickelt wird, stellt das Angular Team selbstverst√§ndlich sicher, dass der klassische Stil weiterhin wie erwartet funktioniert.\nDer zuk√ºnftige Fokus des Angular-Teams ist allerdings eindeutig.\nWir empfehlen, neue Angular-Anwendungen definitiv mit den Signals umzusetzen.\nDer klassische Stil wird weiterhin unterst√ºtzt werden, aber hier wird es keine neuen Innovationen mehr geben.</p>\n<h3 id=\"natives-asyncawait-f√ºr-zonenlose-apps\">Natives <code>async</code>/<code>await</code> f√ºr zonenlose Apps</h3>\n<p>zone.js f√§ngt viele APIs im Browser ab, um die bisherige Change Detection von Angular zu realisieren.\nLeider geh√∂rt <code>async</code>/<code>await</code> zu den Schnittstellen, die zone.js nicht patchen kann. \nAls Workaround wird bisher von der Angular CLI jede Verwendung der beiden Schl√ºsselw√∂rter auf Promises heruntergestuft ‚Äì denn Promises k√∂nnen von zone.js gepatcht werden. \nDas ist suboptimal, da alle modernen Browser <code>async</code>/<code>await</code> unterst√ºtzen und optimieren k√∂nnen.</p>\n<p>Wenn zone.js nicht in den Polyfills der Anwendung enthalten ist, dann findet die Entfernung von <code>async</code>/<code>await</code> nicht mehr statt.\nDies verbessert das Debugging und verkleinert die Bundles.</p>\n<h3 id=\"zonenlose-unterst√ºtzung-in-angular-material--cdk\">Zonenlose Unterst√ºtzung in Angular Material &amp; CDK</h3>\n<p><a href=\"https://material.angular.io/\">Angular Material</a> 3 ist jetzt stabil.\nDas Angular Team hat mit der neuen Version auch gleich die zonenlose Unterst√ºtzung aktiviert. Ebenso kann man nun auch das <a href=\"https://material.angular.io/cdk/\">Angular CDK</a> vollst√§ndig ohne zone.js verwenden.</p>\n<p>Wenn Sie also auf die Komponentenbibliothek Angular Material setzen, k√∂nnen Sie prinzipiell direkt auf eine zonenlose App umsteigen.\nSollten Sie eine Bibliothek von einem anderen Hersteller bzw. von einem anderen Open-Source-Projekt verwenden, so pr√ºfen Sie am besten, ob die Bibliothek bereits &quot;Zoneless Angular&quot; unterst√ºtzt.\nIst das nicht der Fall, werden sich nach einer Umstellung diverse Stellen in der Anwendung nicht mehr korrekt aktualisieren.</p>\n<h2 id=\"neue-signal-apis\">Neue Signal-APIs</h2>\n<p>In den letzten Monaten wurden mit Angular 17.1, 17.2 und 17.3 bereits eine Reihe von spannenden APIs rund um die Signals als <strong>Developer Preview</strong> ver√∂ffentlicht. Wir haben diese in unserem Blogpost <a href=\"/blog/2024-05-modern-angular-bm\">&quot;Modern Angular: den BookMonkey migrieren&quot;</a> bereits vorgestellt. Da Angular 18 die erste gr√∂√üere Version ist, die die APIs enth√§lt, stellen wir diese hier gerne noch einmal im Detail vor.\nAuch in Angular 18 sind diese APIs allesamt im Status  <strong>Developer Preview</strong> ‚Äì sie k√∂nnten sich also noch bei der Verwendung oder im Verhalten √§ndern. </p>\n<h3 id=\"inputs-als-signal\">Inputs als Signal</h3>\n<p>Mit dem Minor-Release von Angular 17.1 wurden <a href=\"https://angular.dev/guide/signals/inputs\">Signal Inputs</a> eingef√ºhrt.\nSie sind eine Alternative zum bisherigen <code>@Input()</code>-Dekorator.\nDas Angular-Team misst diesen neuen Signals eine gro√üe Bedeutung bei, und hat das Thema in einem dedizierten <a href=\"https://blog.angular.io/signal-inputs-available-in-developer-preview-6a7ff1941823\">Blogpost</a> vorgestellt.\nNutzen wir die neue Funktion <code>input()</code>, wird der √ºbergebene Wert eines Komponenten-Inputs direkt als Signal erfasst:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-attribute\">anzahl</span> <span class=\"hljs-operator\">=</span> input()<span class=\"hljs-comment\">;                  // InputSignal&lt;unknown&gt;</span>\n<span class=\"hljs-attribute\">anzahl</span> <span class=\"hljs-operator\">=</span> input&lt;number&gt;()<span class=\"hljs-comment\">;          // InputSignal&lt;number | undefined&gt;</span>\n<span class=\"hljs-attribute\">anzahl</span> <span class=\"hljs-operator\">=</span> input.required()<span class=\"hljs-comment\">;         // InputSignal&lt;unknown&gt;</span>\n<span class=\"hljs-attribute\">anzahl</span> <span class=\"hljs-operator\">=</span> input.required&lt;number&gt;()<span class=\"hljs-comment\">; // InputSignal&lt;number&gt;</span>\n<span class=\"hljs-attribute\">anzahl</span> <span class=\"hljs-operator\">=</span> input(<span class=\"hljs-number\">5</span>)<span class=\"hljs-comment\">;                 // InputSignal&lt;number&gt;</span>\n</code></pre>\n<p>Nachfolgend finden Sie ein Beispiel, bei dem eine Kind-Komponente √ºber ein Input aktualisiert wird.\nZun√§chst der klassische Stil, bei dem wir den <code>@Input()</code>-Dekorator einsetzen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Input</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-comment\">// Alter Stil mit Dekorator</span>\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-katzen&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    @if (anzahl) {\n      &lt;img src=&quot;{{ imageUrl() }}&quot;&gt;\n    }\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KatzenComponent</span> {\n  <span class=\"hljs-meta\">@Input</span>() anzahl?: <span class=\"hljs-built_in\">number</span>;\n\n  <span class=\"hljs-title function_\">imageUrl</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`https://api.angular.schule/avatar/<span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.anzahl}</span>`</span>;\n  }\n}\n</code></pre>\n<p>Um vollst√§ndig in der Welt von Signals zu bleiben, k√∂nnen wir stattdessen jetzt folgende Syntax verwenden.\nEine massive Erleichterung ist die Funktion <code>input.required()</code>:\nBeim alten Stil musste man immer auch <code>undefined</code> als m√∂glichen Wert ber√ºcksichtigen.\nDies ist nun nicht mehr notwendig, da <code>input.required()</code> entweder einen gesetzten Wert hat oder eine Exception wirft, wenn es keinen Wert gibt.\nDie bisherige leidige Pr√ºfung auf <code>undefined</code> entf√§llt damit endlich.\nAllein hierf√ºr lohnt sich bereits der Umstieg auf Signals:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { input } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-comment\">// Neuer Stil mit Signals</span>\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-katzen&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;img src=&quot;{{ imageUrl() }}&quot;&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KatzenComponent</span> {\n  anzahl = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">number</span>&gt;();\n  imageUrl = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-string\">`https://api.angular.schule/avatar/<span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.anzahl()}</span>`</span>);\n}\n</code></pre>\n<p>Um das Beispiel vollst√§ndiger zu gestalten, sieht man hier auch gleich die Kombination mit einem Computed-Signal. \nDank des Inputs k√∂nnen wir nun mit folgender Syntax einen Wert an die Kind-Komponente √ºbergeben.\nAm Einsatz von Property Bindings √§ndert sich nichts, daher funktioniert die Verwendung in beiden Beispielen gleich:</p>\n<pre><code class=\"language-html\">&lt;app-katzen [anzahl]<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;5&quot;</span> /&gt;\n</code></pre>\n<p>Je nach √ºbergebener Zahl sieht man nun ein anderes Bild ‚Äì mit der entsprechenden Anzahl an Katzen.</p>\n<p><strong>Hinweis:</strong> Wenn wir einen Test f√ºr die <code>KatzenComponent</code> schreiben wollen, dann k√∂nnen wir nicht mehr wie fr√ºher das Input-Property direkt √ºberschreiben:</p>\n<pre><code class=\"language-ts\">beforeEach(<span class=\"hljs-name\">async</span> () =&gt; {\n  await TestBed.configureTestingModule({\n    imports: [KatzenComponent]\n  })\n  .compileComponents()<span class=\"hljs-comment\">;</span>\n\n  fixture = TestBed.createComponent(<span class=\"hljs-name\">KatzenComponent</span>)<span class=\"hljs-comment\">;</span>\n  component = fixture.componentInstance<span class=\"hljs-comment\">;</span>\n\n  // Fehler: Type &#x27;number&#x27; is not assignable to type &#x27;InputSignal&lt;number&gt;&#x27;\n  component.anzahl = <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span>\n  fixture.detectChanges()<span class=\"hljs-comment\">;</span>\n})<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>Stattdessen steht uns die Methode <code>setInput()</code> zur Verf√ºgung, um den Wert des Input Signals zu setzen:</p>\n<pre><code class=\"language-ts\">beforeEach(<span class=\"hljs-name\">async</span> () =&gt; {\n  await TestBed.configureTestingModule({\n    imports: [KatzenComponent]\n  })\n  .compileComponents()<span class=\"hljs-comment\">;</span>\n\n  fixture = TestBed.createComponent(<span class=\"hljs-name\">KatzenComponent</span>)<span class=\"hljs-comment\">;</span>\n  component = fixture.componentInstance<span class=\"hljs-comment\">;</span>\n\n  // kein Fehler\n  fixture.componentRef.setInput(&#x27;anzahl&#x27;, <span class=\"hljs-number\">5</span>)<span class=\"hljs-comment\">;</span>\n  fixture.detectChanges()<span class=\"hljs-comment\">;</span>\n})<span class=\"hljs-comment\">;</span>\n</code></pre>\n<h3 id=\"querys-als-signal\">Querys als Signal</h3>\n<p>Es kann Situationen geben, in denen wir aus einer √ºbergeordneten Komponente auf eine Kind-Komponente/Kind-Direktive oder ein DOM-Element zugreifen m√∂chten, bzw. auf den Inhalt von <code>&lt;ng-content&gt;&lt;/ng-content&gt;</code>.\nSeit jeher stehen uns hierf√ºr die Dekoratoren <a href=\"https://v17.angular.io/api/core/ViewChild\"><code>@ViewChild()</code></a>, <a href=\"https://v17.angular.io/api/core/ViewChildren\"><code>@ViewChildren()</code></a>, <a href=\"https://v17.angular.io/api/core/ContentChild\"><code>@ContentChild()</code></a> sowie <a href=\"https://v17.angular.io/api/core/ContentChildren\"><code>@ContentChildren()</code></a> zu Verf√ºgung, um die entsprechenden Referenzen zu erhalten:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { ViewChild, ViewChildren, ElementRef } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-comment\">// Alter Stil mit Dekoratoren</span>\n<span class=\"hljs-meta\">@Component({\n  // ...\n  template: `\n    &lt;div #el&gt;&lt;/div&gt;\n    &lt;div #el&gt;&lt;/div&gt;\n\n    &lt;app-child /&gt;\n    &lt;app-child /&gt;\n  `\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppComponent</span> {\n\n  <span class=\"hljs-comment\">// liefert ein Kind</span>\n  <span class=\"hljs-meta\">@ViewChild(<span class=\"hljs-string\">&#x27;el&#x27;</span>)</span> element!: ElementRef;\n  <span class=\"hljs-meta\">@ViewChild(ChildComponent)</span> child!: ChildComponent;\n\n  <span class=\"hljs-comment\">// liefert alle Kinder</span>\n  <span class=\"hljs-meta\">@ViewChildren(<span class=\"hljs-string\">&#x27;el&#x27;</span>)</span> elements!: QueryList&lt;ElementRef&gt;;\n  <span class=\"hljs-meta\">@ViewChildren(ChildComponent)</span> children!: QueryList&lt;ChildComponent&gt;;\n}\n</code></pre>\n<p>Die √§quivalenten <a href=\"https://angular.dev/guide/signals/queries\">Signal Queries</a> <code>viewChild()</code>, <code>viewChildren()</code>, <code>contentChild()</code> und <code>contentChildren()</code> wurden mit Angular 17.2 hinzugef√ºgt und geben uns moderne Signals zur√ºck.</p>\n<pre><code class=\"language-ts\">import { viewChild, viewChildren, ElementRef } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-comment\">// Neuer Stil mit Signals</span>\n@Component({\n  <span class=\"hljs-comment\">// ...</span>\n  template: `\n    &lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-meta\">#el&gt;&lt;/div&gt;</span>\n    &lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-meta\">#el&gt;&lt;/div&gt;</span>\n\n    &lt;app-child /&gt;\n    &lt;app-child /&gt;\n  `\n})\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppComponent</span> {\n\n   <span class=\"hljs-comment\">// liefert ein Kind (oder `undefined`, falls keines gefunden wurde)</span>\n  element = viewChild&lt;ElementRef&gt;(<span class=\"hljs-string\">&#x27;el&#x27;</span>); <span class=\"hljs-comment\">// Signal&lt;ElementRef | undefined&gt;</span>\n  child   = viewChild(ChildComponent);   <span class=\"hljs-comment\">// Signal&lt;ChildComponent|undefined&gt;</span>\n\n   <span class=\"hljs-comment\">// liefert ein Kind (oder einen Runtime error, falls keines gefunden wurde)</span>\n  elementRequired = viewChild.required&lt;ElementRef&gt;(<span class=\"hljs-string\">&#x27;el&#x27;</span>); <span class=\"hljs-comment\">// Signal&lt;ElementRef&gt;</span>\n  childRequired   = viewChild.required(ChildComponent);   <span class=\"hljs-comment\">// Signal&lt;MyComponent&gt;</span>\n\n  <span class=\"hljs-comment\">// liefert alle Kinder (oder eine leere Liste)</span>\n  elements = viewChild&lt;ElementRef&gt;(<span class=\"hljs-string\">&#x27;el&#x27;</span>); <span class=\"hljs-comment\">// Signal&lt;ReadonlyArray&lt;ElementRef&gt;&gt;</span>\n  childs   = viewChild(ChildComponent);   <span class=\"hljs-comment\">// Signal&lt;ReadonlyArray&lt;ChildComponent&gt;&gt;</span>\n}\n</code></pre>\n<p>Neu hinzugekommen ist die M√∂glichkeit, das Vorhandensein eines einzelnen Kinds per <a href=\"https://angular.dev/guide/signals/queries#required-child-queries\"><code>viewChild.required</code></a> typsicher zu erzwingen.\nSollte das Element doch nicht im Template vorhanden sein ‚Äì weil es z. B. per <code>@if</code> versteckt wurde ‚Äì so wirft Angular einen Laufzeitfehler: <code>Runtime error: result marked as required by not available!</code>.</p>\n<h3 id=\"model-inputs\">Model Inputs</h3>\n<p>Die weiter oben vorgestellten Signal Inputs sind schreibgesch√ºtzt.\nDies stellt sicher, das wir nicht versehentlich das Signal im Code setzen ‚Äì was kein sch√∂ner Stil w√§re.</p>\n<p>Um einen gemeinsamen Zustand zwischen einer Eltern- und einer Kindkomponente elegant zu teilen,\nsind aber beschreibbare Signals sehr praktisch.\nGenau diese L√ºcke f√ºllen die <a href=\"https://angular.dev/guide/signals/model\">Model Inputs</a>.\nMit diesen k√∂nnen wir dann Two-Way Bindings realisieren:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Alter Stil mit Dekoratoren</span>\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-pager&#x27;</span>,\n  template: `\n    Aktuelle Seite: {{ page }}\n    &lt;button (click)=<span class=\"hljs-string\">&quot;goToNextPage()&quot;</span>&gt;N√§chste Seite&lt;/button&gt;\n  `\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PagerComponent</span> {\n\n  <span class=\"hljs-meta\">@Input({ required: true })</span> page!: number;\n  <span class=\"hljs-meta\">@Output()</span> pageChange = new EventEmitter&lt;number&gt;();\n\n  goToNextPage() {\n    <span class=\"hljs-keyword\">this</span>.page = <span class=\"hljs-keyword\">this</span>.page + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">this</span>.pageChange.emit(<span class=\"hljs-keyword\">this</span>.page);\n  }\n}\n</code></pre>\n<p>Und hier der neue Stil, bei dem wir ein beschreibbares Signal verwenden.\nDer Code wird deutlich k√ºrzer und √ºbersichtlicher:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Neuer Stil mit Signal</span>\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-pager&#x27;</span>,\n  template: `\n    Aktuelle Seite: {{ page() }}\n    &lt;button (click)=<span class=\"hljs-string\">&quot;goToNextPage()&quot;</span>&gt;N√§chste Seite&lt;/button&gt;\n  `\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PagerComponent</span> {\n  page = model.required&lt;number&gt;();\n\n  goToNextPage() {\n    <span class=\"hljs-keyword\">this</span>.page.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-keyword\">this</span>.page() + <span class=\"hljs-number\">1</span>);\n  }\n}\n</code></pre>\n<p>In beiden F√§llen kann unsere Komponente nun mit einem Two-Way-Binding verwendet werden.\nDer Wert f√ºr das Two-Way-Binding kann wie gehabt <a href=\"https://angular.dev/guide/signals/model#two-way-binding-with-plain-properties\">ein Property mit einem Wert</a> sein:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  template: <span class=\"hljs-string\">&#x27;&lt;app-pager [(page)]=&quot;currentPage&quot; /&gt;&#x27;</span>,\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ParentComponent</span> </span>{\n  currentPage = <span class=\"hljs-number\">1</span>;\n}\n</code></pre>\n<p>Allerdings wollen wir ja idealerweise in der gesamten Applikation auf Signals setzen.\nDaher ist es ebenso m√∂glich, <a href=\"https://angular.dev/guide/signals/model#two-way-binding-with-signals\">schreibbare Signals mit einem Two-Way Binding</a> zu kombinieren:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  template: <span class=\"hljs-string\">&#x27;&lt;app-pager [(page)]=&quot;currentPage&quot; /&gt;&#x27;</span>,\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ParentComponent</span> </span>{\n  currentPage = signal(<span class=\"hljs-number\">1</span>);\n}\n</code></pre>\n<h3 id=\"outputs-als-funktion\">Outputs als Funktion</h3>\n<p>Analog zur Funktion <code>input()</code> steht seit Angular 17.3 eine Alternative zum <code>@Output()</code>-Dekorator bereit: die Funktion <code>output()</code>.\nDabei wurde auch die Typsicherheit verbessert: \nWenn wir den Output typisieren, z. B. <code>output&lt;string&gt;()</code>, dann ist √ºbergebene Payload bei <code>emit()</code> verpflichtend.\nBeim bisherigen Weg mit <code>EventEmitter.emit</code> war der Payload hingegen immer optional.\nWollen wir keinen Payload √ºbergeben, m√ºssen wir den Output nicht typisieren, und es wird automatisch der Typ <code>void</code> f√ºr den Payload angenommen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">select</span> = output(); <span class=\"hljs-comment\">// OutputEmitterRef&lt;void&gt;</span>\ntextChange = output&lt;<span class=\"hljs-built_in\">string</span>&gt;(); <span class=\"hljs-comment\">// OutputEmitterRef&lt;string&gt;</span>\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">select</span>.emit(); <span class=\"hljs-comment\">// OK</span>\n<span class=\"hljs-keyword\">this</span>.textChange.emit(); <span class=\"hljs-comment\">// Error: Expected 1 arguments, but got 0.</span>\n<span class=\"hljs-keyword\">this</span>.textChange.emit(<span class=\"hljs-string\">&#x27;Text&#x27;</span>); <span class=\"hljs-comment\">// OK</span>\n</code></pre>\n<p>Gerne zeigen wir auch hier ein vollst√§ndiges Beispiel.<br>Zun√§chst erneut der klassische Stil:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Output</span>, <span class=\"hljs-title class_\">EventEmitter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-comment\">// Alter Stil mit Dekorator</span>\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-katzen&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button (click)=&quot;wasMachenDieKatzen()&quot;&gt;Klick mich&lt;/button&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KatzenComponent</span> {\n  <span class=\"hljs-meta\">@Output</span>() katzenGeraeusch = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventEmitter</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  <span class=\"hljs-title function_\">wasMachenDieKatzen</span>(<span class=\"hljs-params\"></span>) {\n    katzenGeraeusch.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;Miau! üò∏&#x27;</span>);\n\n    <span class=\"hljs-comment\">// aber auch folgende Zeile kompiliert</span>\n    katzenGeraeusch.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-literal\">undefined</span>);\n  }\n}\n</code></pre>\n<p>Der Umstieg auf Signals geht hier schnell voran ‚Äì wir m√ºssen nur eine Zeile austauschen und den Import aktualisieren:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { output } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-comment\">// Neuer Stil mit Signal</span>\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-katzen&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button (click)=&quot;wasMachenDieKatzen()&quot;&gt;Klick mich&lt;/button&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KatzenComponent</span> {\n  katzenGeraeusch = output&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  <span class=\"hljs-title function_\">wasMachenDieKatzen</span>(<span class=\"hljs-params\"></span>) {\n    katzenGeraeusch.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;Miau! üò∏&#x27;</span>);\n\n    <span class=\"hljs-comment\">// funktioniert nicht</span>\n    katzenGeraeusch.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-literal\">undefined</span>);\n  }\n}\n</code></pre>\n<p>Auf das Ereignis k√∂nnen wir wie bisher per Event Binding reagieren:</p>\n<pre><code class=\"language-html\">&lt;app-katzen (katzenGeraeusch)<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;handleEvent($event)&quot;</span> /&gt;\n</code></pre>\n<p>Bitte beachten Sie noch einmal, dass alle drei neuen Signal-APIs aktuell noch im Status <strong>Developer Preview</strong> sind.\nWir erwarten aber bei dieser bereits sehr ausgereiften API keine fundamentalen √Ñnderungen mehr. </p>\n<h3 id=\"outputs-von-observables\">Outputs von Observables</h3>\n<p>Zus√§tzlich zur neuen Funktion <code>output()</code> bietet Angular die Funktion <a href=\"https://angular.dev/guide/signals/rxjs-interop#outputfromobservable\"><code>outputFromObservable()</code></a>, welche einen nahtlosen √úbergang vom Framework RxJS bereitstellt.\nDie neue Funktion wurde vom Angular-Team in einem <a href=\"https://blog.angular.dev/meet-angulars-new-output-api-253a41ffa13c\">separaten Blogpost vorgestellt</a>. </p>\n<p>Wenn die Datenquelle ein Observable ist, kann man den √úbergang zur neuen Output-API wie folgt durchf√ºhren:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { outputFromObservable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({‚Ä¶})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComp</span> {\n  nameChange$ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observable</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;( ‚Ä¶ );\n  nameChange = <span class=\"hljs-title function_\">outputFromObservable</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">nameChange$</span>);\n}\n</code></pre>\n<p>Der umgekehrte Weg ist ebenso mit <a href=\"https://angular.dev/guide/signals/rxjs-interop#outputtoobservable\"><code>outputToObservable()</code></a> m√∂glich.\nBen√∂tigt man etwa die Ereignisse einer Kind-Komponente als Observable, so kann man auf ein Output wie folgt wieder zu einem RxJS-Datenstrom umwandeln.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { outputToObservable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n\noutputToObservable(this.myComp.<span class=\"hljs-keyword\">instance</span>.onNameChange)\n  .pipe(‚Ä¶)\n  .subscribe(‚Ä¶);\n</code></pre>\n<p>Die Funktion <code>outputToObservable()</code> funktioniert √ºbrigens nicht nur mit der neuen Output-API, sondern auch mit dem alten Output-Dekorator.</p>\n<h2 id=\"stabile-apis\">Stabile APIs</h2>\n<p>Mit dem aktuellen Realease sind einige Developer Previews als stabil markiert worden:</p>\n<ul>\n<li>Das Framework <a href=\"https://material.angular.io/\">Angular Material</a> 3 ist jetzt stabil.</li>\n<li>Die <a href=\"https://angular-buch.com/blog/2023-11-angular17#deferrable-views-mit-defer\">Deferrable Views</a> (<code>@defer</code>) sind jetzt stabil</li>\n<li>Der <a href=\"https://angular-buch.com/blog/2023-11-angular17#neuer-control-flow-if-for-switch\">Built-in Control Flow</a> (<code>@if</code>, <code>@for</code> und <code>@switch</code>) ist ebenso als stabil markiert worden.</li>\n</ul>\n<h2 id=\"automatische-migration-auf-den-neuen-application-builder\">Automatische Migration auf den neuen Application Builder</h2>\n<p>Im Blogpost zu Angular 17 haben wir bereits den neuen <a href=\"https://angular-buch.com/blog/2023-11-angular17\">Application Builder auf Basis von ESBuild</a> vorgestellt.\nZu dem Zeitpunkt musste man die Umstellung noch manuell durchf√ºhren.\nDies ist nun nicht mehr notwendig, da folgender Befehl die Anwendung automatisch umstellt:</p>\n<pre><code class=\"language-sh\">ng <span class=\"hljs-keyword\">update</span> <span class=\"hljs-variable\">@angular</span><span class=\"hljs-operator\">/</span>cli <span class=\"hljs-comment\">--name use-application-builder</span>\n</code></pre>\n<h2 id=\"neuer-ordner-public-statt-assets\">Neuer Ordner <code>public</code> statt <code>assets</code></h2>\n<p>Wenn Sie eine neue Anwendung mit <code>ng new</code> generieren, werden Sie bemerken, dass der Ordner <code>assets</code> nicht mehr vorhanden ist.\nDieser wurde durch des neuen <code>public</code>-Ordner abgel√∂st.</p>\n<p>Vor Angular 18 wurde standardm√§√üig ein leerer Assets-Ordner bereitgestellt.\nDie Datei <code>favicon.ico</code> befand sich an einem anderen Ort:</p>\n<ul>\n<li><code>name-der-app/src/assets</code></li>\n<li><code>name-der-app/src/favicon.ico</code></li>\n</ul>\n<p>Dabei wird der gesamte Ordner <code>assets</code> ber√ºcksichtigt sowie die einzelne Datei <code>favicon.ico</code>.\nDie bisherige Konfiguration in der <code>angular.json</code> sieht so aus:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;name-der-app&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;build&quot;</span>: {\n          <span class=\"hljs-string\">&quot;assets&quot;</span>: [\n            <span class=\"hljs-string\">&quot;src/favicon.ico&quot;</span>,\n            <span class=\"hljs-string\">&quot;src/assets&quot;</span>\n          ]\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Speichern wir bei dieser Konfiguration ein Bild in den Ordner <code>assets</code>, so l√§sst sich das Bild so einbinden:</p>\n<pre><code class=\"language-html\">&lt;img <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-string\">&quot;/assets/bild.png&quot;</span> <span class=\"hljs-attribute\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;\n</code></pre>\n<p>Mit Angular 18 finden wir nur noch folgende Datei:</p>\n<ul>\n<li><code>name-der-app/public/favicon.ico</code></li>\n</ul>\n<p>Die neue Konfiguration in der <code>angular.json</code> sieht hierbei so aus:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;name-der-app&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;build&quot;</span>: {\n          <span class=\"hljs-string\">&quot;assets&quot;</span>: [\n            {\n              <span class=\"hljs-string\">&quot;glob&quot;</span>: <span class=\"hljs-string\">&quot;**/*&quot;</span>,\n              <span class=\"hljs-string\">&quot;input&quot;</span>: <span class=\"hljs-string\">&quot;public&quot;</span>\n            }\n          ]\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Legen wir bei dieser Konfiguration ein Bild in den <code>public</code>-Ordner ab, so l√§sst sich das Bild wie folgt einbinden:</p>\n<pre><code class=\"language-html\">&lt;img <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-string\">&quot;/bild.png&quot;</span> <span class=\"hljs-attribute\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;\n</code></pre>\n<p>Wollen wir weiterhin das Bild per <code>&lt;img src=&quot;/assets/bild.png&quot;&gt;</code> einbinden, so muss die vollst√§ndige Ordnerstruktur so aussehen. Der Ordner <code>assets</code> muss also in <code>public</code> platziert werden:</p>\n<ul>\n<li><code>name-der-app/public/assets/bild.png</code></li>\n</ul>\n<p>F√ºr bestehende Anwendungen √§ndert sich nichts, die ge√§nderte Ordnerstruktur wird nur bei neuen Apps erzeugt.</p>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Mit Angular 18 steht uns eine solide neue Version zur Verf√ºgung, \ndie sich auf die Stabilisierung zuvor eingef√ºhrter APIs, \nzahlreiche Detailverbesserungen und Bugfixes sowie eine Reihe √§u√üerst hilfreicher APIs f√ºr den Umgang mit Signals konzentriert.</p>\n<p>Das Angular Team hat wieder einmal gezeigt, \nwie kontinuierliche Innovation und die Ber√ºcksichtigung des Feedbacks aus der Community zu einem leistungsstarken und nutzungsfreundlichen Framework f√ºhren.</p>\n<p>Wir freuen uns darauf, diese neuen Features in unseren Projekten zu nutzen. \nOb Sie auf die verbesserte Zoneless Change Detection, \ndie stabilen APIs f√ºr Material 3, \ndie Deferrable Views oder den neuen Built-in Control Flow zugreifen ‚Äì Angular 18 bietet zahlreiche Werkzeuge, \num moderne und elegante Anwendungen zu erstellen.</p>\n<hr>\n\n\n<p>Wir w√ºnschen Ihnen viel Spa√ü mit Angular 18!\nHaben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>\n<p><strong>Viel Spa√ü w√ºnschen\nJohannes, Danny und Ferdinand</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Blumenwiese bei V√§ster√•s, Schweden. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 18 ist da: Signals, Signals, Signals!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2024-06-14T00:00:00.000Z","lastModified":"2024-06-14T00:00:00.000Z","keywords":["Angular","Angular 18","Zoneless","Zoneless Change Detection","Signals","Material 3"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2024-06-angular18/angular18.jpg","sticky":false}}
