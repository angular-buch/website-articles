{"slug":"reactive-forms","html":"<blockquote>\n<p><strong>Hinweis:</strong> Dieser Artikel ist ein Zusatzmaterial zum <a href=\"https://angular-buch.com\">Angular-Buch</a>.\nIm Buch behandeln wir <strong>Signal Forms</strong> – den neuesten Ansatz zur Formularverarbeitung in Angular.\nTemplate-Driven Forms und Reactive Forms sind weiterhin vollständig unterstützt und in vielen Projekten im Einsatz.</p>\n<p>Dieser Artikel behandelt <strong>Reactive Forms</strong>.\nWenn du dich für den templatebasierten Ansatz interessierst, schau dir unseren Artikel zu <a href=\"/template-forms\">Template-Driven Forms</a> an.</p>\n</blockquote>\n<hr>\n<p>Angular bietet drei Ansätze für die Formularverarbeitung: <strong>Template-Driven Forms</strong>, <strong>Reactive Forms</strong> und <strong>Signal Forms</strong>.\nReactive Forms eignen sich dort, wo wir nicht auf Signal Forms setzen können besonders für komplexe Formulare mit dynamischen Anforderungen.\nDas Formularmodell wird dabei vollständig in der Komponentenklasse definiert und bietet strikte Typisierung.</p>\n<h2 id=\"reactive-forms\">Reactive Forms</h2>\n<p>Bei Reactive Forms speichern wir in der Komponentenklasse ein komplexes Formularmodell.\nEs beschreibt alles, was Angular rund um das Formular weiß:\nDas sind nicht nur die Daten, sondern auch Validierungsregeln und Zustände.\nWir definieren also zunächst in der Klasse das Formularmodell und verknüpfen es dann mit den Feldern im HTML.\nMit Reactive Forms wird also ein großer Teil der Formularlogik in der TypeScript-Klasse erledigt.</p>\n<p>Um Reactive Forms verwenden zu können, benötigen wir das <code>ReactiveFormsModule</code> aus <code>@angular/forms</code> als Komponentenimport.\nDas Modul enthält die notwendigen Direktiven, die wir im Template verwenden werden.</p>\n<pre><code class=\"language-typescript\">import { ReactiveFormsModule } from <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span>;\n\n<span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  imports: [ReactiveFormsModule]\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{ }\n</code></pre><h2 id=\"formularmodell-in-der-komponente\">Formularmodell in der Komponente</h2>\n<p>Die Grundidee der Reactive Forms ist, dass das komplette Modell des Formulars in der Komponentenklasse angesiedelt wird.\nDazu gehören neben den reinen Eingabedaten auch die gesamten logischen Controls mit ihren Zuständen, Validierungsregeln und Werten.\nDiese Idee gibt uns die nötige Flexibilität für große Formularanwendungen.</p>\n<p>Im ersten Schritt müssen wir uns dazu überlegen, wie das Formular strukturiert ist, um ein entsprechendes Datenmodell aufzubauen.\nDazu stehen uns vier Bausteine zur Verfügung: <code>FormControl</code>, <code>FormGroup</code>, <code>FormArray</code> und <code>FormRecord</code>.</p>\n<h3 id=\"formcontrol\">FormControl</h3>\n<p>Jedes Feld unseres Formulars erhält zunächst eine Instanz von <code>FormControl</code>.\nDabei ist es vollkommen egal, ob es sich um ein Textfeld, ein Dropdown, eine Checkbox oder ein anderes Eingabefeld handelt – jedes unserer Formularfelder wird durch ein <code>FormControl</code> repräsentiert.\nBei der Initialisierung geben wir direkt einen Startwert für das Control an.\nDer Typ des Controls wird automatisch aus diesem Startwert ermittelt.\nIst kein Wert gegeben, wird das Feld mit <code>null</code> initialisiert.\nIn der Praxis sollten wir immer einen Startwert übergeben, damit der Typ sicher bekannt ist. Für ein Textfeld kann das z. B. ein leerer String sein.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-built_in\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>);    // FormControl&lt;string | <span class=\"hljs-keyword\">null</span>&gt;\n<span class=\"hljs-built_in\">new</span> FormControl(<span class=\"hljs-number\">5</span>);     // FormControl&lt;number | <span class=\"hljs-keyword\">null</span>&gt;\n<span class=\"hljs-built_in\">new</span> FormControl(<span class=\"hljs-keyword\">true</span>);  // FormControl&lt;<span class=\"hljs-type\">boolean</span> | <span class=\"hljs-keyword\">null</span>&gt;\n</code></pre><p>Wir sehen, dass jedoch auch bei der Definition eines Startwerts der Typ <code>null</code> immer inkludiert ist.\nDer Hintergrund: Ein Control kann mithilfe der Methode <code>reset()</code> zurückgesetzt werden.\nBeim Zurücksetzen wird traditionell der Wert <code>null</code> verwendet – und ist deshalb immer auch im Typ des Controls enthalten.</p>\n<p>In vielen Fällen wird dieses Verhalten nicht mit den tatsächlich zu erfassenden Daten übereinstimmen.\nEin einfaches Input-Feld erzeugt zum Beispiel stets einen String.\nDer Wert <code>null</code> beschäftigt uns hier also tatsächlich nur beim Zurücksetzen des Formulars.</p>\n<p>Wir können das Standardverhalten deshalb mithilfe der Option <code>nonNullable</code> ändern:\nBeim Zurücksetzen wird dann nicht <code>null</code> verwendet, sondern der ursprünglich definierte Startwert.\nDamit entfällt der Typ <code>null</code>, und das <code>FormControl</code> besitzt nur noch den Typ <code>string</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> });\n<span class=\"hljs-comment\">// FormControl&lt;string&gt;</span>\n</code></pre><p>Falls der Typ für ein <code>FormControl</code> nicht automatisch inferiert werden kann, weil der Startwert explizit auf <code>null</code> gesetzt wird, können wir mithilfe des generischen Typparameters nachhelfen:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">new</span> FormControl&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-keyword\">null</span>&gt;(<span class=\"hljs-keyword\">null</span>);\n// FormControl&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-keyword\">null</span>&gt;\n</code></pre><p>Wir empfehlen dir, die Option <code>nonNullable</code> für jedes Control auf <code>true</code> zu setzen.\nDas vereinfacht die Arbeit mit den erzeugten Daten, weil die Typen den tatsächlichen Eingabewert widerspiegeln.</p>\n<h3 id=\"formgroup\">FormGroup</h3>\n<p>Da ein Formular nur selten aus einem einzigen Feld besteht, können wir eine Menge von <code>FormControl</code>s in einem <em>Objekt</em> zusammenfassen: einer <code>FormGroup</code>.\nTatsächlich übergeben wir bei der Initialisierung ein Objekt an die <code>FormGroup</code>.\nJedes Control erhält in diesem Objekt einen Namen, anhand dessen wir das Feld später identifizieren können.</p>\n<p>Ein Formular besteht auf oberster Ebene meist aus einer <code>FormGroup</code> (Seit Angular 21.0.0 kann jedoch auch ein <code>FormArray</code> auf oberster Ebene verwendet werden).\nÜbrigens kannst du in einer solchen <code>FormGroup</code> nicht nur <code>FormControl</code>s zusammenfassen, sondern auch weitere <code>FormGroup</code>s (und <code>FormArray</code>s und <code>FormRecord</code>s).\nDu kannst deine Formulare also hierarchisch aufbauen – so wie es für deine komplexe Anwendung nötig ist.\nDie Blätter dieses Baums sind allerdings immer einzelne <code>FormControl</code>s.</p>\n<p>Der Typ der <code>FormGroup</code> wird anhand der enthaltenen <code>FormControl</code>s ermittelt.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">new</span> FormGroup({\n  username: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> }),\n  password: <span class=\"hljs-keyword\">new</span> FormGroup({\n    pw: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> }),\n    pwConfirm: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> })\n  })\n});\n\n<span class=\"hljs-comment\">// Typ der erfassten Daten:</span>\n<span class=\"hljs-comment\">// {</span>\n<span class=\"hljs-comment\">//   username: string;</span>\n<span class=\"hljs-comment\">//   password: {</span>\n<span class=\"hljs-comment\">//     pw: string;</span>\n<span class=\"hljs-comment\">//     pwConfirm: string;</span>\n<span class=\"hljs-comment\">//   };</span>\n<span class=\"hljs-comment\">// }</span>\n</code></pre><h3 id=\"formrecord\">FormRecord</h3>\n<p>Da die <code>FormGroup</code> strikt typisiert ist, können wir zur Laufzeit keine Felder mit anderen Namen oder Typen hinzufügen.\nDas schränkt die Verwendung ein, denn manche Formulare sollen gezielt dynamisch verändert werden.\nDer Baustein <code>FormRecord</code> löst dieses Problem.\nTechnisch ist dieses Objekt auch eine <code>FormGroup</code>, alle darin enthaltenen Controls müssen aber denselben Typ besitzen.\nDas ist besonders dann sinnvoll, wenn Controls zur Laufzeit hinzugefügt oder entfernt werden sollen:</p>\n<pre><code class=\"language-typescript\">new FormRecord({\n  <span class=\"hljs-params\">acceptAGB:</span> new FormControl(<span class=\"hljs-literal\">false</span>, { <span class=\"hljs-params\">nonNullable:</span> <span class=\"hljs-literal\">true</span> }),\n  <span class=\"hljs-params\">acceptDSGVO:</span> new FormControl(<span class=\"hljs-literal\">false</span>, { <span class=\"hljs-params\">nonNullable:</span> <span class=\"hljs-literal\">true</span> })\n});\n</code></pre><p>Bei der Typisierung kommt TypeScript allerdings an seine Grenzen: Die Namen der Felder können nicht statisch ermittelt werden und sind deshalb generisch mit <code>string</code> typisiert:</p>\n<pre><code class=\"language-typescript\">{ <span class=\"hljs-built_in\">[key</span>:<span class=\"hljs-built_in\"> string</span>]:<span class=\"hljs-built_in\"> boolean</span>; }\n</code></pre><p>Wollen wir also z. B. ein Control anhand seines Namens abrufen, kann der eingegebene Key nicht von TypeScript geprüft werden.\nEin <code>FormRecord</code> sollte deshalb gezielt eingesetzt werden, wenn eine <code>FormGroup</code> oder ein <code>FormArray</code> nicht die gewünschten Anforderungen erfüllen.</p>\n<h3 id=\"formarray\">FormArray</h3>\n<p>Der vierte Baustein für Reactive Forms ist das <code>FormArray</code>.\nDamit können wir mehrere Teile des Formulars in einer <em>Liste</em> zusammenfassen.\nEin solches Array ist sinnvoll, um eine unbestimmte Anzahl von Einträgen zu erfassen, z. B. Produkte einer Bestellung, Stichwörter oder mehrere Autoren zu einem Buch.\nIn einem <code>FormArray</code> können nicht nur <code>FormControl</code>s zusammengefasst werden, sondern auch <code>FormGroup</code>, <code>FormArray</code> oder <code>FormRecord</code>.</p>\n<p>Das <code>FormArray</code> besitzt Methoden, die denen eines echten Arrays aus JavaScript nachempfunden sind.\nZum Beispiel können wir mit der Methode <code>push()</code> weitere Controls am Ende anfügen.\nAußerdem existieren die Methoden <code>removeAt()</code> und <code>insert()</code> zum Entfernen bzw. Einfügen von Controls an einer bestimmten Position.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">emails</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FormArray</span>([\n  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FormControl</span>(<span class=\"hljs-string\">&#x27;mail@example.org&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> })\n]);\n\n<span class=\"hljs-comment\">// Neues Control hinzufügen</span>\nemails.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FormControl</span>(<span class=\"hljs-string\">&#x27;other@example.org&#x27;</span>, { <span class=\"hljs-attr\">nonNullable</span>: <span class=\"hljs-literal\">true</span> }));\n\n<span class=\"hljs-comment\">// Control an Position 0 entfernen</span>\nemails.<span class=\"hljs-title function_ invoke__\">removeAt</span>(<span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-comment\">// Control an Position 1 einfügen</span>\nemails.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FormControl</span>(<span class=\"hljs-string\">&#x27;third@example.org&#x27;</span>, { <span class=\"hljs-attr\">nonNullable</span>: <span class=\"hljs-literal\">true</span> }));\n</code></pre><p>Mit dem Property <code>length</code> können wir die Anzahl der Elemente herausfinden, das Property <code>controls</code> liefert uns ein Array mit allen Controls, über das du nach Belieben mit den bekannten Bordmitteln wie <code>@for</code> iterieren kannst.\nDamit ist es also ebenfalls möglich, dynamische Formulare zu entwickeln, bei denen wir zur Laufzeit Controls hinzufügen und entfernen können.</p>\n<h3 id=\"die-oberklasse-abstractcontrol\">Die Oberklasse AbstractControl</h3>\n<p>Die Klasse <code>AbstractControl</code> ist die Oberklasse für <code>FormControl</code>, <code>FormGroup</code>, <code>FormRecord</code> und <code>FormArray</code>.\nNeben den spezifischen Schnittstellen besitzen also alle vier Bausteine die gleichen Eigenschaften und Methoden, um das Formular zu verwalten.</p>\n<table>\n<thead>\n<tr>\n<th>Eigenschaft oder Methode</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>value</code></td>\n<td>Wert des Controls (nur aktivierte Felder)</td>\n</tr>\n<tr>\n<td><code>getRawValue()</code></td>\n<td>Wert des Controls (alle Felder, auch deaktivierte)</td>\n</tr>\n<tr>\n<td><code>enable()</code></td>\n<td>Control aktivieren</td>\n</tr>\n<tr>\n<td><code>disable()</code></td>\n<td>Control deaktivieren</td>\n</tr>\n<tr>\n<td><code>touched</code>, <code>untouched</code>, <code>dirty</code>, <code>pristine</code>, <code>valid</code>, <code>invalid</code></td>\n<td>Zustände des Controls</td>\n</tr>\n<tr>\n<td><code>errors</code></td>\n<td>Objekt mit allen Fehlern</td>\n</tr>\n<tr>\n<td><code>getError(e)</code></td>\n<td>liefert den Fehler mit dem Namen <code>e</code></td>\n</tr>\n<tr>\n<td><code>hasError(e)</code></td>\n<td>prüft, ob ein Fehler mit dem Namen <code>e</code> existiert (Boolean)</td>\n</tr>\n<tr>\n<td><code>reset()</code></td>\n<td>Control zurücksetzen</td>\n</tr>\n<tr>\n<td><code>setValue(v)</code></td>\n<td>gesamten Wert des Controls setzen</td>\n</tr>\n<tr>\n<td><code>patchValue(v)</code></td>\n<td>Teile des Control-Werts setzen (für <code>FormGroup</code>, <code>FormRecord</code> und <code>FormArray</code>)</td>\n</tr>\n<tr>\n<td><code>valueChanges</code></td>\n<td>Änderungen am Wert überwachen (Observable)</td>\n</tr>\n<tr>\n<td><code>statusChanges</code></td>\n<td>Status des Controls überwachen (Observable)</td>\n</tr>\n</tbody></table>\n<h3 id=\"komplexes-formularmodell\">Komplexes Formularmodell</h3>\n<p>Mit den vier Bausteinen können wir in der Komponente ein komplexes Formularmodell definieren.</p>\n<p>So können wir z. B. ein Formular für die Registrierung erstellen:</p>\n<ul>\n<li>Den Benutzernamen können wir als einfaches Textfeld abbilden.</li>\n<li>Das Passwort und die Bestätigung des Passworts können wir zusammenhängend in einer Gruppe abfragen.</li>\n<li>Mehrere E-Mail-Adressen können wir in einer Liste erfassen.</li>\n</ul>\n<p>Die Reise beginnt aber zunächst mit einer <code>FormGroup</code>, unter der sich das gesamte Formular aufspannt.\nDiese <code>FormGroup</code> legen wir direkt in einem Property der Komponentenklasse ab.\nWir empfehlen dir, für jedes Feld die Option <code>nonNullable</code> zu setzen.</p>\n<pre><code class=\"language-typescript\">registerForm = <span class=\"hljs-built_in\">new</span> FormGroup({\n  username: <span class=\"hljs-built_in\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-keyword\">true</span> }),\n  <span class=\"hljs-keyword\">password</span>: <span class=\"hljs-built_in\">new</span> FormGroup({\n    pw: <span class=\"hljs-built_in\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-keyword\">true</span> }),\n    pwConfirm: <span class=\"hljs-built_in\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-keyword\">true</span> })\n  }),\n  emails: <span class=\"hljs-built_in\">new</span> FormArray([\n    <span class=\"hljs-built_in\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-keyword\">true</span> })\n  ])\n});\n</code></pre><p>In der <code>FormGroup</code> können wir ein einfaches Feld für den <code>username</code> direkt mit einem <code>FormControl</code> anlegen.\nFür die Passworteingabe erzeugen wir eine verschachtelte <code>FormGroup</code>, die zwei separate Controls für das Passwort und die Bestätigung des Passworts beinhaltet. Diese Gruppierung hat den Vorteil, dass wir die Controls später zusammen validieren können.\nDie E-Mail-Adressen sollen in einer Liste abgefragt werden.\nWir fassen also mehrere <code>FormControl</code>s in einem <code>FormArray</code> zusammen.</p>\n<h2 id=\"template-mit-dem-modell-verknüpfen\">Template mit dem Modell verknüpfen</h2>\n<p>Im Template der Komponente entwickeln wir das passende Markup für unser Formular.\nAnschließend müssen wir die Formularfelder aus dem Template mit den Controls aus dem Modell verknüpfen.</p>\n<p>Im ersten Schritt definieren wir auf dem umschließenden <code>&lt;form&gt;</code>-Element, für welche <code>FormGroup</code> dieses Formular verantwortlich ist.\nDafür existiert die Direktive <code>formGroup</code>, an die wir direkt unser gesamtes Formularmodell übergeben können.</p>\n<blockquote>\n<p>Seit Angular 21.0.0 ist es auch möglich auf oberster Ebene ein Formularmodell, welches mit einem FormArray erzeugt wurde mit der Direktive <code>formArray</code> zu verknüpfen.</p>\n</blockquote>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> [<span class=\"hljs-attr\">formGroup</span>]=<span class=\"hljs-string\">&quot;registerForm&quot;</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Formularfelder --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Ab Angular 21.0.0 geht auch: --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> [<span class=\"hljs-attr\">formArray</span>]=<span class=\"hljs-string\">&quot;myFormArray&quot;</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Formularfelder --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></pre><p>Nun müssen wir die einzelnen Formularfelder im Template mit dem zugehörigen <code>FormControl</code> aus dem Modell verknüpfen.\nDafür existieren zwei Ansätze.</p>\n<h3 id=\"ansatz-1-formcontrolname-mit-control-namen\">Ansatz 1: formControlName mit Control-Namen</h3>\n<p>Alle Inhalte innerhalb von <code>&lt;form&gt;</code> befinden sich im Kontext des Modells <code>registerForm</code>.\nZur Verknüpfung der einzelnen Felder können wir deshalb den Namen des Controls verwenden:\nDazu setzen wir die Direktive <code>formControlName</code> ein und übergeben den Namen als String.\nUnsere <code>FormGroup</code> besitzt das Feld <code>username</code>, also können wir das HTML wie folgt aufbauen:</p>\n<pre><code class=\"language-html\">&lt;label <span class=\"hljs-attribute\">for</span>=<span class=\"hljs-string\">&quot;username&quot;</span>&gt;Username&lt;/label&gt;\n&lt;input <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-string\">&quot;username&quot;</span> <span class=\"hljs-attribute\">formControlName</span>=<span class=\"hljs-string\">&quot;username&quot;</span>&gt;\n</code></pre><blockquote>\n<p><strong><code>formControlName</code>:</strong> Binde dieses Input-Feld an das Control mit dem Namen <code>username</code> aus der <code>FormGroup</code> im Property <code>registerForm</code>.</p>\n</blockquote>\n<p>Dieser Weg wird in der Dokumentation von Angular beschrieben, er hat aber einen entscheidenden Nachteil:\nZur Verknüpfung notieren wir den Namen des Controls nur als losen String.\nOb aber überhaupt ein Control mit diesem Namen existiert, wird erst zur Laufzeit geprüft.\nGeben wir hier einen falschen Namen an, erhalten wir keine Fehlermeldung im Editor.</p>\n<p>Wir empfehlen deshalb, die typsichere zweite Variante mit der Direktive <code>formControl</code> zu verwenden.</p>\n<h3 id=\"ansatz-2-formcontrol-mit-control-referenz\">Ansatz 2: formControl mit Control-Referenz</h3>\n<p>Um mehr Typsicherheit zu erreichen, können wir eine Referenz auf das Control an das Input-Feld übergeben.\nZum Zugriff auf die einzelnen <code>FormControl</code>-Objekte verwenden wir die Eigenschaft <code>controls</code> auf der <code>FormGroup</code>.\nUm ein Control direkt an ein Input-Feld zu binden, setzen wir schließlich die Direktive <code>formControl</code> ein.\nDiese Referenz wird direkt im Editor ausgewertet. Beim Tippen profitieren wir von der Autovervollständigung, und Fehler werden sofort vom Compiler erkannt.\nWir empfehlen diese typsichere Variante ganz klar gegenüber der losen Kopplung mit dem Control-Namen.</p>\n<pre><code class=\"language-html\">&lt;label for<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;username&quot;</span>&gt;Username&lt;/label&gt;\n&lt;input id<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;username&quot;</span> [formControl]<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;registerForm.controls.username&quot;</span>&gt;\n</code></pre><blockquote>\n<p><strong><code>formControl</code>:</strong> Binde dieses Input-Feld an das Control aus <code>registerForm.controls.username</code>.</p>\n</blockquote>\n<p>Die verschachtelte <code>FormGroup</code> für die doppelte Passworteingabe verknüpfen wir erneut mit der Direktive <code>formGroup</code> auf einem umschließenden Element (z. B. <code>&lt;fieldset&gt;</code>).\nInnerhalb dieses Elements sprechen wir mit <code>formControl</code> die Controls aus dieser verschachtelten <code>FormGroup</code> an.\nDie hierarchische Struktur des Formularmodells findet sich auch in der Hierarchie des Templates wieder.\nUm die Ausdrücke im Template kurz und lesbar zu halten, können wir eine lokale Variable mit <code>@let</code> verwenden.</p>\n<pre><code class=\"language-html\">&lt;fieldset [formGroup]=<span class=\"hljs-string\">&quot;registerForm.controls.password&quot;</span>&gt;\n  @let pwGroup = registerForm.controls.password;\n\n  &lt;<span class=\"hljs-keyword\">label</span> <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;pw&quot;</span>&gt;Password&lt;/<span class=\"hljs-keyword\">label</span>&gt;\n  &lt;<span class=\"hljs-keyword\">input</span> id=<span class=\"hljs-string\">&quot;pw&quot;</span> <span class=\"hljs-keyword\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;pwGroup.controls.pw&quot;</span>&gt;\n\n  &lt;<span class=\"hljs-keyword\">label</span> <span class=\"hljs-keyword\">for</span>=<span class=\"hljs-string\">&quot;pwConfirm&quot;</span>&gt;<span class=\"hljs-keyword\">Confirm</span> Password&lt;/<span class=\"hljs-keyword\">label</span>&gt;\n  &lt;<span class=\"hljs-keyword\">input</span> id=<span class=\"hljs-string\">&quot;pwConfirm&quot;</span> <span class=\"hljs-keyword\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;pwGroup.controls.pwConfirm&quot;</span>&gt;\n&lt;/fieldset&gt;\n</code></pre><p>Für die Liste der E-Mail-Adressen wird es etwas aufwendiger.\nZunächst benötigen wir ein umschließendes Element (hier wieder <code>&lt;fieldset&gt;</code>), mit dem wir auf das <code>FormArray</code> zugreifen können.\nDazu setzen wir die Direktive <code>formArray</code> ein.\nDamit das Formular dynamisch erweiterbar bleibt, legen wir die passenden Input-Felder allerdings nicht von Hand an.\nStattdessen nutzen wir <code>@for</code> und iterieren über die Controls aus dem <code>FormArray</code>, um stets die passende Anzahl Formularfelder zu erstellen.\nAuf dem <code>FormArray</code> liefert das Property <code>controls</code> schließlich ein Array mit allen enthaltenen Controls.</p>\n<pre><code class=\"language-html\">&lt;fieldset [formArray]=<span class=\"hljs-string\">&quot;registerForm.controls.emails&quot;</span>&gt;\n  @<span class=\"hljs-keyword\">for</span> (emailCtrl of registerForm.controls.emails.controls; track <span class=\"hljs-variable\">$index</span>) {\n    &lt;label [attr.for]=<span class=\"hljs-string\">&quot;&#x27;email-&#x27; + <span class=\"hljs-variable\">$index</span>&quot;</span>&gt;E-Mail {{ <span class=\"hljs-variable\">$index</span> + 1 }}&lt;/label&gt;\n    &lt;input [<span class=\"hljs-built_in\">id</span>]=<span class=\"hljs-string\">&quot;&#x27;email-&#x27; + <span class=\"hljs-variable\">$index</span>&quot;</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">&quot;email&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;emailCtrl&quot;</span>&gt;\n  }\n&lt;/fieldset&gt;\n</code></pre><p>Du siehst hier, dass wir bereits den Weg geebnet haben für ein hochdynamisches Formular.\nMit der Methode <code>push()</code> auf dem <code>FormArray</code> könnten wir nun zur Laufzeit weitere E-Mail-Felder hinzufügen – das Template wird dank <code>@for</code> automatisch aktualisiert.</p>\n<h2 id=\"eingebaute-validatoren-nutzen\">Eingebaute Validatoren nutzen</h2>\n<p>Angular stellt für Reactive Forms einige grundlegende Funktionen bereit, um die Formulareingaben zu validieren.\nDiese eingebauten Validatoren sind in der Klasse <code>Validators</code> untergebracht.\nWir müssen sie in die Formularkomponente importieren:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Validators } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span>;\n</code></pre><table>\n<thead>\n<tr>\n<th>Validator</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>required</code></td>\n<td>Das Feld muss ausgefüllt sein.</td>\n</tr>\n<tr>\n<td><code>requiredTrue</code></td>\n<td>Der Wert muss <code>true</code> sein (z. B. eine Checkbox, die angekreuzt sein muss).</td>\n</tr>\n<tr>\n<td><code>min(5)</code></td>\n<td>Die eingegebene Zahl muss größer oder gleich 5 sein.</td>\n</tr>\n<tr>\n<td><code>max(10)</code></td>\n<td>Die eingegebene Zahl muss kleiner oder gleich 10 sein.</td>\n</tr>\n<tr>\n<td><code>minLength(5)</code></td>\n<td>Es müssen mindestens 5 Zeichen angegeben werden.</td>\n</tr>\n<tr>\n<td><code>maxLength(10)</code></td>\n<td>Es dürfen höchstens 10 Zeichen angegeben werden.</td>\n</tr>\n<tr>\n<td><code>pattern(&#39;[a-z]*&#39;)</code></td>\n<td>Der Wert des Eingabefelds wird auf den angegebenen regulären Ausdruck geprüft.</td>\n</tr>\n<tr>\n<td><code>email</code></td>\n<td>Das Feld muss eine gültige E-Mail-Adresse beinhalten.</td>\n</tr>\n</tbody></table>\n<p>Um die Controls mit den Validatoren zu verknüpfen, können wir sie bei der Erzeugung von <code>FormControl</code> notieren.\nDafür gibt es zwei Möglichkeiten:</p>\n<ul>\n<li>im zweiten Argument von <code>FormControl</code></li>\n<li>in den Optionen des Controls</li>\n</ul>\n<p>Das zweite Argument von <code>FormControl</code> kann entweder Validatoren oder das uns schon bekannte Objekt mit Optionen entgegennehmen.\nWelchen der beiden Wege wir verwenden, hängt davon ab, ob wir andere Optionen setzen wollen, z. B. <code>nonNullable</code>.\nIn beiden Fällen können wir entweder einen einzigen Validator angeben oder ein Array von Validatorfunktionen notieren.</p>\n<p>Bitte beachte, dass die Validatoren <code>required</code> und <code>email</code> direkt auf die Validatorfunktion referenzieren und deshalb ohne Funktionsklammern angegeben werden.\n<code>minLength</code> und <code>maxLength</code> hingegen sind Factory-Funktionen, die erst nach dem Aufruf eine Validatorfunktion zurückgeben.\nDas klingt kompliziert, macht es aber erst möglich, Argumente an einen Validator zu übergeben.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// Ein Validator als zweites Argument</span>\n<span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, Validators.<span class=\"hljs-keyword\">required</span>);\n\n<span class=\"hljs-comment\">// Mehrere Validatoren als Array</span>\n<span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, [Validators.<span class=\"hljs-keyword\">required</span>, Validators.minLength(<span class=\"hljs-number\">3</span>)]);\n\n<span class=\"hljs-comment\">// Validatoren in den Optionen</span>\n<span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, {\n  nonNullable: <span class=\"hljs-literal\">true</span>,\n  validators: [Validators.<span class=\"hljs-keyword\">required</span>, Validators.minLength(<span class=\"hljs-number\">3</span>)]\n});\n</code></pre><p>Geben wir mehrere Validatoren an, werden sie in dieser Reihenfolge ausgeführt.\nTrotzdem generieren nicht immer alle Validatoren einen Fehler: <code>minLength</code> und <code>maxLength</code> ignorieren beispielsweise einen leeren Eingabewert.\nKombiniert mit <code>required</code> wird <code>minLength</code> also erst dann aktiv, wenn überhaupt ein Wert eingegeben wurde und <code>required</code> nicht mehr anschlägt.</p>\n<h2 id=\"formularzustand-verarbeiten\">Formularzustand verarbeiten</h2>\n<p>Ein Formularfeld kann unterschiedliche Zustände besitzen, die sich nach drei Fragestellungen richten:</p>\n<table>\n<thead>\n<tr>\n<th>Zustand</th>\n<th>ja</th>\n<th>nein</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Wurde das Control bedient?</td>\n<td><code>touched</code></td>\n<td><code>untouched</code></td>\n</tr>\n<tr>\n<td>Wurde der Wert verändert?</td>\n<td><code>dirty</code></td>\n<td><code>pristine</code></td>\n</tr>\n<tr>\n<td>Ist der Wert gültig?</td>\n<td><code>valid</code></td>\n<td><code>invalid</code></td>\n</tr>\n</tbody></table>\n<p>Zusätzlich drückt der Zustand <code>pending</code> aus, dass eine asynchrone Validierung noch nicht abgeschlossen ist.</p>\n<p>Die Zustände werden automatisch als CSS-Klassen auf die Formularfelder im Template angewendet.\nWir können diese Klassen also nutzen, um die Felder passend zu ihrem Zustand zu stylen.\nDie Felder erhalten einen roten Rand, wenn das Control gleichzeitig <code>invalid</code> und <code>touched</code> ist.\nDiese Kombination ist sinnvoll, damit der Fehlerzustand erst angezeigt wird, nachdem wir mit dem Formular interagiert haben.</p>\n<pre><code class=\"language-css\"><span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.ng-invalid</span><span class=\"hljs-selector-class\">.ng-touched</span> {\n  <span class=\"hljs-attribute\">border-color</span>: red;\n}\n\n<span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.ng-valid</span><span class=\"hljs-selector-class\">.ng-touched</span> {\n  <span class=\"hljs-attribute\">border-color</span>: green;\n}\n</code></pre><p>Um den Formularzustand programmatisch zu verarbeiten, benötigen wir Zugriff auf das <code>FormControl</code>.\nDadurch dass das Formularmodell in der Komponentenklasse liegt, können wir direkt mit den Controls interagieren.\nDer Zugriff auf das passende Control erfolgt nach der Initialisierung der <code>FormGroup</code> über das Property <code>controls</code>.\nUm z. B. im Template eine Meldung abhängig vom Zustand anzuzeigen, können wir so vorgehen:</p>\n<pre><code class=\"language-html\">@<span class=\"hljs-keyword\">if</span> (registerForm<span class=\"hljs-selector-class\">.controls</span><span class=\"hljs-selector-class\">.username</span><span class=\"hljs-selector-class\">.invalid</span> &amp;&amp; registerForm<span class=\"hljs-selector-class\">.controls</span><span class=\"hljs-selector-class\">.username</span>.touched) {\n  &lt;<span class=\"hljs-selector-tag\">div</span> class=<span class=\"hljs-string\">&quot;error&quot;</span>&gt;Username is required&lt;/div&gt;\n}\n</code></pre><p>Übrigens werden alle diese Zustände auch auf <code>FormGroup</code> und <code>FormArray</code> zur Verfügung gestellt.\nWie in einer guten Familie kennen also die Elternelemente immer den Zustand ihrer Kinder, und der Zustand wird nach oben vererbt.\nIst z. B. ein einzelnes <code>FormControl</code> im Zustand <code>invalid</code>, so ist auch die gesamte umgebende <code>FormGroup</code> ungültig.</p>\n<h2 id=\"formular-abschicken\">Formular abschicken</h2>\n<p>Um das Formular abzuschicken, benötigen wir zunächst einen Button vom Typ <code>submit</code>.\nEr muss sich innerhalb des <code>&lt;form&gt;</code>-Elements befinden.\nWird das Formular schließlich in der Oberfläche abgeschickt, so wird ein passendes Event ausgelöst: <code>ngSubmit</code>.\nDieses Event können wir abonnieren und eine Methode ausführen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> [<span class=\"hljs-attr\">formGroup</span>]=<span class=\"hljs-string\">&quot;registerForm&quot;</span> (<span class=\"hljs-attr\">ngSubmit</span>)=<span class=\"hljs-string\">&quot;submitForm()&quot;</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Formularfelder --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span> [<span class=\"hljs-attr\">disabled</span>]=<span class=\"hljs-string\">&quot;registerForm.invalid&quot;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></pre><p>In der Komponentenklasse müssen wir die Eingabewerte aus dem Formular weiterverarbeiten.\nDie Klasse <code>AbstractControl</code> – und damit auch jede <code>FormGroup</code>, <code>FormArray</code> und <code>FormControl</code> – bietet dazu zwei Möglichkeiten.</p>\n<p>Das Property <code>value</code> beinhaltet die Werte des Formulars, bei einer <code>FormGroup</code> ist das ein Objekt mit allen erfassten Daten.\nDabei sind allerdings nur die aktivierten Controls enthalten:\nVerwenden wir die Methode <code>disable()</code>, um ein Control zu deaktivieren, kann das Formularfeld nicht mehr bedient werden.\nDas führt auch dazu, dass der Wert in <code>value</code> nicht mehr enthalten ist.\nDa theoretisch jedes Control zur Laufzeit deaktiviert werden kann, ist der Typ von <code>value</code> mit <code>Partial</code> definiert: <code>Partial</code> lockert die Typisierung eines Objekts, indem alle Eigenschaften optional gesetzt werden.</p>\n<p>Arbeiten wir mit einem festgelegten Datenmodell wie einem <code>Book</code>, ist es unpraktisch, dass alle Felder optional sind. Der erfasste Formularwert ist so nicht mit dem Datenmodell kompatibel.\nDeshalb liefert die Methode <code>getRawValue()</code> die Werte <em>aller</em> Felder – auch wenn sie deaktiviert sind.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-title function_\">submitForm</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> formValue = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">registerForm</span>.<span class=\"hljs-title function_\">getRawValue</span>();\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(formValue);\n  <span class=\"hljs-comment\">// Daten weiterverarbeiten, z. B. zum Server schicken</span>\n}\n</code></pre><p>In der Praxis empfehlen wir dir, <code>getRawValue()</code> zu verwenden.\nFalls du Controls zur Laufzeit deaktivieren möchtest, kann es sinnvoll sein, <code>value</code> zu nutzen, um die deaktivierten Felder nicht zu berücksichtigen.</p>\n<h2 id=\"formular-zurücksetzen\">Formular zurücksetzen</h2>\n<p>Nachdem das Formular erfolgreich abgeschickt wurde, können wir alle Felder auf ihren Ausgangszustand zurücksetzen.\nDas betrifft nicht nur die Formularwerte, sondern auch die Zustände des Formulars.\nAlle Controls besitzen dazu eine passende Methode <code>reset()</code>.</p>\n<p>Rufen wir <code>reset()</code> ohne Argument auf, werden die Felder entweder auf ihren definierten Startwert zurückgesetzt (falls <code>nonNullable</code> aktiviert ist) oder auf den Wert <code>null</code>.\nAlternativ können wir im Argument einen neuen Wert angeben, auf den das Formular zurückgesetzt werden soll.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// Formular auf Startwerte zurücksetzen</span>\nthis.registerForm.<span class=\"hljs-title function_ invoke__\">reset</span>();\n\n<span class=\"hljs-comment\">// Formular auf bestimmte Werte zurücksetzen</span>\nthis.registerForm.<span class=\"hljs-title function_ invoke__\">reset</span>({\n  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;default&#x27;</span>,\n  <span class=\"hljs-attr\">password</span>: { <span class=\"hljs-attr\">pw</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-attr\">pwConfirm</span>: <span class=\"hljs-string\">&#x27;&#x27;</span> },\n  <span class=\"hljs-attr\">emails</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>]\n});\n</code></pre><h2 id=\"formularwerte-setzen\">Formularwerte setzen</h2>\n<p>Um die Werte unseres Formulars programmatisch zu überschreiben, besitzen alle Controls zwei passende Methoden: <code>setValue()</code> und <code>patchValue()</code>.\nDiese beiden Hilfsmittel klingen zunächst ähnlich, haben aber einen subtilen Unterschied.</p>\n<p>Mit <code>setValue()</code> können wir die Werte des <em>gesamten</em> Controls neu setzen.\nWenden wir diese Methode auf einer <code>FormGroup</code> oder einem <code>FormArray</code> an, so müssen wir als Argument immer die exakte und vollständige Struktur übergeben – andernfalls wird ein Fehler geworfen.\nDas klingt sehr strikt, sorgt aber dafür, dass wirklich alle Felder neu gesetzt werden.</p>\n<p>Möchten wir nicht das gesamte Formular überschreiben, sondern nur <em>einzelne</em> Felder, ist die Methode <code>patchValue()</code> die richtige Wahl.\nDas übergebene Objekt kann eine Auswahl von Feldern enthalten, deren Werte im Formular überschrieben werden.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// Alle Felder setzen (muss vollständig sein)</span>\nthis.registerForm.<span class=\"hljs-title function_ invoke__\">setValue</span>({\n  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;newuser&#x27;</span>,\n  <span class=\"hljs-attr\">password</span>: { <span class=\"hljs-attr\">pw</span>: <span class=\"hljs-string\">&#x27;secret&#x27;</span>, <span class=\"hljs-attr\">pwConfirm</span>: <span class=\"hljs-string\">&#x27;secret&#x27;</span> },\n  <span class=\"hljs-attr\">emails</span>: [<span class=\"hljs-string\">&#x27;mail@example.org&#x27;</span>]\n});\n\n<span class=\"hljs-comment\">// Nur einzelne Felder setzen</span>\nthis.registerForm.<span class=\"hljs-title function_ invoke__\">patchValue</span>({\n  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;newuser&#x27;</span>\n});\n</code></pre><p>Wollen wir den Wert für ein einzelnes <code>FormControl</code> setzen, das nur einen String erfasst, ist die Bedeutung der beiden Methoden gleich. Wir empfehlen dir, in diesem Fall <code>setValue()</code> zu verwenden.\nDer Unterschied ist nur bei <code>FormGroup</code>, <code>FormArray</code> und <code>FormRecord</code> interessant.</p>\n<h2 id=\"änderungen-überwachen\">Änderungen überwachen</h2>\n<p>Stell dir einmal einen komplexen Anwendungsfall vor:\nDu möchtest anhand der Formulareingaben Berechnungen durchführen und die Ergebnisse live anzeigen.\nAbstrakt formuliert möchtest du also Änderungen an den Formularwerten überwachen und mit Aktionen darauf reagieren.\nDie Bezeichnung <em>Reactive Forms</em> kommt nicht von ungefähr: Die reaktive Denkweise versteckt sich auch in unseren Formularelementen und erlaubt es uns, flexibel mit den Eingaben umzugehen.</p>\n<p>Jedes Control besitzt dafür zwei besondere Propertys: <code>valueChanges</code> und <code>statusChanges</code>.\nDahinter verstecken sich Observables, die immer dann ein Element ausgeben, wenn sich der Formularwert (<code>valueChanges</code>) oder der Zustand (<code>statusChanges</code>) ändert.\nDer Zustand wird als Zeichenkette vom Typ <code>FormControlStatus</code> repräsentiert, die einen der folgenden Werte annimmt: <code>VALID</code>, <code>INVALID</code>, <code>PENDING</code>, <code>DISABLED</code>.\nWie bei jedem Observable können wir diese Änderungen abonnieren und weiterverarbeiten.\nMit den Möglichkeiten von RxJS lassen sich so komplexe Anwendungsfälle umsetzen.</p>\n<pre><code class=\"language-typescript\">this.registerForm.controls.username.valueChanges.pipe(\n  debounceTime(<span class=\"hljs-number\">300</span>),\n  distinctUntilChanged()\n).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;Username changed:&#x27;</span>, value);\n});\n\nthis.registerForm.statusChanges.subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">status</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;Form status:&#x27;</span>, status);\n});\n</code></pre><p>Ein praktischer Anwendungsfall ist die Typeahead-Suche, bei der die Formulareingaben zunächst entprellt werden, sodass nicht zu viele Elemente kurz nacheinander im Datenstrom ausgegeben werden.</p>\n<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n<ul>\n<li>Um Reactive Forms zu verwenden, müssen wir das <code>ReactiveFormsModule</code> importieren.</li>\n<li>Das Formularmodell wird in der Komponentenklasse erstellt. Wir verwenden dazu die Bausteine <code>FormControl</code>, <code>FormGroup</code>, <code>FormArray</code> und <code>FormRecord</code>.</li>\n<li>Die Bausteine können verschachtelt werden. Am Anfang steht fast immer eine <code>FormGroup</code>, jedes logische Formularfeld erhält ein <code>FormControl</code>.</li>\n<li>Der Typ eines Controls wird durch den eingegebenen Startwert ermittelt. Zusätzlich ist immer <code>null</code> als möglicher Wert enthalten.</li>\n<li>Ein <code>FormControl</code> kann mit der Option <code>nonNullable</code> erstellt werden. Dadurch wird der Typ <code>null</code> verboten. Wir empfehlen, <code>nonNullable</code> immer auf <code>true</code> zu setzen.</li>\n<li>Um das Template mit dem Formularmodell zu verknüpfen, setzen wir die Direktive <code>[formGroup]=&quot;myForm&quot;</code> bzw. <code>[formArray]=&quot;myForm&quot;</code> ein.</li>\n<li>Die Direktive <code>[formControl]</code> stellt eine typsichere Verknüpfung zu einem Control her. Wir empfehlen diesen Ansatz gegenüber <code>formControlName</code>.</li>\n<li>Validatoren werden bei der Initialisierung der Controls angegeben.</li>\n<li>Die Klasse <code>Validators</code> stellt einige eingebaute Validatoren bereit: <code>required</code>, <code>requiredTrue</code>, <code>min</code>, <code>max</code>, <code>minLength</code>, <code>maxLength</code>, <code>pattern</code> und <code>email</code>.</li>\n<li>Die Propertys <code>valueChanges</code> und <code>statusChanges</code> auf jedem Control geben Auskunft über Wert- und Statusänderungen.</li>\n<li>Um Controls zu deaktivieren, nutzen wir nicht das Attribut <code>disabled</code> im Template, sondern die Methoden <code>disable()</code> und <code>enable()</code> auf den Controls.</li>\n</ul>\n<h2 id=\"empfehlung\">Empfehlung</h2>\n<p>Wir empfehlen nach Möglichkeit in modernen Angular Anwendungen stets auf Signal Forms zu setzen wie du sie im Buch kennengelernt hast. Reactive Forms sind eine gute Wahl für komplexe Formulare mit dynamischen Anforderungen oder verschachtelten Strukturen – insbesondere in Projekten, die noch mit einer älteren Angular Version (vor Angular 22) arbeiten oder wo eine Migration auf Signal Forms (noch) nicht möglich ist.</p>\n","meta":{"title":"[WIP] Formulare mit Reactive Forms","published":"2026-02-10T00:00:00.000Z","lastModified":"2026-02-05T00:00:00.000Z","hidden":false}}
