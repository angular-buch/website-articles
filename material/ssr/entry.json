{"slug":"ssr","html":"<blockquote>\n<p><strong>Hinweis:</strong> Dieser Artikel ist ein Zusatzmaterial zum <a href=\"https://angular-buch.com\">Angular-Buch</a>.\nIm Buch haben wir beim Anlegen des BookManager-Projekts bewusst die Option <code>--no-ssr</code> verwendet, um Server-Side Rendering zunächst zu deaktivieren.\nSSR ist ein fortgeschrittenes Konzept, das nicht für jede Anwendung notwendig ist.</p>\n<p>In diesem Artikel zeigen wir, wie du SSR nachträglich aktivieren oder direkt bei der Projekterstellung einrichten kannst.</p>\n</blockquote>\n<hr>\n<h1 id=\"server-side-rendering-mit-angular\">Server-Side Rendering mit Angular</h1>\n<p>Single-Page-Anwendungen mit Angular bieten grundsätzlich eine gute Performance:\nIm Gegensatz zu einer herkömmlichen Webanwendung ist der Anwendungscode bereits nach dem Start im Browser verfügbar, und weitere Inhalte werden zur Laufzeit nachgeladen.\nWir profitieren davon mit schnellen Seitenwechseln und Reaktionszeiten.\nIst die Anwendung einmal heruntergeladen, müssen nur noch die darzustellenden Daten und ggf. kleinere Anwendungsteile vom Server geladen werden.</p>\n<p>So gut diese Eigenschaften aber auch klingen – sie gehen mit Nachteilen einher.\nBis die Anwendung überhaupt vom Server heruntergeladen ist, vergeht Zeit.\nDas fällt insbesondere bei langsamen Internetverbindungen ins Gewicht.\nWährenddessen sehen wir lediglich eine leere Seite mit einer Ladeanzeige.</p>\n<p>Wir möchten uns in diesem Artikel deshalb damit beschäftigen, eine Angular-Anwendung bereits auf dem Server zu rendern und so an den Client auszuliefern.\nDas bringt Verbesserungen in der wahrgenommenen Performance und optimiert die Seite besser für Suchmaschinen.</p>\n<h2 id=\"single-page-anwendungen-suchmaschinen-und-start-performance\">Single-Page-Anwendungen, Suchmaschinen und Start-Performance</h2>\n<p>Die Basis einer Angular-Anwendung ist eine einzige leere HTML-Seite.\nSie ist der Einstiegspunkt in die Anwendung und die Seite, die beim Start im Browser geladen wird.</p>\n<p>Dazu starten wir die Anwendung mit <code>ng serve</code>, öffnen die Anwendung im Browser und lassen uns den Seitenquelltext anzeigen.\nBitte schau dir die Datei wirklich im Browser an, denn das &quot;Original&quot; aus dem Dateisystem enthält nicht die Referenzen auf die gebauten Bundles.\nNutze bitte auch nicht den Elements-Tab in den Chrome DevTools, sondern die statische Quelltextanzeige.\nIn Chrome klickst du dazu rechts in die Seite und wählst <em>View Page Source</em> / <em>Seitenquelltext anzeigen</em>.</p>\n<p>Dort bekommen wir den folgenden Quelltext präsentiert:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BookManager<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;/&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-root</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">app-root</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!--&lt;app-root&gt;&lt;/app-root&gt;--&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;main.js&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre><p>Diese Seite enthält nur ein HTML-Grundgerüst und ist ansonsten weitgehend leer.\nDer Kern des Geschehens versteckt sich in den unteren Zeilen:\nWir sehen hier das Host-Element unserer Anwendung welches dem Selektor der <code>AppComponent</code> entspricht (also zum Beispiel <code>&lt;app-root&gt;</code> oder <code>&lt;bm-root&gt;</code>).\nAußerdem werden mithilfe von <code>&lt;script&gt;</code>-Tags die Bundles eingebunden, die beim Build erzeugt wurden.\nDie Bundles enthalten die Angular-Anwendung, die das Hauptelement der mit Leben füllt.</p>\n<p>Wir sehen hier das Grundprinzip einer Single-Page-Anwendung:\nDie Basis ist eine (mehr oder weniger) leere HTML-Seite, und alle weiteren Inhalte werden mithilfe von JavaScript geladen, das in den Bundles untergebracht ist.\nDie Seite wird zur Laufzeit der Anwendung niemals neu geladen, sondern der Router sorgt dafür, dass alle sichtbaren Seitenwechsel nur innerhalb der Angular-Anwendung durchgeführt werden.\nEs findet dabei niemals eine reale Navigation im Browser statt.\nDie Illusion einer Navigation geschieht durch die HTML5 History API.</p>\n<p>Stellen wir uns nun einmal vor, dass die Ausführung von JavaScript im Browser deaktiviert ist.\nDie statische HTML-Seite enthält dann keine Inhalte, und die Seite bleibt leer.\n<em>Doch deaktiviert heutzutage noch jemand JavaScript im Browser?</em>\nDiese Frage lässt sich klar mit <em>Ja</em> beantworten:\nAuch Suchmaschinen besuchen unsere Website, und viele von ihnen können gar kein JavaScript ausführen.\nDer Crawler von Google kann zwar JavaScript interpretieren, tut das allerdings nicht immer.\nRechenzeit ist teuer. Der GoogleBot führt nur JavaScript auf hoch bewerteten Seiten aus.\nDie erste Indexierung wird immer nur über die empfangene statische HTML-Seite durchgeführt.\nWer hier versagt, wird höchstwahrscheinlich von den Algorithmen des Bots nicht gut bewertet.\nDas bedeutet, dass Suchmaschinen lediglich eine weiße Seite sehen – für die Positionierung unserer Inhalte in den Suchergebnissen ist das eine denkbar schlechte Idee.</p>\n<p>Diese Thematik betrifft auch andere Situationen, in denen Maschinen unsere Anwendung aufrufen.\nEin gutes Beispiel dafür ist die Inhaltsvorschau in sozialen Netzwerken.\nWenn du einen Link zu deiner Anwendung auf BlueSky oder LinkedIn postest, generiert die Plattform automatisch eine ansprechende Vorschau mit einem Bild und dem Text von der Seite.\nIst die abgerufene Seite allerdings leer, wird die Vorschau nur wenig Informationen enthalten.</p>\n<p>Ein weiteres Problem tritt auf, wenn wir die Ladezeit der Anwendung über eine echte Internetverbindung betrachten.\nIst die Anwendung einmal geladen, so reagiert sie schnell.\nDoch bis alle Bundles heruntergeladen wurden und Angular die Seite gerendert hat, vergeht Zeit.\nDiese initiale Wartezeit lässt sich bereits dadurch optimieren, dass wir die Anwendung gezielt in Features separieren und einige Teile mithilfe von Lazy Loading oder Deferrable views erst später nachladen.\nTrotzdem benötigt der Prozess eine Weile – und währenddessen sehen wir nur eine weiße Seite.</p>\n<p>Für diese Herausforderungen gibt es zwei effektive Lösungen:</p>\n<p><strong>Keine Single-Page-Anwendung nutzen:</strong> Mit einer herkömmlichen Webanwendung hast du diese Probleme nicht.\nDafür hast du aber andere Probleme: Das Nachladen dynamischer oder interaktiver Inhalte gestaltet sich als deutlich komplizierter.\nAußerdem verzichtest du dann auf Angular, und das wäre wirklich schade!</p>\n<p><strong>HTML-Seite nicht leer lassen:</strong> Wir können uns darum bemühen, die ausgelieferte HTML-Seite mit Leben zu füllen, sodass Menschen und Suchmaschinen bereits einen sinnvollen Inhalt statt einer leeren Seite erhalten.\nDas macht die Wartezeit erträglicher, und auch für Suchmaschinen und die automatische Inhaltsvorschau sind schon die nötigen Inhalte an Bord.</p>\n<p>Damit wir die Inhalte dieser HTML-Seite nicht statisch hinterlegen müssen, wollen wir die echte Angular-Anwendung als Grundlage nutzen.\nWir betrachten dazu in diesem Artikel verschiedene Strategien, um die Anwendung bereits auf dem Server zu rendern und so die ausgelieferte Seite automatisch mit Inhalten zu füllen:</p>\n<ul>\n<li><strong>Server-Side Rendering (SSR)</strong>: Die Anwendung wird bei jedem Request auf dem Server gerendert.</li>\n<li><strong>Pre-Rendering (SSG)</strong>: Die Anwendung wird zur Build-Zeit gerendert und als statische HTML-Dateien ausgeliefert.</li>\n<li><strong>Client-Side Rendering (CSR)</strong>: Die Anwendung wird wie gewohnt im Browser gerendert.</li>\n</ul>\n<p>Angular ermöglicht es, diese Strategien pro Route individuell zu konfigurieren – das nennt sich <em>Hybrid Rendering</em>.</p>\n<p>Diese Aufgabe klingt zunächst nach viel Arbeit, doch die Plattformunabhängigkeit von Angular kommt uns zugute:\nAngular verfügt bereits über alle Voraussetzungen, um nicht nur in einem Browser ausgeführt zu werden, sondern auf jeder Plattform, die JavaScript versteht.\nDazu gehören native Mobilanwendungen und auch der Server.</p>\n<h2 id=\"ssr-aktivieren\">SSR aktivieren</h2>\n<p>Im Buch haben wir beim Anlegen des BookManager-Projekts bewusst die Option <code>--no-ssr</code> verwendet:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> book-manager <span class=\"hljs-comment\">--style=css --no-ssr</span>\n</code></pre><p>Dadurch wurde kein zusätzlicher Quellcode zur Umsetzung von Server-Side Rendering generiert.\nDas hat den Vorteil, dass wir uns zunächst auf die Grundlagen von Angular konzentrieren können, ohne uns mit der Komplexität von SSR auseinandersetzen zu müssen.</p>\n<h3 id=\"ssr-bei-der-projekterstellung-aktivieren\">SSR bei der Projekterstellung aktivieren</h3>\n<p>Wenn wir von Anfang an SSR nutzen möchten, können wir das Projekt ohne die Option <code>--no-ssr</code> anlegen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> book-manager <span class=\"hljs-comment\">--style=css</span>\n</code></pre><p>Die Angular CLI fragt dann interaktiv nach, ob SSR aktiviert werden soll.\nAlternativ können wir SSR auch explizit aktivieren:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> book-manager <span class=\"hljs-comment\">--style=css --ssr</span>\n</code></pre><h3 id=\"ssr-nachträglich-aktivieren\">SSR nachträglich aktivieren</h3>\n<p>Haben wir ein bestehendes Projekt ohne SSR angelegt, können wir die Funktionalität jederzeit nachträglich hinzufügen.\nDazu nutzen wir das Kommando <code>ng add</code>:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> @angular/ssr</span>\n</code></pre><p>Es werden verschiedene Abhängigkeiten installiert, und unsere Anwendung erhält eine Reihe von neuen Dateien und Änderungen:</p>\n<ul>\n<li><strong><code>server.ts</code></strong>: Enthält das Grundgerüst für den Serverprozess, der die Angular-Anwendung rendert und das erzeugte HTML ausliefert.</li>\n<li><strong><code>main.server.ts</code></strong>: Der Einstiegspunkt für den Server-Build.</li>\n<li><strong><code>app/app.config.ts</code></strong>: Angepasste Client-spezifische Konfiguration der Anwendung mit <a href=\"/material/ssr#hydration\">Hydration</a>.</li>\n<li><strong><code>app/app.config.server.ts</code></strong>: Die Server-spezifische Konfiguration der Anwendung.</li>\n<li><strong><code>app/app.routes.server.ts</code></strong>: Die Server-Routing-Konfiguration, in der wir festlegen, wie jede Route gerendert werden soll.</li>\n<li><strong><code>angular.json</code></strong>: Erhält neue Abschnitte mit der Build-Konfiguration für die servergerenderte Anwendung.</li>\n<li><strong><code>package.json</code></strong>: Beinhaltet neue Abhängigkeiten und NPM-Skripte für den Build-Prozess.</li>\n</ul>\n<h2 id=\"server-routing-konfigurieren\">Server-Routing konfigurieren</h2>\n<p>Angular bietet eine flexible Möglichkeit, für jede Route individuell festzulegen, wie sie gerendert werden soll.\nDie Konfiguration erfolgt in der Datei <code>app.routes.server.ts</code> mithilfe von <code>RenderMode</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.routes.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RenderMode</span>, <span class=\"hljs-title class_\">ServerRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverRoutes</span>: <span class=\"hljs-title class_\">ServerRoute</span>[] = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-comment\">// Startseite wird im Client gerendert (CSR)</span>\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Client</span>,\n  },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;about&#x27;</span>, <span class=\"hljs-comment\">// Statische Seite wird vorgerendert (SSG)</span>\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n  },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books&#x27;</span>, <span class=\"hljs-comment\">// Bücherliste wird auf dem Server gerendert (SSR)</span>\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Server</span>,\n  },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;**&#x27;</span>, <span class=\"hljs-comment\">// Alle anderen Routen werden auf dem Server gerendert</span>\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Server</span>,\n  },\n];\n</code></pre><p>Die drei verfügbaren Rendering-Modi sind:</p>\n<table>\n<thead>\n<tr>\n<th>Rendering-Modus</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RenderMode.Server</code> (SSR)</td>\n<td>Die Anwendung wird bei jedem Request auf dem Server gerendert. Ideal für dynamische Inhalte.</td>\n</tr>\n<tr>\n<td><code>RenderMode.Client</code> (CSR)</td>\n<td>Die Anwendung wird im Browser gerendert. Das ist das Standard-Verhalten von Angular.</td>\n</tr>\n<tr>\n<td><code>RenderMode.Prerender</code> (SSG)</td>\n<td>Die Anwendung wird zur Build-Zeit gerendert. Ideal für statische Inhalte.</td>\n</tr>\n</tbody></table>\n<p>Die Server-Routing-Konfiguration wird in der <code>app.config.server.ts</code> mit <code>provideServerRendering</code> und <code>withRoutes</code> registriert:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.config.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ApplicationConfig</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { provideServerRendering } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-server&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { serverRoutes } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app.routes.server&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideServerRendering</span>(<span class=\"hljs-title function_\">withRoutes</span>(serverRoutes)),\n  ],\n};\n</code></pre><h2 id=\"server-side-rendering-ssr\">Server-Side Rendering (SSR)</h2>\n<p>Wir wollen zuerst das dynamische serverseitige Rendering betrachten.\nDie Grundidee ist die folgende:\nWird die Anwendung vom Browser angefragt, so wird zuerst die <code>index.html</code> ausgeliefert.\nDiese Seite ist hingegen nicht leer, sondern auf dem Server wurde bereits die gesamte Angular-Anwendung mit der angefragten Route <em>gebootstrappt</em>.\nDer resultierende DOM mit allen Komponenten und Inhalten wird als reiner Text in der Datei <code>index.html</code> zum Client ausgeliefert.\nDiese HTML-Seite enthält außerdem weiterhin die <code>&lt;script&gt;</code>-Tags, mit denen die Anwendungsbundles geladen werden.\nSobald die Anwendung im Client hochgefahren ist, übernimmt Angular die gerenderte Seite und funktioniert wie gewohnt.\nZunächst sieht man im Browser das vorgerenderte HTML, anschließend <em>hydriert</em> die Angular die Teile der Anwendung, die nicht statisch sind.\nIm Idealfall bekommt man von diesem Prozess allerdings gar nichts mit und es wir können nach dem Laden unsere SPA wie gewohnt nutzen.</p>\n<h3 id=\"die-anwendung-bauen\">Die Anwendung bauen</h3>\n<p>Die Anwendung ist jetzt vollständig für den Servereinsatz eingerichtet.\nNun müssen wir die beiden Build-Prozesse für die zwei verschiedenen Plattformen anstoßen.\nMit dem folgenden Befehl bauen wir die Anwendung für Client und Server:</p>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-built_in\">run</span> build\n</code></pre><p>Im Ordner <code>dist/book-manager</code> befinden sich nun zwei Unterordner <code>browser</code> und <code>server</code>.\nSie enthalten die gebaute Anwendung in zwei Varianten: die normal gebaute Anwendung zur Ausführung im Browser und dieselbe Anwendung für den Server, sodass sie mit Node.js ausgeführt werden kann.\nDer Serverprozess aus der Datei <code>server.ts</code> wurde bereits in das Serverbundle integriert.</p>\n<h3 id=\"den-server-starten\">Den Server starten</h3>\n<p>Nach dem Bauen der Anwendung können wir den Serverdienst schließlich ausführen – entweder direkt mit Node.js aus dem Ordner <code>dist/book-manager/server</code> oder indem wir das vorbereitete NPM-Skript nutzen:</p>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-built_in\">run</span> serve:ssr:book-manager\n</code></pre><p>Der Server startet, und wir können die Anwendung nun unter <code>http://localhost:4000</code> erreichen.</p>\n<p>Wirf nun noch einmal einen Blick in den Quellcode der ausgelieferten HTML-Seite: Du wirst sehen, dass das Element <code>&lt;bm-root&gt;</code> den vorgerenderten Inhalt der Angular-Anwendung enthält.\nDas serverseitige Rendering hat also funktioniert!</p>\n<p>Die Angular CLI bietet für Server-Side Rendering auch einen Entwicklungswebserver mit Live Reload an, ähnlich <code>ng serve</code>:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">ng serve</span>\n</code></pre><p>Wenn SSR aktiviert ist, wird der Entwicklungsserver automatisch mit SSR-Unterstützung gestartet.</p>\n<h2 id=\"pre-rendering-ssg\">Pre-Rendering (SSG)</h2>\n<p>Wir haben gesehen, wie Server-Side Rendering funktioniert.\nObwohl diese Strategie gut funktioniert, hat sie zwei Nachteile:</p>\n<ul>\n<li>Es wird immer ein Server mit Node.js benötigt. Ein einfacher Webserver, der die Dateien statisch ausliefert, reicht nicht aus.</li>\n<li>Die Angular-Anwendung wird bei jedem Request vollständig hochgefahren, gerendert und wieder abgebaut. Für Seiten mit dynamischen Inhalten ist das sinnvoll. Statische Seiten wie Impressum, Datenschutzerklärung oder Infoseiten hingegen müssen nicht bei jedem Request neu berechnet werden, da sich der Inhalt selten ändert.</li>\n</ul>\n<p>Besteht die Anwendung vor allem aus statischen Inhalten, so müssen wir das serverseitige Rendering nicht zur Laufzeit durchführen.\nStattdessen können wir die Anwendung bereits zur Build-Zeit rendern und die erzeugten HTML-Seiten für alle Routen im Dateisystem ablegen.\nVon dort aus werden die Seiten schließlich von einem normalen Webserver ausgeliefert.\nDieses Prinzip nennt sich <em>Pre-Rendering</em> oder auch <em>Static Site Generation (SSG)</em>.</p>\n<p>Um eine Route für Pre-Rendering zu konfigurieren, setzen wir in der Server-Routing-Konfiguration den <code>RenderMode.Prerender</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.routes.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RenderMode</span>, <span class=\"hljs-title class_\">ServerRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverRoutes</span>: <span class=\"hljs-title class_\">ServerRoute</span>[] = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;about&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n  },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;impressum&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n  },\n];\n</code></pre><h3 id=\"parametrisierte-routen-mit-getprerenderparams\">Parametrisierte Routen mit <code>getPrerenderParams</code></h3>\n<p>Da die Anwendung mehrere Seiten besitzt, benötigt das Pre-Rendering eine Liste von Routen.\nBeim Build wird für jede dieser Routen eine statische HTML-Datei gerendert.\nDamit anschließend der Aufruf der URL <code>/books</code> auch tatsächlich die passende vorgerenderte HTML-Datei ausliefert, müssen die einzelnen Dateien in Unterordner gegliedert und jeweils mit <code>index.html</code> benannt werden.</p>\n<p>Starten wir das Pre-Rendering ohne weitere Konfiguration, analysiert die Angular CLI die Anwendung und extrahiert alle statischen Routen aus dem Code.\nFür viele Anwendungsfälle funktioniert dieser automatische Ansatz sehr gut, und wir müssen die Routenliste nicht manuell pflegen.\nRouten mit Parametern wie <code>books/:isbn</code> können allerdings nicht automatisch bestimmt werden, denn der Parameter ist dynamisch, und der Build-Prozess kennt die möglichen ISBNs nicht.</p>\n<p>Für parametrisierte Routen können wir die Funktion <code>getPrerenderParams</code> verwenden.\nDiese Funktion gibt ein Array von Objekten zurück, wobei jedes Objekt die Parameter für eine zu rendernde Route enthält:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.routes.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RenderMode</span>, <span class=\"hljs-title class_\">ServerRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BookService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./book.service&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverRoutes</span>: <span class=\"hljs-title class_\">ServerRoute</span>[] = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books/:isbn&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getPrerenderParams</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">const</span> bookService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookService</span>);\n      <span class=\"hljs-keyword\">const</span> isbns = <span class=\"hljs-keyword\">await</span> bookService.<span class=\"hljs-title function_\">getAllIsbns</span>();\n      <span class=\"hljs-comment\">// Erzeugt Pfade wie: /books/1234567890, /books/0987654321</span>\n      <span class=\"hljs-keyword\">return</span> isbns.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">isbn</span> =&gt;</span> ({ isbn }));\n    },\n  },\n];\n</code></pre><blockquote>\n<p><strong>Wichtig:</strong> Die Funktion <code>inject()</code> muss synchron aufgerufen werden, bevor ein <code>await</code> verwendet wird.\nSie kann nicht innerhalb von asynchronen Callbacks oder nach <code>await</code>-Statements verwendet werden.</p>\n</blockquote>\n<h3 id=\"fallback-strategien\">Fallback-Strategien</h3>\n<p>Wenn eine Route mit <code>RenderMode.Prerender</code> konfiguriert ist, aber nicht alle möglichen Parameter zur Build-Zeit bekannt sind, können wir eine Fallback-Strategie definieren.\nDiese bestimmt, was passiert, wenn eine nicht vorgerenderte Route angefragt wird:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.routes.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RenderMode</span>, <span class=\"hljs-title class_\">PrerenderFallback</span>, <span class=\"hljs-title class_\">ServerRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverRoutes</span>: <span class=\"hljs-title class_\">ServerRoute</span>[] = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books/:isbn&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n    <span class=\"hljs-attr\">fallback</span>: <span class=\"hljs-title class_\">PrerenderFallback</span>.<span class=\"hljs-property\">Server</span>, <span class=\"hljs-comment\">// Fallback zu SSR</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getPrerenderParams</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// Nur die beliebtesten Bücher vorrendern</span>\n      <span class=\"hljs-keyword\">return</span> [{ <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-string\">&#x27;1234567890&#x27;</span> }, { <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-string\">&#x27;0987654321&#x27;</span> }];\n    },\n  },\n];\n</code></pre><p>Die verfügbaren Fallback-Strategien sind:</p>\n<ul>\n<li><code>PrerenderFallback.Server</code>: Die Route wird zur Laufzeit auf dem Server gerendert (SSR).</li>\n<li><code>PrerenderFallback.Client</code>: Die Route wird im Browser gerendert (CSR).</li>\n<li><code>PrerenderFallback.None</code>: Es wird ein 404-Fehler zurückgegeben.</li>\n</ul>\n<h3 id=\"vollständig-statische-anwendung\">Vollständig statische Anwendung</h3>\n<p>Standardmäßig erzeugt Angular beim Build sowohl vorgerenderte HTML-Dateien als auch einen Server für SSR.\nWenn du eine vollständig statische Anwendung ohne Server erstellen möchtest, kannst du in der <code>angular.json</code> den <code>outputMode</code> auf <code>static</code> setzen:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;projects&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;book-manager&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">&quot;architect&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n          <span class=\"hljs-attr\">&quot;options&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n            <span class=\"hljs-attr\">&quot;outputMode&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;static&quot;</span>\n          <span class=\"hljs-punctuation\">}</span>\n        <span class=\"hljs-punctuation\">}</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre><p>Mit dieser Einstellung werden nur statische HTML-Dateien erzeugt, und es wird kein Server-Bundle generiert.\nDie Anwendung kann dann auf einem einfachen Webserver oder CDN gehostet werden.</p>\n<p>Im Ordner <code>dist/book-manager/browser</code> befindet sich danach die geplante Ordnerstruktur mit den statisch vorgerenderten HTML-Dateien.\nAußerdem enthält der Ordner weiterhin die komplette Angular-Anwendung für den Browser.\nDu kannst den gesamten Ordner nun wie gewohnt mit einem Webserver bereitstellen.\nFragen wir die Route <code>/books</code> an, so wird zuerst die vorgerenderte Datei <code>books/index.html</code> ausgeliefert.\nAnschließend werden die JavaScript-Bundles heruntergeladen, die mittels <code>&lt;script&gt;</code>-Tags eingebunden sind.\nIst die Anwendung vollständig geladen und gebootstrappt, übernimmt Angular die servergerenderte Seite, und die Anwendung funktioniert wie gewohnt.\nSuchmaschinen sehen hingegen schon direkt den gerenderten Inhalt und können die Seite indexieren.</p>\n<h2 id=\"warten-auf-asynchrone-operationen\">Warten auf asynchrone Operationen</h2>\n<p>Wenn der Server die Seite rendert, wird die Anwendung vollständig ausgeführt.\nDas bedeutet, dass z. B. auch HTTP-Requests durchgeführt und Timer gestartet werden.\nDamit die Seite nicht unvollständig ausgeliefert wird, wartet der Server, bis alle HTTP-Requests und Timer beendet sind.</p>\n<p>Das hat zwar den Vorteil, dass die Seite mit allen Daten gerendert wird, die per HTTP abgerufen werden – der Seitenaufbau verzögert sich allerdings, wenn diese Operationen Zeit in Anspruch nehmen.\nKritisch wird es, wenn lang laufende Timer in der Anwendung existieren oder gar ein Intervall verwendet wird, das niemals endet.\nSchließt die asynchrone Operation niemals ab, wird die Anwendung niemals gerendert!</p>\n<p>Probier es aus: Setze ein <code>setTimeout()</code> oder <code>setInterval()</code> in den Code und starte die Anwendung mit Server-Side Rendering.\nDie Seite wird erst geladen, wenn die Operationen abgeschlossen sind.</p>\n<p>Du musst deshalb darauf achten, asynchrone Aufgaben nur zu starten, wenn sie in absehbarer Zeit enden – oder du darfst solche Operationen nicht durchführen, wenn die Anwendung auf dem Server läuft.</p>\n<h2 id=\"serverkompatible-komponenten-schreiben\">Serverkompatible Komponenten schreiben</h2>\n<p>Einige Browser-APIs und -Funktionen sind auf dem Server nicht verfügbar.\nAnwendungen können keine browserspezifischen globalen Objekte wie <code>window</code>, <code>document</code>, <code>navigator</code> oder <code>location</code> verwenden, ebenso wie bestimmte Eigenschaften von <code>HTMLElement</code>.</p>\n<p>Code, der auf browserspezifische Symbole angewiesen ist, sollte nur im Browser ausgeführt werden, nicht auf dem Server.\nDies kann durch die Lifecycle-Hooks <code>afterEveryRender</code> und <code>afterNextRender</code> sichergestellt werden.\nDiese werden nur im Browser ausgeführt und auf dem Server übersprungen:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, afterNextRender } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">afterNextRender</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-comment\">// Dieser Code wird nur im Browser ausgeführt</span>\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Window width:&#x27;</span>, <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">innerWidth</span>);\n    });\n  }\n}\n</code></pre><blockquote>\n<p><strong>Wichtig:</strong> Vermeide die Verwendung von <code>isPlatformBrowser</code> in Templates mit <code>@if</code> oder anderen Bedingungen, um unterschiedliche Inhalte auf Server und Client zu rendern.\nDies führt zu Hydration-Mismatches und Layout-Verschiebungen, die sich negativ auf die User Experience und Core Web Vitals auswirken.\nVerwende stattdessen <code>afterNextRender</code> für browserspezifische Initialisierungen und halte den gerenderten Inhalt auf beiden Plattformen konsistent.</p>\n</blockquote>\n<h3 id=\"plattform-bestimmen-mit-platform_id\">Plattform bestimmen mit <code>PLATFORM_ID</code></h3>\n<p>In manchen Fällen ist es dennoch notwendig, die Plattform zu bestimmen.\nAngular kann uns Auskunft darüber geben, auf welcher Plattform die Anwendung gerade ausgeführt wird.\nWir können dazu das Token <code>PLATFORM_ID</code> injizieren und zusammen mit den Funktionen <code>isPlatformBrowser()</code> und <code>isPlatformServer()</code> verwenden:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-variable constant_\">PLATFORM_ID</span>, inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { isPlatformBrowser, isPlatformServer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-keyword\">private</span> platformId = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-variable constant_\">PLATFORM_ID</span>);\n\n  <span class=\"hljs-title function_\">ngOnInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isPlatformBrowser</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">platformId</span>)) {\n      <span class=\"hljs-comment\">// Dieser Code wird nur im Browser ausgeführt</span>\n    }\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isPlatformServer</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">platformId</span>)) {\n      <span class=\"hljs-comment\">// Dieser Code wird nur auf dem Server ausgeführt</span>\n    }\n  }\n}\n</code></pre><p>Eine solche Weiche ist sinnvoll, wenn native Browserschnittstellen in der Anwendung zum Einsatz kommen, z. B. das Objekt <code>window</code>.\nAuf dem Server ist kein Browser vorhanden, sondern der DOM wird lediglich emuliert.\nEin Aufruf von <code>window</code> führt daher beim Server-Side Rendering zu einem Fehler: <code>ReferenceError: window is not defined</code>.\nWir müssen also mit einer Unterscheidung nach der Plattform dafür sorgen, dass dieser Code nur dann ausgeführt wird, wenn die Anwendung im Browser gerendert wird.</p>\n<h3 id=\"zugriff-auf-document-über-dependency-injection\">Zugriff auf <code>document</code> über Dependency Injection</h3>\n<p>Anstatt direkt auf das globale <code>document</code>-Objekt zuzugreifen, solltest du das <code>DOCUMENT</code>-Token verwenden, um plattformunabhängig auf das Dokument zuzugreifen:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">DOCUMENT</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-variable language_\">document</span> = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-variable constant_\">DOCUMENT</span>);\n\n  <span class=\"hljs-title function_\">ngOnInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">document</span>.<span class=\"hljs-property\">title</span>;\n  }\n}\n</code></pre><blockquote>\n<p><strong>Tipp:</strong> Für die Verwaltung von Meta-Tags bietet Angular den <code>Meta</code>-Service an.</p>\n</blockquote>\n<h2 id=\"http-transfer-cache\">HTTP Transfer Cache</h2>\n<p>Der <code>HttpClient</code> cached ausgehende Netzwerkanfragen, wenn er auf dem Server läuft.\nDiese Informationen werden serialisiert und als Teil des initialen HTML an den Browser übertragen.\nIm Browser prüft der <code>HttpClient</code>, ob er Daten im Cache hat, und verwendet diese wieder, anstatt eine neue HTTP-Anfrage während des initialen Renderings zu machen.\nDer <code>HttpClient</code> hört auf, den Cache zu verwenden, sobald die Anwendung im Browser stabil ist.</p>\n<h3 id=\"cache-optionen-konfigurieren\">Cache-Optionen konfigurieren</h3>\n<p>Du kannst anpassen, wie Angular HTTP-Antworten während des Server-Side Renderings cached und während der Hydration wiederverwendet, indem du <code>HttpTransferCacheOptions</code> konfigurierst:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { bootstrapApplication } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { provideClientHydration, withHttpTransferCacheOptions } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n\nbootstrapApplication(App, {\n  providers: [\n    provideClientHydration(\n      withHttpTransferCacheOptions({\n        includeHeaders: [<span class=\"hljs-string\">&#x27;ETag&#x27;</span>, <span class=\"hljs-string\">&#x27;Cache-Control&#x27;</span>],\n        filter: <span class=\"hljs-function\"><span class=\"hljs-params\">(req)</span> =&gt;</span> !req.url.includes(<span class=\"hljs-string\">&#x27;/api/profile&#x27;</span>),\n        includePostRequests: <span class=\"hljs-literal\">true</span>,\n      }),\n    ),\n  ],\n});\n</code></pre><p>Standardmäßig cached der <code>HttpClient</code> alle HEAD- und GET-Anfragen, die keine <code>Authorization</code>- oder <code>Proxy-Authorization</code>-Header enthalten.</p>\n<blockquote>\n<p><strong>Wichtig:</strong> Vermeide das Einschließen sensibler Header wie Authentifizierungs-Tokens.\nDiese können benutzerspezifische Daten zwischen Anfragen leaken.</p>\n</blockquote>\n<h2 id=\"hydration\">Hydration</h2>\n<p>Hydration ist der Prozess, bei dem die servergerenderte Anwendung im Client wiederhergestellt wird.\nDabei werden die vom Server gerenderten DOM-Strukturen wiederverwendet, der Anwendungszustand übertragen und bereits abgerufene Daten übernommen.</p>\n<h3 id=\"warum-ist-hydration-wichtig\">Warum ist Hydration wichtig?</h3>\n<p>Hydration verbessert die Performance der Anwendung, indem zusätzliche Arbeit zur Neuerstellung von DOM-Knoten vermieden wird.\nStattdessen versucht Angular, vorhandene DOM-Elemente zur Laufzeit mit der Anwendungsstruktur abzugleichen und DOM-Knoten wiederzuverwenden, wo immer möglich.\nDies führt zu einer Verbesserung der Core Web Vitals (CWV), wie z. B. einer Reduzierung von First Input Delay (FID), Largest Contentful Paint (LCP) und Cumulative Layout Shift (CLS).</p>\n<p>Ohne aktivierte Hydration würde eine servergerenderte Angular-Anwendung den DOM der Anwendung zerstören und neu rendern, was zu einem sichtbaren UI-Flackern führen kann.\nDieses Neurendern kann sich negativ auf Core Web Vitals wie LCP auswirken und einen Layout-Shift verursachen.\nMit aktivierter Hydration wird der vorhandene DOM wiederverwendet und ein Flackern verhindert.</p>\n<h3 id=\"hydration-aktivieren\">Hydration aktivieren</h3>\n<p>Wenn du die Angular CLI verwendet hast, um SSR zu aktivieren (entweder bei der Projekterstellung oder später über <code>ng add @angular/ssr</code>), ist der Code zur Aktivierung von Hydration bereits in deiner Anwendung enthalten.</p>\n<p>Bei einer manuellen Einrichtung kannst du Hydration aktivieren, indem du <code>provideClientHydration</code> aus <code>@angular/platform-browser</code> importierst und zu den Providern deiner Anwendung hinzufügst:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { bootstrapApplication } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { provideClientHydration } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { App } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app/app&#x27;</span>;\n\nbootstrapApplication(App, {\n  providers: [\n    provideClientHydration(),\n  ],\n});\n</code></pre><h3 id=\"hydration-überprüfen\">Hydration überprüfen</h3>\n<p>Um zu überprüfen, ob Hydration aktiviert ist, öffne die Entwicklertools im Browser und schau in die Konsole.\nDu solltest eine Meldung mit Hydration-bezogenen Statistiken sehen, z. B. die Anzahl der hydrierten Komponenten und Knoten.</p>\n<h3 id=\"event-replay\">Event Replay</h3>\n<p>Wenn eine Anwendung auf dem Server gerendert wird, ist sie im Browser sichtbar, sobald das erzeugte HTML geladen ist.\nBenutzer könnten annehmen, dass sie mit der Seite interagieren können, aber Event-Listener werden erst nach Abschluss der Hydration angehängt.</p>\n<p>Mit dem Event Replay-Feature können alle Events, die vor der Hydration auftreten, erfasst und nach Abschluss der Hydration wiedergegeben werden.\nDu kannst es mit der Funktion <code>withEventReplay()</code> aktivieren:</p>\n<pre><code class=\"language-typescript\">import { provideClientHydration, withEventReplay } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n\nbootstrapApplicatio<span class=\"hljs-meta\">n</span>(App, {\n  providers: [\n    provideClientHydratio<span class=\"hljs-meta\">n</span>(withEventReplay()),\n  ],\n});\n</code></pre><h3 id=\"hydration-für-einzelne-komponenten-überspringen\">Hydration für einzelne Komponenten überspringen</h3>\n<p>Einige Komponenten funktionieren möglicherweise nicht korrekt mit aktivierter Hydration, z. B. wenn sie direkte DOM-Manipulation verwenden.\nAls Workaround kannst du das Attribut <code>ngSkipHydration</code> zum Tag einer Komponente hinzufügen, um die Hydration für die gesamte Komponente zu überspringen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-section\">&lt;app-chart ngSkipHydration&gt;</span><span class=\"hljs-section\">&lt;/app-chart&gt;</span>\n</code></pre><p>Alternativ kannst du <code>ngSkipHydration</code> als Host-Binding setzen:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-variable\">@Component</span>({\n  host: { ngSkipHydration: <span class=\"hljs-string\">&#x27;true&#x27;</span> },\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ChartComponent</span> </span>{ }\n</code></pre><blockquote>\n<p><strong>Hinweis:</strong> Das Attribut <code>ngSkipHydration</code> kann nur auf Komponenten-Host-Knoten verwendet werden.\nWenn du es zur Root-Komponente hinzufügst, wird die Hydration für die gesamte Anwendung deaktiviert.</p>\n</blockquote>\n<h3 id=\"einschränkungen-bei-der-hydration\">Einschränkungen bei der Hydration</h3>\n<p>Hydration erfordert, dass deine Anwendung auf Server und Client dieselbe DOM-Struktur erzeugt.\nDer Hydration-Prozess erwartet, dass der DOM-Baum an beiden Stellen die gleiche Struktur hat, einschließlich Whitespaces und Kommentarknoten.</p>\n<p>Komponenten, die direkte DOM-Manipulation mit nativen DOM-APIs durchführen, sind die häufigste Ursache für Probleme.\nWenn du Komponenten hast, die den DOM mit nativen APIs manipulieren oder <code>innerHTML</code> bzw. <code>outerHTML</code> verwenden, wird der Hydration-Prozess auf Fehler stoßen.</p>\n<p>Am besten refaktorierst du solche Komponenten, um diese Art der DOM-Manipulation zu vermeiden.\nVerwende Angular-APIs, wenn möglich.\nFalls du das Verhalten nicht refaktorieren kannst, verwende das Attribut <code>ngSkipHydration</code> als Workaround.</p>\n<h2 id=\"incremental-hydration\">Incremental Hydration</h2>\n<p>Incremental Hydration ist eine fortgeschrittene Form der Hydration, die eine granularere Kontrolle darüber ermöglicht, wann die Hydration stattfindet.\nTeile der Anwendung können dehydriert bleiben und erst bei Bedarf hydriert werden.</p>\n<p>Incremental Hydration baut auf der vollständigen Anwendungs-Hydration auf und kann kleinere initiale Bundles erzeugen, während die Benutzererfahrung vergleichbar mit einer vollständigen Hydration bleibt.\nKleinere Bundles verbessern die initialen Ladezeiten und reduzieren First Input Delay (FID) und Cumulative Layout Shift (CLS).</p>\n<h3 id=\"defer-mit-hydration-triggern\"><code>@defer</code> mit Hydration-Triggern</h3>\n<p>Im Buch haben wir bereits <code>@defer</code> kennengelernt, um Teile der Anwendung verzögert zu laden.\nMit Incremental Hydration können wir <code>@defer</code>-Blöcke nun auch für Inhalte verwenden, die &quot;above the fold&quot; (im sichtbaren Bereich) liegen.</p>\n<p>Vor Incremental Hydration hätte ein <code>@defer</code>-Block im sichtbaren Bereich dazu geführt, dass zuerst der Placeholder-Inhalt gerendert und dann durch den Hauptinhalt ersetzt wird – was einen Layout-Shift verursacht hätte.\nMit Incremental Hydration wird der Hauptinhalt des <code>@defer</code>-Blocks ohne Layout-Shift bei der Hydration gerendert.</p>\n<h3 id=\"incremental-hydration-aktivieren\">Incremental Hydration aktivieren</h3>\n<p>Du kannst Incremental Hydration für Anwendungen aktivieren, die bereits SSR mit Hydration verwenden.\nFüge die Funktion <code>withIncrementalHydration()</code> zum <code>provideClientHydration</code>-Provider hinzu:</p>\n<pre><code class=\"language-typescript\">import { provideClientHydration, withIncrementalHydration } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n\nbootstrapApplicatio<span class=\"hljs-meta\">n</span>(App, {\n  providers: [\n    provideClientHydratio<span class=\"hljs-meta\">n</span>(withIncrementalHydratio<span class=\"hljs-meta\">n</span>()),\n  ],\n});\n</code></pre><blockquote>\n<p><strong>Hinweis:</strong> Incremental Hydration aktiviert automatisch Event Replay.\nWenn du bereits <code>withEventReplay()</code> in deiner Liste hast, kannst du es nach der Aktivierung von Incremental Hydration entfernen.</p>\n</blockquote>\n<h3 id=\"hydration-trigger-für-defer\">Hydration-Trigger für <code>@defer</code></h3>\n<p>Mit Incremental Hydration kannst du zusätzliche Trigger zu <code>@defer</code>-Blöcken hinzufügen, die definieren, wann die Hydration stattfinden soll.\nEin <code>hydrate</code>-Trigger teilt Angular mit, dass die Abhängigkeiten des <code>@defer</code>-Blocks während des Server-Side Renderings geladen und der Hauptinhalt gerendert werden soll.\nIm Client bleiben die Abhängigkeiten verzögert, und der Inhalt bleibt dehydriert, bis der Hydration-Trigger ausgelöst wird.</p>\n<p>Die verfügbaren Hydration-Trigger sind:</p>\n<table>\n<thead>\n<tr>\n<th>Trigger</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>hydrate on idle</code></td>\n<td>Löst aus, wenn der Browser im Leerlauf ist.</td>\n</tr>\n<tr>\n<td><code>hydrate on viewport</code></td>\n<td>Löst aus, wenn der Inhalt in den sichtbaren Bereich scrollt.</td>\n</tr>\n<tr>\n<td><code>hydrate on interaction</code></td>\n<td>Löst aus, wenn der Benutzer mit dem Element interagiert (Klick, Tastatur).</td>\n</tr>\n<tr>\n<td><code>hydrate on hover</code></td>\n<td>Löst aus, wenn die Maus über den Bereich fährt.</td>\n</tr>\n<tr>\n<td><code>hydrate on immediate</code></td>\n<td>Löst sofort aus, nachdem der nicht-verzögerte Inhalt gerendert wurde.</td>\n</tr>\n<tr>\n<td><code>hydrate on timer(ms)</code></td>\n<td>Löst nach einer bestimmten Zeitspanne aus.</td>\n</tr>\n<tr>\n<td><code>hydrate when &lt;condition&gt;</code></td>\n<td>Löst aus, wenn eine benutzerdefinierte Bedingung wahr wird.</td>\n</tr>\n<tr>\n<td><code>hydrate never</code></td>\n<td>Der Inhalt bleibt dauerhaft dehydriert (statischer Inhalt).</td>\n</tr>\n</tbody></table>\n<h3 id=\"beispiele-für-hydration-trigger\">Beispiele für Hydration-Trigger</h3>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- Hydriert, wenn der Browser im Leerlauf ist --&gt;</span>\n@defer (hydrate on idle) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-comments</span> /&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- Hydriert, wenn der Inhalt in den sichtbaren Bereich scrollt --&gt;</span>\n@defer (hydrate on viewport) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-footer</span> /&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- Hydriert bei Benutzerinteraktion --&gt;</span>\n@defer (hydrate on interaction) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-interactive-chart</span> /&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- Hydriert nach 2 Sekunden --&gt;</span>\n@defer (hydrate on timer(2000ms)) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-delayed-content</span> /&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- Hydriert basierend auf einer Bedingung --&gt;</span>\n@defer (hydrate when isLoggedIn) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-user-dashboard</span> /&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- Bleibt dauerhaft dehydriert (statischer Inhalt) --&gt;</span>\n@defer (hydrate never) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-static-footer</span> /&gt;</span>\n}\n</code></pre><h3 id=\"hydration-trigger-mit-regulären-triggern-kombinieren\">Hydration-Trigger mit regulären Triggern kombinieren</h3>\n<p>Hydration-Trigger sind zusätzliche Trigger, die zusammen mit regulären <code>@defer</code>-Triggern verwendet werden.\nHydration ist eine Optimierung für den initialen Ladevorgang, daher gelten Hydration-Trigger nur für diesen initialen Ladevorgang.\nBei nachfolgenden clientseitigen Renderings wird der reguläre Trigger verwendet:</p>\n<pre><code class=\"language-html\">@defer (<span class=\"hljs-literal\">on</span> idle; hydrate <span class=\"hljs-literal\">on</span> interaction) {\n  &lt;app-comments /&gt;\n}\n</code></pre><p>In diesem Beispiel gilt beim initialen Laden der <code>hydrate on interaction</code>-Trigger.\nDie Hydration wird bei Interaktion mit der Komponente ausgelöst.\nBei nachfolgenden clientseitigen Renderings (z. B. wenn ein Benutzer über einen <code>routerLink</code> navigiert) gilt der <code>on idle</code>-Trigger.</p>\n<h3 id=\"verschachtelte-defer-blöcke\">Verschachtelte <code>@defer</code>-Blöcke</h3>\n<p>Angulars Komponenten- und Abhängigkeitssystem ist hierarchisch.\nDas bedeutet, dass die Hydration einer Komponente erfordert, dass auch alle übergeordneten Komponenten hydriert werden.\nWenn die Hydration für einen untergeordneten <code>@defer</code>-Block in einer verschachtelten Struktur ausgelöst wird, wird die Hydration vom obersten dehydrierten <code>@defer</code>-Block bis zum ausgelösten untergeordneten Block in dieser Reihenfolge durchgeführt.</p>\n<h3 id=\"placeholder-weiterhin-erforderlich\"><code>@placeholder</code> weiterhin erforderlich</h3>\n<p>Auch bei Incremental Hydration ist ein <code>@placeholder</code>-Block weiterhin erforderlich.\nDer <code>@placeholder</code>-Inhalt wird zwar nicht für Incremental Hydration verwendet, ist aber für nachfolgende clientseitige Renderings notwendig.\nWenn der Inhalt nicht Teil der initial geladenen Route war, wird bei der Navigation zu dieser Route der <code>@defer</code>-Block wie ein regulärer <code>@defer</code>-Block gerendert – und der <code>@placeholder</code> wird in diesen Fällen angezeigt.</p>\n<h2 id=\"wann-setze-ich-serverseitiges-rendering-ein\">Wann setze ich serverseitiges Rendering ein?</h2>\n<p>Server-Side Rendering und Pre-Rendering sind wirkungsvolle Mittel, um die wahrgenommene Ladezeit einer Anwendung zu verkürzen.\nAußerdem wird die initiale HTML-Seite nicht leer ausgeliefert, sondern enthält bereits Informationen, die für Suchmaschinen und automatische Inhaltsvorschau sinnvoll sind.\nObwohl beide Strategien mit moderatem Aufwand umsetzbar sind, sollte immer untersucht werden, ob sich der Einsatz von serverseitigem Rendering für eine bestimmte Anwendung lohnt.\nDazu solltest du stets folgende Fragen beantworten:</p>\n<ul>\n<li>Wird die Anwendung über einen externen Link aufgerufen?</li>\n<li>Besuchen Suchmaschinen und Crawler die Seite?</li>\n<li>Ist die wahrgenommene Start-Performance der Anwendung ein wichtiges Kriterium für die User Experience?</li>\n</ul>\n<p><strong>Öffentliche Anwendungen:</strong> Sinnvoll ist der Einsatz von Server-Side Rendering bei öffentlichen Portalen, deren Angebot über Links erreichbar ist und von Suchmaschinen indexiert wird.\nWenn wir die Seite mit einer potenziell langsamen Internetverbindung nutzen, kann die vorgerenderte HTML-Seite die gefühlte Performance verbessern.\nSolche Anwendungen können z. B. ein Online-Shop, Blog oder eine öffentliche Firmenwebsite sein.</p>\n<p><strong>Firmeninterne Anwendungen:</strong> Für ausschließlich interne Anwendungen ist es meist nicht notwendig, das Rendering auf dem Server vorzunehmen.\nDie Seite wird nicht von öffentlichen Suchmaschinen indexiert und wird hauptsächlich auf Desktop-Rechnern genutzt oder sogar lokal ausgeliefert.\nBeispiele sind Intranetportale, Verwaltungssoftware und Desktopanwendungen.\nAuch bei hochdynamischen Inhalten, die sich erst aus der Interaktion in der Oberfläche ergeben (z. B. ein Chat), kann es sein, dass Server-Side Rendering nicht zielführend ist.\nEbenso musst du nur die Seiten vorrendern, die von extern über einen Link aufgerufen werden können.\nInterne Bereiche wie die individuelle Bestellverwaltung in einem Online-Shop musst du also nicht servergerendert ausliefern.</p>\n<p><strong>Statische Inhalte:</strong> Pre-Rendering bietet sich immer dann an, wenn die Anwendung statische Inhalte besitzt, die keinen zeitlichen Bezug haben und sich nur aus dem Code der Anwendung ergeben.\nDabei musst du dich nicht für eine Strategie entscheiden, sondern du kannst dynamisches Server-Side Rendering und statisches Pre-Rendering parallel nutzen.\nBeispielsweise kannst du die Startseite mit dynamischen Inhalten mittels Server-Side Rendering ausliefern, während das Impressum, das Kontaktformular und die Firmenhistorie auf der Website durch Pre-Rendering erzeugt werden.\nDa für das Pre-Rendering immer die Pfade aller zu rendernden Routen bekannt sein müssen, eignet sich dieses Verfahren ohnehin nur für statische Seiten.\nGeschützte Bereiche wie eine Nutzerverwaltung hingegen solltest du gar nicht vorrendern.</p>\n","meta":{"title":"[WIP] Server-Side Rendering mit Angular","published":"2026-02-10T00:00:00.000Z","lastModified":"2026-02-05T00:00:00.000Z","hidden":false}}
