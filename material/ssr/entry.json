{"slug":"ssr","html":"<p>Single-Page-Anwendungen mit Angular bieten grundsätzlich eine gute Performance:\nIm Gegensatz zu einer herkömmlichen Webanwendung ist der Anwendungscode bereits nach dem Start im Browser verfügbar, und weitere Inhalte werden zur Laufzeit nachgeladen.\nWir profitieren davon mit schnellen Seitenwechseln und Reaktionszeiten.\nIst die Anwendung einmal heruntergeladen, müssen nur noch die darzustellenden Daten und ggf. kleinere Anwendungsteile vom Server geladen werden.</p>\n<p>So gut diese Eigenschaften aber auch klingen: Sie gehen mit Nachteilen einher.\nBis die Anwendung überhaupt vom Server heruntergeladen ist, vergeht Zeit.\nDas fällt insbesondere bei einer langsamen Internetverbindung ins Gewicht.\nWährenddessen sehen wir lediglich eine leere Seite.</p>\n<p>In diesem Kapitel geht es darum, eine Angular-Anwendung bereits auf dem Server zu rendern und so an den Client auszuliefern.\nDas bringt Verbesserungen in der wahrgenommenen Performance und optimiert die Seite besser für Suchmaschinen.</p>\n<h2 id=\"single-page-anwendungen-suchmaschinen-und-start-performance\">Single-Page-Anwendungen, Suchmaschinen und Start-Performance</h2>\n<p>Die Basis einer Angular-Anwendung ist eine einzige leere HTML-Seite.\nSie ist der Einstiegspunkt in die Anwendung und die Seite, die beim Start im Browser geladen wird.</p>\n<p>Dafür nehmen wir uns eine Angular-Anwendung, z. B. das Projekt <em>BookManager</em> aus dem Angular-Buch.\nWir starten die Anwendung mit <code>ng serve</code>, öffnen die Seite im Browser und lassen uns den Seitenquelltext anzeigen.\nBitte schau dir die Datei wirklich im Browser an, denn das &quot;Original&quot; aus dem Dateisystem enthält nicht die Referenzen auf die gebauten Bundles.\nNutze bitte auch nicht den Elements-Tab in den Chrome DevTools, sondern die statische Quelltextanzeige.\nIn Chrome klickst du dazu rechts in die Seite und wählst <em>View Page Source</em> / <em>Seitenquelltext anzeigen</em>.</p>\n<p>Dort bekommen wir den folgenden Quelltext präsentiert:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/@vite/client&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>BookManager<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;/&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;icon&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;image/x-icon&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;favicon.ico&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;styles.css&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-root</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">app-root</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;main.js&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre><p>Diese Seite enthält nur ein HTML-Grundgerüst und ist ansonsten weitgehend leer.\nDer Kern des Geschehens versteckt sich in den unteren Zeilen:\nWir sehen hier das Host-Element unserer Anwendung, welches dem Selektor der Komponente <code>App</code> entspricht, also in der Regel <code>&lt;app-root&gt;</code>.\nAußerdem werden mithilfe von <code>&lt;script&gt;</code>-Tags die Bundles eingebunden, die beim Build erzeugt wurden.\nDie Bundles enthalten die Angular-Anwendung, die das Element <code>&lt;app-root&gt;</code> mit Leben füllt.</p>\n<p>Wir sehen hier das Grundprinzip einer Single-Page-Anwendung:\nDie Basis ist eine (mehr oder weniger) leere HTML-Seite, und alle weiteren Inhalte werden mithilfe von JavaScript geladen, das in den Bundles untergebracht ist.\nDie Seite wird zur Laufzeit der Anwendung niemals neu geladen, sondern der Router sorgt dafür, dass alle sichtbaren Seitenwechsel nur innerhalb der Angular-Anwendung durchgeführt werden.\nEs findet dabei niemals eine echte Navigation im Browser statt, sondern Angular verwaltet die History des Browsers und erzeugt virtuelle Seitenwechsel.</p>\n<p>Stellen wir uns nun einmal vor, dass die Ausführung von JavaScript im Browser deaktiviert ist.\nDie statische HTML-Seite enthält dann keine Inhalte, und die Seite bleibt leer.\n<em>Doch deaktiviert heutzutage noch jemand JavaScript im Browser?</em>\nDiese Frage lässt sich klar mit <em>Ja</em> beantworten:\nAuch Suchmaschinen und AI-Werkzeuge rufen unsere Website ab, und viele von ihnen können gar kein JavaScript ausführen.\nDer Crawler von Google kann zwar JavaScript interpretieren, tut das allerdings nicht immer.\nRechenzeit ist teuer. Der GoogleBot führt JavaScript deshalb nur auf hoch bewerteten Seiten aus.\nDie erste Indexierung wird immer nur über die empfangene statische HTML-Seite durchgeführt.\nWer hier versagt, wird höchstwahrscheinlich von den Algorithmen des Bots nicht gut bewertet.\nDas bedeutet, dass Suchmaschinen lediglich eine weiße Seite sehen – für die Positionierung unserer Inhalte in den Suchergebnissen ist das eine denkbar schlechte Idee.</p>\n<p>Diese Thematik betrifft auch andere Situationen, in denen Maschinen unsere Anwendung aufrufen.\nEin gutes Beispiel dafür ist die Inhaltsvorschau in sozialen Netzwerken.\nWenn du einen Link zu deiner Anwendung auf BlueSky oder LinkedIn postest, generiert die Plattform automatisch eine ansprechende Vorschau mit einem Bild und dem Text von der Seite.\nIst die abgerufene Seite allerdings leer, wird die Vorschau nur wenige Informationen enthalten.</p>\n<p>Ein weiteres Problem tritt auf, wenn wir die Ladezeit der Anwendung über eine echte Internetverbindung betrachten.\nIst die Anwendung einmal geladen, so reagiert sie schnell.\nDoch bis alle Bundles heruntergeladen wurden und Angular die Seite gerendert hat, vergeht Zeit.\nDiese initiale Wartezeit lässt sich bereits dadurch optimieren, dass wir die Anwendung gezielt in Features separieren und einige Teile mithilfe von Lazy Loading oder Deferrable views erst später nachladen.\nTrotzdem benötigt der Prozess eine Weile, und währenddessen sehen wir nur eine weiße Seite.</p>\n<p>Für diese Herausforderungen gibt es zwei effektive Lösungen:</p>\n<p><strong>Keine Single-Page-Anwendung nutzen:</strong> Mit einer herkömmlichen Webanwendung gibt es diese Probleme nicht.\nDafür stehen wir vor anderen Herausforderungen: Das Nachladen dynamischer oder interaktiver Inhalte gestaltet sich als deutlich komplizierter.\nAußerdem verzichten wir dann auf Angular, und das wäre wirklich schade!</p>\n<p><strong>HTML-Seite nicht leer lassen:</strong> Wir können uns darum bemühen, die ausgelieferte HTML-Seite mit Leben zu füllen, sodass Menschen und Suchmaschinen bereits einen sinnvollen Inhalt statt einer leeren Seite erhalten.\nDas macht die Wartezeit erträglicher, und auch für Suchmaschinen, AI-Agenten und die automatische Inhaltsvorschau sind schon die nötigen Inhalte an Bord.</p>\n<p>Damit wir die Inhalte dieser HTML-Seite nicht statisch hinterlegen müssen, wollen wir die echte Angular-Anwendung als Grundlage nutzen.\nWir betrachten dazu in diesem Artikel verschiedene Strategien:</p>\n<ul>\n<li><strong>Server-Side Rendering (SSR)</strong>: Die Anwendung wird bei jedem Request auf dem Server gerendert.</li>\n<li><strong>Pre-Rendering (SSG)</strong>: Die Anwendung wird zur Build-Zeit gerendert und als statische HTML-Dateien ausgeliefert.</li>\n<li><strong>Client-Side Rendering (CSR)</strong>: Die Anwendung wird wie gewohnt im Browser gerendert.</li>\n</ul>\n<p>Angular ermöglicht es, diese Strategien pro Route individuell zu konfigurieren – das nennt sich <em>Hybrid Rendering</em>.</p>\n<p>Diese Aufgabe klingt zunächst nach viel Arbeit, doch die Plattformunabhängigkeit von Angular kommt uns zugute:\nAngular verfügt bereits über alle Voraussetzungen, um nicht nur in einem Browser ausgeführt zu werden, sondern auch auf dem Server.</p>\n<h2 id=\"ssr-aktivieren\">SSR aktivieren</h2>\n<p>Als wir im Angular-Buch das Beispielprojekt <em>BookManager</em> angelegt haben, haben wir bewusst die Option <code>--no-ssr</code> verwendet:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> book-manager <span class=\"hljs-comment\">--style=css --no-ssr</span>\n</code></pre><p>Dadurch wurde kein zusätzlicher Quellcode zur Umsetzung von Server-Side Rendering generiert.\nDas hat den Vorteil, dass wir uns zunächst auf die Grundlagen von Angular konzentrieren konnten, ohne uns mit der Komplexität von SSR auseinandersetzen zu müssen.</p>\n<h3 id=\"ssr-bei-der-projekterstellung-aktivieren\">SSR bei der Projekterstellung aktivieren</h3>\n<p>Wenn wir von Anfang an SSR nutzen möchten, können wir das Projekt ohne die Option <code>--no-ssr</code> anlegen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> book-manager <span class=\"hljs-comment\">--style=css</span>\n</code></pre><p>Die Angular CLI fragt dann interaktiv nach, ob SSR aktiviert werden soll.\nAlternativ können wir SSR auch explizit aktivieren:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> book-manager <span class=\"hljs-comment\">--style=css --ssr</span>\n</code></pre><h3 id=\"ssr-nachträglich-aktivieren\">SSR nachträglich aktivieren</h3>\n<p>Haben wir ein bestehendes Projekt ohne SSR angelegt, können wir die Funktionalität jederzeit nachträglich hinzufügen.\nDazu nutzen wir das folgende Kommando:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> @angular/ssr</span>\n</code></pre><h3 id=\"struktur-des-projekts\">Struktur des Projekts</h3>\n<p>Es werden verschiedene Abhängigkeiten installiert, und unsere Anwendung erhält eine Reihe von zusätzlichen Dateien und Änderungen:</p>\n<ul>\n<li><strong><code>src/server.ts</code></strong>: enthält das Grundgerüst für den Serverprozess, der die Angular-Anwendung rendert und das erzeugte HTML ausliefert</li>\n<li><strong><code>src/main.server.ts</code></strong>: Einstiegspunkt für den Server-Build</li>\n<li><strong><code>src/app/app.config.ts</code></strong>: angepasste clientspezifische Konfiguration der Anwendung mit <a href=\"/material/ssr#hydration\">Hydration</a></li>\n<li><strong><code>src/app/app.config.server.ts</code></strong>: serverspezifische Konfiguration der Anwendung</li>\n<li><strong><code>src/app/app.routes.server.ts</code></strong>: Server-Routing-Konfiguration, in der wir festlegen, wie jede Route gerendert werden soll</li>\n<li><strong><code>angular.json</code></strong>: enthält neue Abschnitte mit der Build-Konfiguration für die servergerenderte Anwendung</li>\n<li><strong><code>package.json</code></strong>: enthält neue Abhängigkeiten und NPM-Skripte für den Build-Prozess</li>\n</ul>\n<p>In der Datei <code>angular.json</code> wird unter dem Build-Target <code>build</code> die SSR-Konfiguration hinterlegt.\nMit <code>outputMode</code> legen wir fest, wie die Anwendung ausgeliefert wird:\nDer Wert <code>server</code> sorgt dafür, dass ein Server-Bundle generiert wird, das die Anwendung zur Laufzeit rendern kann.</p>\n<pre><code class=\"language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;projects&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;book-manager&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">&quot;architect&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n          <span class=\"hljs-attr\">&quot;options&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n            <span class=\"hljs-attr\">&quot;server&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;src/main.server.ts&quot;</span><span class=\"hljs-punctuation\">,</span>\n            <span class=\"hljs-attr\">&quot;outputMode&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;server&quot;</span><span class=\"hljs-punctuation\">,</span>\n            <span class=\"hljs-attr\">&quot;ssr&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n              <span class=\"hljs-attr\">&quot;entry&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;src/server.ts&quot;</span>\n            <span class=\"hljs-punctuation\">}</span>\n          <span class=\"hljs-punctuation\">}</span>\n        <span class=\"hljs-punctuation\">}</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre><h2 id=\"server-routing-konfigurieren\">Server-Routing konfigurieren</h2>\n<p>Angular bietet eine flexible Möglichkeit, für jede Route individuell festzulegen, wie sie gerendert werden soll.\nDie Konfiguration erfolgt in der Datei <code>app.routes.server.ts</code> mithilfe von <code>RenderMode</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.routes.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RenderMode</span>, <span class=\"hljs-title class_\">ServerRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverRoutes</span>: <span class=\"hljs-title class_\">ServerRoute</span>[] = [\n  <span class=\"hljs-comment\">// Startseite wird im Client gerendert (CSR)</span>\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Client</span>,\n  },\n  <span class=\"hljs-comment\">// Statische Seite wird beim Build vorgerendert (SSG)</span>\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;about&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n  },\n  <span class=\"hljs-comment\">// Buchliste wird auf dem Server gerendert (SSR)</span>\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Server</span>,\n  },\n  <span class=\"hljs-comment\">// Alle anderen Routen werden auf dem Server gerendert</span>\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;**&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Server</span>,\n  },\n];\n</code></pre><p>Die drei verfügbaren Rendering-Modi sind:</p>\n<table>\n<thead>\n<tr>\n<th>Rendering-Modus</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RenderMode.Server</code> (SSR)</td>\n<td>Die Anwendung wird bei jedem Request auf dem Server gerendert. Das ist ideal für dynamische Inhalte.</td>\n</tr>\n<tr>\n<td><code>RenderMode.Client</code> (CSR)</td>\n<td>Die Anwendung wird im Browser gerendert. Das ist das Standard-Verhalten von Angular.</td>\n</tr>\n<tr>\n<td><code>RenderMode.Prerender</code> (SSG)</td>\n<td>Die Anwendung wird zur Build-Zeit gerendert. Das ist ideal für statische Inhalte.</td>\n</tr>\n</tbody></table>\n<p>Die Server-Routing-Konfiguration wird in der Datei <code>app.config.server.ts</code> registriert:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.config.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { mergeApplicationConfig, <span class=\"hljs-title class_\">ApplicationConfig</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { provideServerRendering, withRoutes } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { appConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app.config&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { serverRoutes } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app.routes.server&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideServerRendering</span>(<span class=\"hljs-title function_\">withRoutes</span>(serverRoutes)),\n  ],\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = <span class=\"hljs-title function_\">mergeApplicationConfig</span>(appConfig, serverConfig);\n</code></pre><p>Die Serverkonfiguration wird mit <code>mergeApplicationConfig</code> mit der allgemeinen Konfiguration der Anwendung aus <code>app.config.ts</code> zusammengeführt.\nAuf diese Weise müssen wir die Providers nicht doppelt definieren.</p>\n<h2 id=\"server-side-rendering-ssr\">Server-Side Rendering (SSR)</h2>\n<p>Wir wollen zuerst das dynamische serverseitige Rendering betrachten.\nDie Grundidee ist die folgende:\nWird die Anwendung vom Browser angefragt, so wird zuerst die <code>index.html</code> ausgeliefert.\nDiese Seite ist hingegen nicht leer, sondern auf dem Server wurde bereits die gesamte Angular-Anwendung mit der angefragten Route <em>gebootstrappt</em>.\nDer resultierende DOM mit allen Komponenten und Inhalten wird als reiner Text in der Datei <code>index.html</code> zum Client ausgeliefert.\nDiese HTML-Seite enthält außerdem weiterhin die <code>&lt;script&gt;</code>-Tags, mit denen die Anwendungsbundles geladen werden.\nSobald die Anwendung im Client hochgefahren ist, übernimmt Angular die gerenderte Seite und funktioniert wie gewohnt.\nZunächst sieht man im Browser das vorgerenderte HTML, anschließend <em>hydriert</em> Angular die Anwendung.\nIm Idealfall bekommt man von diesem Prozess allerdings gar nichts mit und wir können die Anwendung nach dem Laden wie gewohnt nutzen.</p>\n<h3 id=\"die-anwendung-bauen\">Die Anwendung bauen</h3>\n<p>Nach der Einrichtung kann die Anwendung wie gewohnt gebaut werden:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">ng build</span>\n</code></pre><p>Im Ordner <code>dist/book-manager</code> befinden sich nun zwei Unterordner <code>browser</code> und <code>server</code>.\nSie enthalten die gebaute Anwendung in zwei Varianten: die normal gebaute Anwendung zur Ausführung im Browser und dieselbe Anwendung für den Server, sodass sie mit Node.js ausgeführt werden kann.\nDer Serverprozess aus der Datei <code>src/server.ts</code> wurde bereits in das Serverbundle integriert.</p>\n<h3 id=\"den-server-starten\">Den Server starten</h3>\n<p>Nach dem Bauen der Anwendung können wir den Serverdienst schließlich ausführen.\nDas funktioniert entweder direkt mit Node.js aus dem Ordner <code>dist/book-manager/server</code> oder indem wir das vorbereitete NPM-Skript nutzen:</p>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-built_in\">run</span> serve:ssr:book-manager\n</code></pre><p>Der Server startet, und wir können die Anwendung nun unter <code>http://localhost:4000</code> erreichen.</p>\n<p>Wirf nun noch einmal einen Blick in den Quellcode der ausgelieferten HTML-Seite: Du wirst sehen, dass das Element <code>&lt;app-root&gt;</code> den vorgerenderten Inhalt der Angular-Anwendung enthält.\nDas serverseitige Rendering hat also funktioniert!</p>\n<h3 id=\"entwicklungsserver-mit-ssr\">Entwicklungsserver mit SSR</h3>\n<p>Für die Entwicklung müssen wir die Anwendung nicht jedes Mal manuell bauen.\nWenn SSR aktiviert ist, wird der Entwicklungsserver automatisch mit SSR-Unterstützung gestartet.\nWir können die Anwendung also wie gewohnt mit <code>ng serve</code> starten und gleichzeitig das serverseitige Rendering testen.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">ng serve</span>\n</code></pre><h2 id=\"pre-rendering-ssg\">Pre-Rendering (SSG)</h2>\n<p>Wir haben gesehen, wie Server-Side Rendering funktioniert.\nObwohl diese Strategie gut funktioniert, hat sie zwei Nachteile:</p>\n<ul>\n<li>Es wird immer ein Server mit Node.js benötigt. Ein einfacher Webserver, der die Dateien statisch ausliefert, reicht nicht aus.</li>\n<li>Die Angular-Anwendung wird bei jedem Request vollständig hochgefahren, gerendert und wieder abgebaut. Für Seiten mit dynamischen Inhalten ist das sinnvoll. Statische Seiten wie Impressum, Datenschutzerklärung oder Infoseiten hingegen müssen nicht bei jedem Request neu berechnet werden, da sich der Inhalt selten ändert.</li>\n</ul>\n<p>Für statische Inhalte müssen wir das serverseitige Rendering nicht zur Laufzeit durchführen.\nStattdessen können wir die Anwendung bereits zur Build-Zeit rendern und die erzeugten HTML-Seiten im Dateisystem ablegen.\nVon dort aus werden die Seiten schließlich von einem normalen Webserver ausgeliefert.\nDieses Prinzip nennt sich <em>Pre-Rendering</em> oder auch <em>Static Site Generation (SSG)</em>.</p>\n<p>Um eine Route für Pre-Rendering zu konfigurieren, verwenden wir in der Server-Routing-Konfiguration die Variante <code>RenderMode.Prerender</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.routes.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RenderMode</span>, <span class=\"hljs-title class_\">ServerRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverRoutes</span>: <span class=\"hljs-title class_\">ServerRoute</span>[] = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;home&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n  },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n  },\n];\n</code></pre><p>Beim Build wird für jede festgelegte Route eine statische HTML-Datei gerendert.\nDamit anschließend der Aufruf der URL <code>/books</code> auch tatsächlich die passende vorgerenderte HTML-Datei ausliefert, werden die einzelnen Dateien in Unterordner gegliedert und jeweils mit <code>index.html</code> benannt.\nDas passiert beim Build automatisch, wie wir im Ordner <code>dist/book-manager/browser</code> sehen können.</p>\n<h3 id=\"parametrisierte-routen-mit-getprerenderparams\">Parametrisierte Routen mit <code>getPrerenderParams</code></h3>\n<p>Bei Routen mit Parametern wie <code>books/details/:isbn</code> ist nicht automatisch bekannt, welche konkreten Parameter eingesetzt werden müssen.\nDer Build-Prozess kennt die möglichen ISBNs nicht.</p>\n<p>Deshalb können wir die Funktion <code>getPrerenderParams()</code> verwenden.\nSie gibt ein Array von Objekten zurück, wobei jedes Objekt die Parameter für eine zu rendernde Route enthält.\nWir können zum Beispiel einen Service nutzen, um die Liste der ISBNs vom Server abzurufen.\nBitte beachte, dass wir hier das native <code>async</code>/<code>await</code> verwenden, das mit Promises arbeitet. Die Methode <code>getISBNList()</code> muss also eine Promise zurückgeben.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.routes.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RenderMode</span>, <span class=\"hljs-title class_\">ServerRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BookStore</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./shared/book-store&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverRoutes</span>: <span class=\"hljs-title class_\">ServerRoute</span>[] = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books/details/:isbn&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getPrerenderParams</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">const</span> bookStore = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookStore</span>);\n      <span class=\"hljs-keyword\">const</span> isbns = <span class=\"hljs-keyword\">await</span> bookStore.<span class=\"hljs-title function_\">getISBNList</span>();\n      <span class=\"hljs-comment\">// Erzeugt Pfade wie: /books/details/1234567890, /books/details/0987654321</span>\n      <span class=\"hljs-keyword\">return</span> isbns.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">isbn</span> =&gt;</span> ({ isbn }));\n    },\n  },\n];\n</code></pre><blockquote>\n<p><strong>Wichtig:</strong> Die Funktion <code>inject()</code> muss synchron aufgerufen werden, bevor ein <code>await</code> verwendet wird.\nSie kann nicht innerhalb von asynchronen Callbacks oder nach <code>await</code>-Statements verwendet werden.</p>\n</blockquote>\n<h3 id=\"fallback-strategien\">Fallback-Strategien</h3>\n<p>Wenn eine Route mit <code>RenderMode.Prerender</code> konfiguriert ist, aber nicht alle möglichen Parameter zur Build-Zeit bekannt sind, können wir eine Fallback-Strategie definieren.\nSie legt fest, was passiert, wenn eine nicht vorgerenderte Route angefragt wird:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.routes.server.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RenderMode</span>, <span class=\"hljs-title class_\">PrerenderFallback</span>, <span class=\"hljs-title class_\">ServerRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/ssr&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">serverRoutes</span>: <span class=\"hljs-title class_\">ServerRoute</span>[] = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books/details/:isbn&#x27;</span>,\n    <span class=\"hljs-attr\">renderMode</span>: <span class=\"hljs-title class_\">RenderMode</span>.<span class=\"hljs-property\">Prerender</span>,\n    <span class=\"hljs-attr\">fallback</span>: <span class=\"hljs-title class_\">PrerenderFallback</span>.<span class=\"hljs-property\">Server</span>, <span class=\"hljs-comment\">// Fallback zu SSR</span>\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getPrerenderParams</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// Nur die beliebtesten Bücher vorrendern</span>\n      <span class=\"hljs-keyword\">return</span> [{ <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-string\">&#x27;1234567890&#x27;</span> }, { <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-string\">&#x27;0987654321&#x27;</span> }];\n    },\n  },\n];\n</code></pre><p>Die verfügbaren Fallback-Strategien sind:</p>\n<ul>\n<li><code>PrerenderFallback.Server</code> (Standard): Die Route wird zur Laufzeit auf dem Server gerendert (SSR).</li>\n<li><code>PrerenderFallback.Client</code>: Die Route wird im Browser gerendert (CSR).</li>\n<li><code>PrerenderFallback.None</code>: Es wird ein 404-Fehler zurückgegeben.</li>\n</ul>\n<h3 id=\"ssg-für-die-gesamte-anwendung\">SSG für die gesamte Anwendung</h3>\n<p>Standardmäßig erzeugt Angular beim Build sowohl vorgerenderte HTML-Dateien als auch einen Server für SSR.\nWenn du eine vollständig statisch gerenderte Anwendung ohne Server erstellen möchtest, kannst du in der <code>angular.json</code> den <code>outputMode</code> auf <code>static</code> setzen:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;projects&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;book-manager&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">&quot;architect&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n          <span class=\"hljs-attr\">&quot;options&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n            <span class=\"hljs-attr\">&quot;outputMode&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;static&quot;</span>\n          <span class=\"hljs-punctuation\">}</span>\n        <span class=\"hljs-punctuation\">}</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre><p>Mit dieser Einstellung werden nur statische HTML-Dateien erzeugt, und es wird kein Server-Bundle generiert.\nDie Anwendung kann dann auf einem einfachen Webserver oder CDN gehostet werden.</p>\n<p>Im Ordner <code>dist/book-manager/browser</code> befindet sich danach die geplante Ordnerstruktur mit den statisch vorgerenderten HTML-Dateien.\nAußerdem enthält der Ordner weiterhin die komplette Angular-Anwendung für den Browser.\nDu kannst den gesamten Ordner nun wie gewohnt mit einem Webserver bereitstellen.\nFragen wir die Route <code>/books</code> an, so wird zuerst die vorgerenderte Datei <code>books/index.html</code> ausgeliefert.\nAnschließend werden die JavaScript-Bundles heruntergeladen, die mittels <code>&lt;script&gt;</code>-Tags eingebunden sind.\nIst die Anwendung vollständig geladen und gebootstrappt, übernimmt Angular die servergerenderte Seite, und die Anwendung funktioniert wie gewohnt.\nSuchmaschinen sehen hingegen schon direkt den gerenderten Inhalt und können die Seite indexieren.</p>\n<h2 id=\"warten-auf-asynchrone-operationen\">Warten auf asynchrone Operationen</h2>\n<p>Sowohl beim Server-Side Rendering als auch beim Pre-Rendering wird die Anwendung vollständig ausgeführt.\nDas bedeutet, dass z. B. auch HTTP-Requests durchgeführt und Timer gestartet werden.\nDamit die Seite nicht unvollständig ausgeliefert wird, wartet der Server, bis alle HTTP-Requests und Timer beendet sind.</p>\n<p>Das hat zwar den Vorteil, dass die Seite mit allen Daten gerendert wird, die per HTTP abgerufen werden – der Seitenaufbau verzögert sich allerdings, wenn diese Operationen Zeit in Anspruch nehmen.\nKritisch wird es, wenn lang laufende Timer in der Anwendung existieren oder gar ein Intervall verwendet wird, das niemals endet.\nSchließt die asynchrone Operation niemals ab, wird die Anwendung niemals gerendert!</p>\n<p>Probier es aus: Setze ein <code>setTimeout()</code> oder <code>setInterval()</code> in den Code und starte die Anwendung mit Server-Side Rendering.\nDie Seite wird erst geladen, wenn die Operationen abgeschlossen sind.</p>\n<p>Du musst deshalb darauf achten, asynchrone Aufgaben nur zu starten, wenn sie in absehbarer Zeit enden – oder du darfst solche Operationen nicht durchführen, wenn die Anwendung auf dem Server läuft.</p>\n<h2 id=\"serverkompatible-komponenten-schreiben\">Serverkompatible Komponenten schreiben</h2>\n<p>Auf dem Server ist kein Browser vorhanden, sondern der DOM wird lediglich emuliert.\nBrowserspezifische Objekte wie <code>window</code>, <code>document</code>, <code>navigator</code> oder <code>location</code> stehen deshalb nicht zur Verfügung, ebenso einige Eigenschaften von <code>HTMLElement</code>.\nEin Aufruf von <code>window</code> führt daher beim Server-Side Rendering zu einem Fehler: <code>ReferenceError: window is not defined</code>.\nWir müssen also mit einer Unterscheidung nach der Plattform dafür sorgen, dass dieser Code nur dann ausgeführt wird, wenn die Anwendung im Browser gerendert wird.</p>\n<p>Dies kann durch die Lifecycle Hooks <code>afterEveryRender</code> und <code>afterNextRender</code> sichergestellt werden.\nDiese werden nur im Browser ausgeführt und auf dem Server übersprungen:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, afterNextRender } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">afterNextRender</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-comment\">// Dieser Code wird nur im Browser ausgeführt</span>\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Window width:&#x27;</span>, <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">innerWidth</span>);\n    });\n  }\n}\n</code></pre><h3 id=\"plattform-bestimmen-mit-platform_id\">Plattform bestimmen mit <code>PLATFORM_ID</code></h3>\n<p>In manchen Fällen reicht <code>afterNextRender</code> nicht aus, z. B. wenn wir Code unterschiedlich ausführen müssen, aber kein Rendering betroffen ist.\nAngular kann uns Auskunft darüber geben, auf welcher Plattform die Anwendung gerade ausgeführt wird.\nWir können dazu das Token <code>PLATFORM_ID</code> injizieren und zusammen mit den Funktionen <code>isPlatformBrowser()</code> und <code>isPlatformServer()</code> verwenden:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-variable constant_\">PLATFORM_ID</span>, inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { isPlatformBrowser, isPlatformServer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  #platformId = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-variable constant_\">PLATFORM_ID</span>);\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isPlatformBrowser</span>(<span class=\"hljs-variable language_\">this</span>.#platformId)) {\n      <span class=\"hljs-comment\">// Dieser Code wird nur im Browser ausgeführt</span>\n    }\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isPlatformServer</span>(<span class=\"hljs-variable language_\">this</span>.#platformId)) {\n      <span class=\"hljs-comment\">// Dieser Code wird nur auf dem Server ausgeführt</span>\n    }\n  }\n}\n</code></pre><blockquote>\n<p><strong>Wichtig:</strong> Vermeide <code>isPlatformBrowser()</code> in Templates mit <code>@if</code> oder anderen Bedingungen, um unterschiedliche Inhalte auf Server und Client zu rendern.\nDies führt zu Hydration-Mismatches und Layout-Verschiebungen, die sich negativ auf die User Experience und Core Web Vitals auswirken.\nVerwende stattdessen <code>afterNextRender()</code> für browserspezifische Initialisierungen und halte den gerenderten Inhalt auf beiden Plattformen konsistent.</p>\n</blockquote>\n<h3 id=\"zugriff-auf-document-über-dependency-injection\">Zugriff auf <code>document</code> über Dependency Injection</h3>\n<p>Anstatt direkt auf das globale <code>document</code>-Objekt zuzugreifen, solltest du das <code>DOCUMENT</code>-Token verwenden, um plattformunabhängig auf das Dokument zuzugreifen:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">DOCUMENT</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  #<span class=\"hljs-variable language_\">document</span> = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-variable constant_\">DOCUMENT</span>);\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-variable language_\">this</span>.#<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">title</span>;\n  }\n}\n</code></pre><blockquote>\n<p><strong>Tipp:</strong> Für die Verwaltung von Seitentitel und Meta-Tags bietet Angular die Services <code>Title</code> und <code>Meta</code> an.</p>\n</blockquote>\n<h2 id=\"hydration\">Hydration</h2>\n<p>Wir haben bereits erwähnt, dass Angular die servergerenderte Seite im Client <em>hydriert</em>.\nHydration ist der Prozess, bei dem Angular die vom Server gerenderten DOM-Strukturen wiederverwendet, den Anwendungszustand überträgt und bereits abgerufene Daten übernimmt.</p>\n<p>Ohne aktivierte Hydration würde die Anwendung im Browser komplett neu gerendert. Das ist nicht nur aufwendig, sondern kann zu einem sichtbaren Flackern in der Oberfläche führen.\nAußerdem wirkt sich das Neurendern negativ auf Core Web Vitals wie Largest Contentful Paint (LCP) aus und verursacht ggf. Layout Shifts.\nHydration verbessert die Performance, indem Angular die bereits gerenderten DOM-Elemente mit der Anwendungsstruktur abgleicht und wiederverwendet, statt sie neu zu erzeugen.</p>\n<h3 id=\"hydration-aktivieren\">Hydration aktivieren</h3>\n<p>Wenn du die Angular CLI verwendet hast, um SSR zu aktivieren (entweder bei der Projekterstellung oder später über <code>ng add @angular/ssr</code>), ist der Code zur Aktivierung von Hydration bereits in deiner Anwendung enthalten.</p>\n<p>Bei einer manuellen Einrichtung kannst du Hydration aktivieren, indem du den passenden Provider in der Datei <code>main.ts</code> hinzufügst:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// main.ts</span>\n<span class=\"hljs-keyword\">import</span> { bootstrapApplication } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { provideClientHydration } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { App } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app/app&#x27;</span>;\n\nbootstrapApplication(App, {\n  providers: [\n    <span class=\"hljs-comment\">// ...</span>\n    provideClientHydration(),\n  ],\n});\n</code></pre><h3 id=\"hydration-überprüfen\">Hydration überprüfen</h3>\n<p>Um zu überprüfen, ob Hydration aktiviert ist, öffne die Entwicklertools im Browser und schau in die Konsole.\nDu solltest eine Meldung mit Hydration-bezogenen Statistiken sehen, z. B. die Anzahl der hydrierten Komponenten und Knoten.</p>\n<h3 id=\"event-replay\">Event Replay</h3>\n<p>Wenn eine Anwendung auf dem Server gerendert wird, ist sie im Browser sichtbar, sobald das erzeugte HTML geladen ist.\nBenutzer könnten annehmen, dass sie mit der Seite interagieren können, aber Event-Listener werden erst nach Abschluss der Hydration angehängt.</p>\n<p>Mit dem Event Replay-Feature können alle Events, die vor der Hydration auftreten, erfasst und nach Abschluss der Hydration wiedergegeben werden.\nDu kannst es mit der Funktion <code>withEventReplay()</code> aktivieren:</p>\n<pre><code class=\"language-typescript\">import { provideClientHydration, withEventReplay } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n\nbootstrapApplicatio<span class=\"hljs-meta\">n</span>(App, {\n  providers: [\n    provideClientHydratio<span class=\"hljs-meta\">n</span>(withEventReplay()),\n  ],\n});\n</code></pre><h3 id=\"hydration-für-einzelne-komponenten-überspringen\">Hydration für einzelne Komponenten überspringen</h3>\n<p>Einige Komponenten funktionieren möglicherweise nicht korrekt mit aktivierter Hydration, z. B. wenn sie direkte DOM-Manipulation verwenden.\nAls Workaround kannst du das Attribut <code>ngSkipHydration</code> zum Host-Element einer Komponente hinzufügen, um die Hydration für die gesamte Komponente zu überspringen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-section\">&lt;app-chart ngSkipHydration&gt;</span><span class=\"hljs-section\">&lt;/app-chart&gt;</span>\n</code></pre><p>Alternativ kannst du das Attribut als Host Binding setzen. Es wird dann aus der Komponente heraus auf ihr Host-Element angewendet.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  host: { ngSkipHydration: <span class=\"hljs-string\">&#x27;true&#x27;</span> },\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ChartViewer</span> </span>{ }\n</code></pre><blockquote>\n<p><strong>Hinweis:</strong> Das Attribut <code>ngSkipHydration</code> kann nur auf Komponenten-Host-Knoten verwendet werden.\nWenn du es zur Root-Komponente hinzufügst, wird die Hydration für die gesamte Anwendung deaktiviert.</p>\n</blockquote>\n<h3 id=\"einschränkungen-bei-der-hydration\">Einschränkungen bei der Hydration</h3>\n<p>Für die Hydration ist es wichtig, dass die Anwendung auf Server und Client die exakt gleiche DOM-Struktur erzeugt.\nDas betrifft auch Whitespaces und Kommentarknoten.</p>\n<p>Komponenten, die direkte DOM-Manipulation mit nativen DOM-APIs durchführen, sind die häufigste Ursache für Probleme.\nWenn du Komponenten hast, die den DOM mit nativen APIs manipulieren oder die nativen HTML-Propertys <code>innerHTML</code> bzw. <code>outerHTML</code> verwenden, wird der Hydration-Prozess auf Fehler stoßen.</p>\n<p>Verwende, wenn möglich, immer die Schnittstellen des Frameworks.\nFalls das bei komplexen Szenarien nicht möglich ist, verwende das Attribut <code>ngSkipHydration</code> als Workaround.</p>\n<h2 id=\"incremental-hydration\">Incremental Hydration</h2>\n<p>Incremental Hydration ist eine fortgeschrittene Form der Hydration.\nSie ermöglicht eine genaue Kontrolle darüber, wann die Hydration stattfindet.\nTeile der Anwendung können dehydriert bleiben und erst bei Bedarf hydriert werden.</p>\n<p>Wenn wir Incremental Hydration verwenden, werden die definierten Bereiche beim Build in eigene Bundles verpackt, die erst später geladen werden.\nDie initialen Bundles, die beim Start heruntergeladen werden müssen, sind also kleiner.\nDas verbessert die initialen Ladezeiten und reduziert First Input Delay (FID) und Cumulative Layout Shift (CLS).</p>\n<h3 id=\"incremental-hydration-aktivieren\">Incremental Hydration aktivieren</h3>\n<p>Du kannst Incremental Hydration für Anwendungen aktivieren, die bereits SSR mit Hydration verwenden:</p>\n<pre><code class=\"language-typescript\">import { provideClientHydration, withIncrementalHydration } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n\nbootstrapApplicatio<span class=\"hljs-meta\">n</span>(App, {\n  providers: [\n    provideClientHydratio<span class=\"hljs-meta\">n</span>(withIncrementalHydratio<span class=\"hljs-meta\">n</span>()),\n  ],\n});\n</code></pre><blockquote>\n<p><strong>Hinweis:</strong> Incremental Hydration aktiviert automatisch Event Replay.\nWenn du bereits <code>withEventReplay()</code> in der Liste der Providers hast, kannst du es nach der Aktivierung von Incremental Hydration entfernen.</p>\n</blockquote>\n<h3 id=\"defer-mit-hydration-triggern\"><code>@defer</code> mit Hydration-Triggern</h3>\n<p>Im Buch haben wir bereits <code>@defer</code> kennengelernt, um Teile der Anwendung verzögert zu laden.\nOhne Incremental Hydration hätte ein <code>@defer</code>-Block im sichtbaren Bereich dazu geführt, dass zuerst der Placeholder-Inhalt gerendert und dann durch den Hauptinhalt ersetzt wird – was einen Layout-Shift verursacht hätte.\nMit Incremental Hydration wird der Hauptinhalt des <code>@defer</code>-Blocks ohne Layout-Shift gerendert.</p>\n<p>Dafür kannst du zusätzliche Hydration-Trigger zu <code>@defer</code>-Blöcken hinzufügen, die definieren, wann die Hydration stattfinden soll.\nDie so markierten Inhalte bleiben zunächst dehydriert, bis der Hydration-Trigger auslöst.</p>\n<table>\n<thead>\n<tr>\n<th>Trigger</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>hydrate on idle</code></td>\n<td>Löst aus, wenn der Browser im Leerlauf ist.</td>\n</tr>\n<tr>\n<td><code>hydrate on viewport</code></td>\n<td>Löst aus, wenn der Inhalt in den sichtbaren Bereich scrollt.</td>\n</tr>\n<tr>\n<td><code>hydrate on interaction</code></td>\n<td>Löst aus, wenn der Benutzer mit dem Element interagiert (Klick, Tastatur).</td>\n</tr>\n<tr>\n<td><code>hydrate on hover</code></td>\n<td>Löst aus, wenn die Maus über den Bereich fährt.</td>\n</tr>\n<tr>\n<td><code>hydrate on immediate</code></td>\n<td>Löst sofort aus, nachdem der nicht-verzögerte Inhalt gerendert wurde.</td>\n</tr>\n<tr>\n<td><code>hydrate on timer(ms)</code></td>\n<td>Löst nach einer bestimmten Zeitspanne aus.</td>\n</tr>\n<tr>\n<td><code>hydrate when &lt;condition&gt;</code></td>\n<td>Löst aus, wenn eine benutzerdefinierte Bedingung wahr wird.</td>\n</tr>\n<tr>\n<td><code>hydrate never</code></td>\n<td>Der Inhalt bleibt dauerhaft dehydriert (statischer Inhalt).</td>\n</tr>\n</tbody></table>\n<h3 id=\"beispiele-für-hydration-trigger\">Beispiele für Hydration-Trigger</h3>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- hydriert, wenn der Browser im Leerlauf ist --&gt;</span>\n@defer (hydrate on idle) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-comments</span> /&gt;</span>\n} @placeholder {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Kommentare werden geladen …<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- hydriert, wenn der Inhalt in den sichtbaren Bereich scrollt --&gt;</span>\n@defer (hydrate on viewport) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-footer</span> /&gt;</span>\n} @placeholder {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Footer-Platzhalter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- hydriert bei Benutzerinteraktion --&gt;</span>\n@defer (hydrate on interaction) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-interactive-chart</span> /&gt;</span>\n} @placeholder {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Diagramm-Platzhalter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- hydriert nach 2 Sekunden --&gt;</span>\n@defer (hydrate on timer(2000ms)) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-delayed-content</span> /&gt;</span>\n} @placeholder {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Inhalt wird geladen …<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- hydriert basierend auf einer Bedingung --&gt;</span>\n@defer (hydrate when isLoggedIn) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-user-dashboard</span> /&gt;</span>\n} @placeholder {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Dashboard-Platzhalter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n}\n\n<span class=\"hljs-comment\">&lt;!-- bleibt dauerhaft dehydriert (statischer Inhalt) --&gt;</span>\n@defer (on viewport; hydrate never) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-static-footer</span> /&gt;</span>\n} @placeholder {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Footer-Platzhalter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n}\n</code></pre><h3 id=\"hydration-trigger-mit-regulären-triggern-kombinieren\">Hydration-Trigger mit regulären Triggern kombinieren</h3>\n<p>Hydration-Trigger können zusammen mit regulären <code>@defer</code>-Triggern verwendet werden.\nHydration wird einmalig beim Start der Anwendung ausgeführt, daher gelten Hydration-Trigger nur für diesen initialen Ladevorgang.\nBeim nachfolgenden clientseitigen Rendering (z. B. beim Seitenwechsel mit Routing) wird der reguläre Trigger verwendet:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-meta\">@defer</span> (on idle; hydrate on interaction) {\n  <span class=\"hljs-variable\">&lt;app-comments /&gt;</span>\n} <span class=\"hljs-meta\">@placeholder</span> {\n  <span class=\"hljs-variable\">&lt;div&gt;</span>Kommentare werden geladen …<span class=\"hljs-variable\">&lt;/div&gt;</span>\n}\n</code></pre><p><code>@defer</code> muss immer einen <code>@placeholder</code> besitzen.\nDer Inhalt wird zwar nicht für Incremental Hydration verwendet, ist aber für das nachfolgende clientseitige Rendering notwendig.\nWechseln wir nach dem Start der Anwendung auf eine Unterseite der Anwendung, findet keine erneute Hydration statt.\nDie Komponente wird rein lokal im Browser geladen, und die Inhalte des <code>@defer</code>-Blocks werden regulär gerendert.\nIn diesen Fällen wird der <code>@placeholder</code> angezeigt.</p>\n<h2 id=\"wann-setze-ich-serverseitiges-rendering-ein\">Wann setze ich serverseitiges Rendering ein?</h2>\n<p>Server-Side Rendering und Pre-Rendering sind wirkungsvolle Mittel, um die wahrgenommene Ladezeit einer Anwendung zu verkürzen.\nAußerdem wird die initiale HTML-Seite nicht leer ausgeliefert, sondern enthält bereits Informationen, die für Suchmaschinen und automatische Inhaltsvorschau sinnvoll sind.\nObwohl beide Strategien mit moderatem Aufwand umsetzbar sind, sollte immer untersucht werden, ob sich der Einsatz von serverseitigem Rendering für eine bestimmte Anwendung lohnt.\nDazu solltest du stets folgende Fragen beantworten:</p>\n<ul>\n<li>Wird die Anwendung über einen externen Link aufgerufen?</li>\n<li>Besuchen Suchmaschinen, Crawler oder AI-Agenten die Seite?</li>\n<li>Ist die wahrgenommene Start-Performance der Anwendung ein wichtiges Kriterium für die User Experience?</li>\n</ul>\n<p><strong>Öffentliche Anwendungen:</strong> Sinnvoll ist der Einsatz von Server-Side Rendering bei öffentlichen Portalen, deren Angebot über Links erreichbar ist und von Suchmaschinen indexiert wird.\nWenn wir die Seite mit einer potenziell langsamen Internetverbindung nutzen, kann die vorgerenderte HTML-Seite die gefühlte Performance verbessern.\nSolche Anwendungen können z. B. ein Online-Shop, Blog oder eine öffentliche Firmenwebsite sein.</p>\n<p><strong>Firmeninterne Anwendungen:</strong> Für ausschließlich interne Anwendungen ist es meist nicht notwendig, das Rendering auf dem Server vorzunehmen.\nDie Seite wird nicht von öffentlichen Suchmaschinen indexiert und wird hauptsächlich auf Desktop-Rechnern genutzt oder sogar lokal ausgeliefert.\nBeispiele sind Intranetportale, Verwaltungssoftware und Desktopanwendungen.\nAuch bei hochdynamischen Inhalten, die sich erst aus der Interaktion in der Oberfläche ergeben (z. B. ein Chat), kann es sein, dass Server-Side Rendering nicht zielführend ist.\nEbenso musst du nur die Seiten vorrendern, die von extern über einen Link aufgerufen werden können.\nInterne Bereiche wie die individuelle Bestellverwaltung in einem Online-Shop müssen also nicht servergerendert werden.</p>\n<p><strong>Statische Inhalte:</strong> Pre-Rendering bietet sich immer dann an, wenn die Anwendung statische Inhalte besitzt, die keinen zeitlichen Bezug haben und sich nur aus dem Code der Anwendung ergeben.\nDabei musst du dich nicht für eine Strategie entscheiden, sondern du kannst dynamisches Server-Side Rendering und statisches Pre-Rendering parallel nutzen.\nBeispielsweise kannst du die Startseite mit dynamischen Inhalten mittels Server-Side Rendering ausliefern, während das Impressum, das Kontaktformular und die Firmenhistorie auf der Website durch Pre-Rendering erzeugt werden.\nDa für das Pre-Rendering immer die Pfade aller zu rendernden Routen bekannt sein müssen, eignet sich dieses Verfahren ohnehin nur für statische Seiten.\nGeschützte Bereiche wie eine Nutzerverwaltung hingegen solltest du gar nicht vorrendern.</p>\n","meta":{"title":"Server-Side Rendering (SSR) mit Angular","published":"2026-02-23T00:00:00.000Z","lastModified":"2026-02-23T00:00:00.000Z"}}
