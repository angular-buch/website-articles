{"slug":"interceptors","html":"<blockquote>\n<p><strong>Hinweis:</strong> Dieser Artikel ist ein Zusatzmaterial zum <a href=\"https://angular-buch.com\">Angular-Buch</a>.\nIm Buch behandeln wir den <strong><code>HttpClient</code></strong> von Angular sowie die <strong>Resource API</strong> mit der <strong><code>httpResource()</code></strong>.\nInterceptors fungieren als übergreifende Middleware und sie erlauben es HTTP Calls zentral sowohl vor dem Aufruf als auch beim Empfang der Antwort zu modifizieren.</p>\n</blockquote>\n<hr>\n<p>Der <code>HttpClient</code> bietet ein weiteres nützliches Feature für die Arbeit mit Serverschnittstellen: <em>Interceptors</em>.\nInterceptors fungieren als Middleware für die gesamte HTTP-Kommunikation.\nDas bedeutet, dass ein Interceptor für alle HTTP-Abfragen und -Antworten ausgeführt wird und damit an globaler Stelle Entscheidungen und Umwandlungen vornehmen kann.\nMithilfe von Interceptors kannst du zum Beispiel zusätzliche HTTP-Header setzen, Fehler abfangen oder Funktionen ausführen, ohne sie für jeden HTTP-Aufruf separat implementieren zu müssen.</p>\n<p>Ein Interceptor wird global installiert und kann für jeden HTTP-Request und die Response entscheiden, ob und wie sie behandelt werden.\nDiese Behandlung kann unter anderem sein:</p>\n<ul>\n<li>Sicherheitsfunktionen, z. B. Authentifizierung über ein Access Token, das mit jedem Request im Header übermittelt werden muss</li>\n<li>Hinzufügen zusätzlicher Headerfelder, z. B. für Caching</li>\n<li>Logging von Request und Response</li>\n<li>Anzeige von Zustandsinformationen zum Request (z. B., ob eine HTTP-Anfrage noch aktiv ist oder nicht)</li>\n<li>globales Abfangen und Behandeln von Fehlern bei einer HTTP-Anfrage, z. B. mit <code>catchError()</code></li>\n</ul>\n<h2 id=\"funktionsweise-der-interceptors\">Funktionsweise der Interceptors</h2>\n<p>Bindest du einen Interceptor in die Anwendung ein, so wird er bei jedem HTTP-Request aktiv:\nDer Request läuft zunächst durch den Interceptor und kann dort verändert werden.\nAnschließend wird der Request über das Netzwerk zum Server übermittelt.\nDie Antwort vom Server wird ebenfalls im Interceptor verarbeitet, bevor sie beim Aufrufenden eintrifft.</p>\n<p>In einer Anwendung können mehrere Interceptors registriert werden.\nSie werden als Array hinterlegt, also mit einer definierten Reihenfolge.\nBei einem HTTP-Request werden die Interceptors von vorn nach hinten abgearbeitet, bei der HTTP-Response umgekehrt – von hinten nach vorn.</p>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/material/interceptors/interceptor-flow.svg\" alt=\"Abarbeitung von Interceptors\"></p>\n<h2 id=\"interceptors-anlegen\">Interceptors anlegen</h2>\n<p>Interceptors werden in der Regel als einfache Funktion implementiert.\nAngular stellt dafür den Typ <code>HttpInterceptorFn</code> bereit.\nDu erhältst den Request und eine Funktion vom Typ <code>HttpHandlerFn</code>, an die du den veränderten Request übergibst.\nWenn du Services anfordern möchtest, kannst du die Funktion <code>inject()</code> nutzen, da der Interceptor stets in einem Injection Context ausgeführt wird.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpInterceptorFn</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">myInterceptor</span>: <span class=\"hljs-title class_\">HttpInterceptorFn</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">req, next</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// Request verarbeiten oder verändern</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">next</span>(req);\n};\n</code></pre><p>Um funktionale Interceptors zu registrieren, verwenden wir die Funktion <code>provideHttpClient()</code> zusammen mit <code>withInterceptors()</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { provideHttpClient, withInterceptors } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { myInterceptor } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./my-interceptor&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideHttpClient</span>(\n      <span class=\"hljs-title function_\">withInterceptors</span>([myInterceptor])\n    )\n  ]\n};\n</code></pre><h2 id=\"den-request-manipulieren\">Den Request manipulieren</h2>\n<p>Die Interceptor-Funktion wird für jeden ausgehenden HTTP-Request ausgeführt.\nBevor du den Request auf die Reise schickst, kannst du den Inhalt manipulieren.\nZum Beispiel kannst du einen Interceptor entwickeln, der bestimmte Headerfelder in jeden Request einfügt.</p>\n<p>Dafür musst du den originalen Request zunächst klonen.\nDieser Schritt ist wichtig, denn das Request-Objekt ist unveränderlich: Du kannst es nicht direkt manipulieren, sondern musst immer eine Kopie mit den Änderungen erzeugen.\nVerwende dazu die Methode <code>clone()</code> und übergib direkt die gewünschten Änderungen:\nMit der Eigenschaft <code>setHeaders</code> kannst du neue HTTP-Headerfelder hinzufügen.\nZum Schluss rufst du <code>next()</code> auf und übermittelst den neuen, veränderten Request an den nächsten HTTP-Handler.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { HttpInterceptorFn } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> const <span class=\"hljs-name\">authInterceptor</span>: HttpInterceptorFn = <span class=\"hljs-function\"><span class=\"hljs-params\">(req, <span class=\"hljs-built_in\">next</span>)</span> =&gt;</span> {\n  const modifiedReq = req.clone({\n    <span class=\"hljs-name\">setHeaders</span>: {\n      <span class=\"hljs-string\">&#x27;Authorization&#x27;</span>: <span class=\"hljs-string\">&#x27;Bearer my-token&#x27;</span>,\n      <span class=\"hljs-string\">&#x27;X-Custom-Header&#x27;</span>: <span class=\"hljs-string\">&#x27;my-value&#x27;</span>\n    }\n  });\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">next</span>(modifiedReq);\n};\n</code></pre><h2 id=\"die-response-verarbeiten\">Die Response verarbeiten</h2>\n<p>Jeder Interceptor gibt ein Observable zurück: Es verarbeitet den Request und gibt die HTTP-Antworten aus, die vom Server eintreffen.\nDu kannst dieses Observable nutzen, um mit den eintreffenden Daten zu arbeiten.\nZum Beispiel kannst du auf diese Weise Fehler abfangen, die Antworten loggen oder sogar den Inhalt manipulieren.</p>\n<p>Um alle eingehenden Responses zu loggen, kannst du den Operator <code>tap()</code> verwenden.\nEr lässt den Inhalt des Observables unverändert, und du kannst sowohl die erfolgreiche Serverantwort als auch fehlgeschlagene Requests auf der Konsole ausgeben.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { HttpInterceptorFn, HttpResponse } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { tap } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> const <span class=\"hljs-name\">loggingInterceptor</span>: HttpInterceptorFn = <span class=\"hljs-function\"><span class=\"hljs-params\">(req, <span class=\"hljs-built_in\">next</span>)</span> =&gt;</span> {\n  console.log(<span class=\"hljs-string\">&#x27;Request URL:&#x27;</span>, req.url);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">next</span>(req).pipe(\n    tap({\n      <span class=\"hljs-name\">next</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">(event)</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">if</span> (event instanceof HttpResponse) {\n          console.log(<span class=\"hljs-string\">&#x27;Response Status:&#x27;</span>, event.status);\n        }\n      },\n      <span class=\"hljs-name\">error</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">(<span class=\"hljs-built_in\">error</span>)</span> =&gt;</span> {\n        console.<span class=\"hljs-built_in\">error</span>(<span class=\"hljs-string\">&#x27;Request failed:&#x27;</span>, <span class=\"hljs-built_in\">error</span>);\n      }\n    })\n  );\n};\n</code></pre><blockquote>\n<p><strong>Wichtig:</strong> Das HTTP-Observable muss completen!\nDie HTTP-Kommunikation über die Interceptors wird mithilfe von Observables realisiert.\nEs ist wichtig, dass das Observable, das du aus dem Interceptor zurückgibst, immer completet wird.\nIst der Datenstrom nie zu Ende, so wird auch der ursprüngliche Aufruf des <code>HttpClient</code> niemals beendet.</p>\n</blockquote>\n<h2 id=\"interceptors-einbinden\">Interceptors einbinden</h2>\n<p>Interceptors werden über die Dependency Injection von Angular als Providers bereitgestellt.\nDamit der <code>HttpClient</code> weiß, welche Interceptors ausgeführt werden sollen, nutzt du die Funktion <code>provideHttpClient()</code> zusammen mit <code>withInterceptors()</code>.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.config.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ApplicationConfig</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { provideHttpClient, withInterceptors } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { authInterceptor } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./auth.interceptor&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { loggingInterceptor } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logging.interceptor&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideHttpClient</span>(\n      <span class=\"hljs-title function_\">withInterceptors</span>([\n        authInterceptor,\n        loggingInterceptor\n      ])\n    )\n  ]\n};\n</code></pre><p>Die Reihenfolge der Interceptors im Array bestimmt die Ausführungsreihenfolge:\nBei einem Request werden sie von vorn nach hinten abgearbeitet, bei der Response umgekehrt.</p>\n<h2 id=\"interceptors-mit-httpresource\">Interceptors mit httpResource</h2>\n<p>Die Funktion <code>httpResource()</code> nutzt intern den <code>HttpClient</code>, um HTTP-Requests durchzuführen.\nDas bedeutet, dass alle konfigurierten Interceptors automatisch auch für <code>httpResource()</code> angewendet werden.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { httpResource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n\n<span class=\"hljs-regexp\">//</span> Dieser Request durchläuft alle registrierten Interceptors\nconst booksResource = httpResource&lt;Book[]&gt;(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">&#x27;/api/books&#x27;</span>);\n</code></pre><p>Wenn du also einen Auth-Interceptor konfiguriert hast, der ein Bearer-Token hinzufügt, wird dieses Token auch bei allen Requests über <code>httpResource()</code> automatisch mitgesendet.\nDas gleiche gilt für Logging-Interceptors, Error-Handler und alle anderen Interceptors.</p>\n<h2 id=\"oauth-2-und-openid-connect\">OAuth 2 und OpenID Connect</h2>\n<p>Egal ob du eine unternehmensinterne oder eine öffentliche Webanwendung entwickelst, die im Internet erreichbar ist:\nIn vielen Fällen benötigt die Anwendung einen Login, um Authentifizierung und Autorisierung zu realisieren.</p>\n<p>In der Regel wird dieser Vorgang durch den Austausch von Authentifizierungstokens realisiert.\nNach dem Login senden wir mit jedem Request an die Web-API ein Access Token, das die Berechtigung der nutzenden Person bestätigt.\nDies ist ein klassischer Anwendungsfall für einen Interceptor, denn er ermöglicht es, das Token automatisch mit jedem Request einzufügen.</p>\n<p>Wir möchten dir an dieser Stelle dazu raten, eine Authentifizierungslösung nie selbst zu entwickeln.\nDas Risiko, dabei einen Fehler zu machen, ist sehr hoch, und selbst wenn du Erfahrung in diesem Bereich hast, solltest du das Rad nicht neu erfinden.\nSpezialisierte Anbieter bieten hier Lösungen, die seit Jahren etabliert sind und stets an die neuesten Sicherheitsanforderungen angepasst werden.\nGreife deshalb bitte immer auf etablierte Lösungen und Identity Provider zurück.</p>\n<p>Weit verbreitete Industriestandards zur Autorisierung sind <em>OAuth 2</em> und das darauf aufsetzende Authentifizierungsframework <em>OpenID Connect (OIDC)</em>.</p>\n<ul>\n<li><strong>OAuth 2</strong> ist ein Standard zur Autorisierung von API-Zugriffen im Web.</li>\n<li><strong>OpenID Connect (OIDC)</strong> ist eine Erweiterung von OAuth 2, die alle notwendigen Funktionen für Login und Single Sign-On (SSO) etabliert.</li>\n</ul>\n<p>Die Datenflüsse in einer Anwendung mit OAuth 2 und OIDC können in verschiedenen <em>Flows</em> realisiert werden.</p>\n<h3 id=\"authorization-code-flow\">Authorization Code Flow</h3>\n<p>Mit der Verbreitung von OAuth 2 und OIDC wurde kontinuierlich an noch sichereren Möglichkeiten der Authentifizierung gearbeitet.\nEin Ergebnis dieser Arbeit ist der nun empfohlene <em>Authorization Code Flow</em>.</p>\n<p>Der Flow verwendet die Erweiterung <em>PKCE (Proof Key for Code Exchange)</em>, die sicherstellt, dass beim Austausch des Access Tokens keine sensiblen Informationen bei potenziellen Angriffen abgefangen werden können.\nDafür sendet der Client mit der Umleitung zum Authorization Server einen Hashwert mit.\nDer Client generiert zunächst einen Zufallsstring (den sogenannten <em>Verifier</em>) und leitet daraus eine <em>Code Challenge</em> ab.\nDiese Challenge wird dann im Request übertragen.</p>\n<p>Nach dem erfolgreichen Login empfängt der Client lediglich einen <em>Authorization Code</em> vom Authorization Server.\nDieser Code ist noch kein gültiges Token, sondern muss zunächst „eingetauscht&quot; werden:\nDafür sendet der Client den Authorization Code zusammen mit dem Verifier in einem asynchronen HTTP-Request (AJAX) an den Authorization Server.\nDieser kann jetzt prüfen, ob der Verifier zum zuvor ausgestellten Authorization Code passt.\nIst die Prüfung erfolgreich, stellt der Authorization Server schließlich an den Client das Access Token und das Identity Token aus.\nDamit kann der Client nun den Resource Server abfragen, der wiederum prüft, ob das Access Token valide ist.</p>\n<p>Durch den zusätzlichen Schritt und den flüchtigen Authorization Code kann sichergestellt werden, dass das Token während des Datenaustauschs nicht gestohlen werden kann, denn nur der Client kennt den verwendeten Verifier.</p>\n<h3 id=\"openid-connect-und-angular\">OpenID Connect und Angular</h3>\n<p>Um den empfohlenen Authorization Code Flow fehlerfrei zu implementieren, ist es notwendig, die Spezifikationen sehr genau zu studieren.\nDamit das Fehlerrisiko gering bleibt, solltest du eine etablierte Bibliothek verwenden, um die Datenflüsse für die Autorisierung und Authentifizierung korrekt abzubilden.\nFür Angular möchten wir die beiden folgenden Bibliotheken empfehlen:</p>\n<ul>\n<li><a href=\"https://github.com/damienbod/angular-auth-oidc-client\">angular-auth-oidc-client</a></li>\n<li><a href=\"https://github.com/manfredsteyer/angular-oauth2-oidc\">angular-oauth2-oidc</a></li>\n</ul>\n<p>Beide sind von der OpenID Foundation zertifiziert und bieten komfortable Schnittstellen, um die Flows von OAuth 2 und OIDC in eine Angular-Anwendung zu integrieren.</p>\n<h2 id=\"praxisbeispiel-api-aufrufe-mit-credentials-anreichern\">Praxisbeispiel: API-Aufrufe mit Credentials anreichern</h2>\n<p>Um sicherzustellen, dass die nutzende Person berechtigt ist, Daten von der API zu lesen und später auch zu bearbeiten, soll eine Authentifizierung mit jedem Request erfolgen.\nWir wollen einen Interceptor implementieren, der ein Token an die Web-API übermittelt.</p>\n<p>Die Authentifizierungsverfahren können dabei ganz unterschiedlich ausfallen, unter anderem:</p>\n<ul>\n<li>native HTTP-Authentifizierung (Basic/Digest)</li>\n<li>Verwendung von Cookies</li>\n<li>Token-basierte Authentifizierung (z. B. Bearer-Token mit JWT)</li>\n<li>OAuth 2/OpenID Connect (verwendet ebenso ein Bearer-Token)</li>\n</ul>\n<p>Eines haben aber alle Methoden gemeinsam: Sie erfordern, dass spezielle Informationen in jedem HTTP-Request mitgeliefert werden, um sich gegenüber dem Backend auszuweisen.</p>\n<h3 id=\"service-zur-authentifizierung\">Service zur Authentifizierung</h3>\n<p>Um mit jedem Request über einen Interceptor entsprechende Informationen mitzusenden, benötigen wir zunächst eine zentrale Stelle in der Anwendung, die die Authentifizierung vollzieht und Informationen über den aktuellen Status ausgibt.</p>\n<p>Hierfür wollen wir einen eigenen Service implementieren.\nDieser Ansatz ist vergleichbar mit etablierten Bibliotheken.\nSie stellen hierfür unter anderem folgende oder ähnliche Funktionen zur Verfügung:</p>\n<ul>\n<li><code>isAuthenticated$</code>: ein Observable, das den aktuellen Status der Authentifizierung reaktiv ausgibt</li>\n<li><code>isAuthenticated</code>: Boolean, das den Authentifizierungsstatus synchron bereitstellt</li>\n<li><code>login()</code>: Methode zum Einloggen</li>\n<li><code>logout()</code>: Methode zum Ausloggen</li>\n</ul>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// auth.service.ts</span>\n<span class=\"hljs-keyword\">import</span> { Injectable, signal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Injectable({ providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span> })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AuthService</span> {\n  <span class=\"hljs-keyword\">private</span> _isAuthenticated = signal(<span class=\"hljs-literal\">true</span>);\n\n  readonly isAuthenticated = <span class=\"hljs-keyword\">this</span>._isAuthenticated.asReadonly();\n\n  login() {\n    <span class=\"hljs-keyword\">this</span>._isAuthenticated.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-literal\">true</span>);\n  }\n\n  logout() {\n    <span class=\"hljs-keyword\">this</span>._isAuthenticated.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-literal\">false</span>);\n  }\n}\n</code></pre><h3 id=\"den-auth-interceptor-implementieren\">Den Auth-Interceptor implementieren</h3>\n<p>Um in jede API-Anfrage einen Token zur Authentifizierung einzubauen, wollen wir einen Interceptor nutzen.\nDas hat den Vorteil, dass wir nicht bei jedem einzelnen HTTP-Request einen entsprechenden Header mit dem Token setzen müssen.\nSobald der Interceptor aktiv ist, wird er auf alle HTTP-Requests angewendet.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// auth.interceptor.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpInterceptorFn</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AuthService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./auth.service&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">authInterceptor</span>: <span class=\"hljs-title class_\">HttpInterceptorFn</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">req, next</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> authService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">AuthService</span>);\n\n  <span class=\"hljs-keyword\">if</span> (authService.<span class=\"hljs-title function_\">isAuthenticated</span>()) {\n    <span class=\"hljs-keyword\">const</span> modifiedReq = req.<span class=\"hljs-title function_\">clone</span>({\n      <span class=\"hljs-attr\">setHeaders</span>: {\n        <span class=\"hljs-string\">&#x27;Authorization&#x27;</span>: <span class=\"hljs-string\">&#x27;Bearer 1234567890&#x27;</span>\n      }\n    });\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">next</span>(modifiedReq);\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">next</span>(req);\n};\n</code></pre><p>Zur Authentifizierung am Server wollen wir ein Bearer-Token einsetzen.\nEin solches Token muss üblicherweise zuvor von einem Authentifizierungsserver ausgestellt werden.\nDie konkrete Implementierung hängt stark vom Projekt und von den zu nutzenden Endpunkten ab.\nUns geht es an dieser Stelle vor allem darum, zu zeigen, wie ein solches Token in den Request eingebaut werden kann.\nWir nutzen deshalb den statischen String <code>1234567890</code>, den wir als Bearer-Token senden.\nDas bedeutet, dass das Token im Headerfeld <code>Authorization</code> mit dem Präfix <code>Bearer</code> übermittelt werden muss.</p>\n<p>An dieser Stelle treffen wir eine Fallunterscheidung:\nLiefert der <code>AuthService</code> im Property <code>isAuthenticated</code> den Wert <code>true</code>, wollen wir ein zusätzliches Headerfeld im Request setzen.\nWir verwenden die Methode <code>clone()</code> und setzen den Header <code>Authorization</code>.\nDanach übergeben wir den Request an den Handler, damit er zum nächsten Interceptor bzw. zum Server gesendet wird.\nFalls <code>isAuthenticated</code> den Wert <code>false</code> besitzt, reichen wir den originalen Request unverändert weiter.\nDas Token wird also im Header übermittelt, falls eine Authentifizierung vorliegt.</p>\n<h3 id=\"den-interceptor-registrieren\">Den Interceptor registrieren</h3>\n<p>Bevor der Auth-Interceptor genutzt werden kann, muss er noch registriert werden:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// app.config.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ApplicationConfig</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { provideHttpClient, withInterceptors } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { authInterceptor } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./shared/auth.interceptor&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideHttpClient</span>(\n      <span class=\"hljs-title function_\">withInterceptors</span>([authInterceptor])\n    )\n  ]\n};\n</code></pre><h2 id=\"was-haben-wir-gelernt\">Was haben wir gelernt?</h2>\n<ul>\n<li>Interceptors modifizieren HTTP-Anfragen auf globaler Ebene und requestübergreifend.</li>\n<li>Mit Interceptors lassen sich auch die Antworten vom Server verarbeiten, bevor sie im Service eintreffen.</li>\n<li>Ein funktionaler Interceptor ist eine Funktion vom Typ <code>HttpInterceptorFn</code>, die den Request und eine Handler-Funktion erhält.</li>\n<li>Interceptors werden mit <code>provideHttpClient(withInterceptors([...]))</code> registriert.</li>\n<li>Mehrere Interceptors werden beim Request nach dem Muster A → B → C abgearbeitet. Bei der Serverantwort werden die Observables in umgekehrter Reihenfolge durchlaufen (C → B → A).</li>\n<li>Interceptors sollten nur genutzt werden, wenn du für <em>alle</em> Requests bestimmte Aktionen durchführen willst. Verwende Interceptors nicht, wenn du für einen <em>einzelnen</em> Request spezielle Header oder andere Optionen setzen möchtest.</li>\n<li><code>httpResource()</code> nutzt intern den <code>HttpClient</code>, daher werden alle konfigurierten Interceptors automatisch auch für <code>httpResource()</code> angewendet.</li>\n</ul>\n","meta":{"title":"Interceptors: HTTP-Requests abfangen und transformieren","published":"2026-02-10T00:00:00.000Z","lastModified":"2026-02-05T00:00:00.000Z","hidden":true}}
