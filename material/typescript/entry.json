{"slug":"typescript","html":"<blockquote>\n<p><strong>Hinweis:</strong> Dieser Artikel ist ein Zusatzmaterial zum <a href=\"https://angular-buch.com\">Angular-Buch</a>.\nIm Buch setzen wir durchgehend auf <strong>TypeScript</strong> für die Entwicklung mit Angular.\nDieses Kapitel bietet eine Einführung in die wichtigsten Sprachfeatures.</p>\n<p>Wenn du bereits Erfahrung mit TypeScript hast, kannst du dieses Kapitel überspringen.\nViele Konzepte werden wir auch im Verlauf des Buchs praktisch kennenlernen.</p>\n</blockquote>\n<hr>\n<p>Für die Entwicklung mit Angular verwenden wir die Programmiersprache <em>TypeScript</em>.\nFür Entwickler:innen, die bisher noch nicht mit TypeScript entwickelt haben, wollen wir hier einen kurzen Einstieg geben.\nKeine Angst – du musst keine vollständig neue Sprache erlernen, um mit Angular arbeiten zu können, denn TypeScript ist eine Obermenge von JavaScript.</p>\n<p>TypeScript greift die aktuellen ECMAScript-Standards auf und integriert zusätzliche Features, unter anderem ein statisches Typsystem.\nDas bedeutet praktisch, dass die Typen von Variablen, Funktionsparametern und Klassen-Propertys direkt im Code aufgeschrieben werden.\nSo erhalten wir schon während der Entwicklung eine gute Unterstützung im Editor und können unsere Software typsicher entwickeln.\nAutovervollständigung, Typprüfungen und Rename Refactoring sind nur einige der Vorteile, die sich aus einem statischen Typsystem ergeben.</p>\n<p>Jedes Programm, das in JavaScript geschrieben wurde, funktioniert auch in TypeScript.\nDein bestehendes Wissen zu JavaScript bleibt also weiterhin anwendbar.</p>\n<h2 id=\"typescript-einsetzen\">TypeScript einsetzen</h2>\n<p>TypeScript ist nicht direkt im Browser lauffähig.\nDeshalb wird der TypeScript-Code vor der Auslieferung wieder in JavaScript umgewandelt.\nFür diesen Prozess ist der TypeScript-Compiler verantwortlich.\nMan spricht dabei auch von <em>Transpilierung</em>, weil der Code lediglich in eine andere Sprache übertragen wird.</p>\n<p>Die statische Typisierung geht bei diesem Schritt verloren.\nDas bedeutet, dass das Programm zur Laufzeit keine Typen mehr besitzt, denn es ist ein reines JavaScript-Programm.\nDurch die Typunterstützung bei der Entwicklung und beim Build können allerdings schon die meisten Fehler erkannt und vermieden werden.</p>\n<p>TypeScript ist als Open-Source-Projekt bei der Firma Microsoft entstanden.\nDurch die Typisierung können Fehler bereits zur Entwicklungszeit erkannt werden.\nAußerdem können Tools den Code genauer analysieren.\nDies ermöglicht Komfortfunktionen wie automatische Vervollständigung, Navigation zwischen Methoden und Klassen, eine solide Refactoring-Unterstützung und automatische Dokumentation in der Entwicklungsumgebung.</p>\n<p>Die meisten modernen IDEs wie Visual Studio Code oder IntelliJ/WebStorm unterstützen TypeScript nativ und ohne zusätzliche Plug-ins.\nIn einem Angular-Projekt ist der TypeScript-Compiler außerdem schon vollständig konfiguriert, sodass wir sofort mit der Entwicklung beginnen können.</p>\n<!-- TODO: klären, ob wir das drin haben wollen -->\n<!-- Danny: nein, ist mittlerweile Basiswissen und hat erst einmal auch nichts direkt mit TS zu tun -->\n<!--\n## Variablen: `const`, `let` und `var`\n\nUrsprünglich wurden Variablen in JavaScript mit dem Schlüsselwort `var` eingeleitet.\nDas funktioniert noch immer, allerdings kamen mit ECMAScript 2015 die neuen Variablenarten `let` und `const` hinzu.\n\n### Die schmerzhafte `var`-heit\n\nMit dem Schlüsselwort `var` eingeleitete Variablen sind jeweils in der Funktion gültig, in der sie auch deklariert wurden – und zwar überall.\nVariablen mit `var` „fressen\" sich durch alle Blöcke hindurch und sind in der *gesamten* Funktion und in allen darin verschachtelten Blöcken und Funktionen verfügbar.\n\n```typescript\nfunction example() {\n  if (true) {\n    var x = 10;\n  }\n  console.log(x); // 10 – x ist hier verfügbar!\n}\n```\n\nDiese Eigenschaft führt in der Praxis schnell zu Kollisionen von Variablen aus verschiedenen Programmteilen.\n\n### Blockgebundene Variablen mit `let`\n\nMit Einführung von ECMAScript 2015 hielt der Variablentyp `let` Einzug in die Webentwicklung.\nDamit lassen sich blockgebundene Variablen definieren.\nSie sind nicht in der gesamten Funktion gültig, sondern lediglich innerhalb des Blocks, in dem sie definiert wurden.\n\n```typescript\nfor (let i = 0; i < 10; i++) {\n  // i ist nur hier gültig\n}\n// console.log(i); // Fehler: i ist nicht definiert\n```\n\n### Konstanten mit `const`\n\nVariablen, die mit `var` oder `let` eingeleitet werden, lassen sich jederzeit überschreiben.\nHäufig ändert sich der Wert einer Variable allerdings nach der Initialisierung nicht mehr.\nFür solche Fälle gibt es Konstanten.\nSie werden mit dem Schlüsselwort `const` eingeleitet.\nWird eine Konstante einmal festgelegt, so lässt sich der Wert nicht mehr überschreiben.\n\n```typescript\nconst name = 'Angular';\n// name = 'React'; // Fehler: Zuweisung nicht möglich\n```\n\nVorsicht ist allerdings geboten bei Variablen, die ein Objekt oder Array enthalten.\nObjekte und Arrays werden in JavaScript nur anhand ihrer Speicherreferenz identifiziert.\nDas bedeutet, dass eine `const`-Variable nur die Referenz auf das Objekt konstant speichert, wir den Inhalt aber trotzdem verändern können:\n\n```typescript\nconst book = { title: 'Angular' };\nbook.title = 'Angular Buch'; // Das funktioniert!\n// book = { title: 'Neues Buch' }; // Fehler: Zuweisung nicht möglich\n```\n\n### Wann nutze ich welche?\n\nAls Faustregel kannst du dir Folgendes merken:\n\n- Nutze zunächst immer `const`.\n- Willst du den Wert später im Programm verändern, wähle `let`.\n- Nutze nicht `var`, denn du wirst es nicht benötigen.\n-->\n\n<h2 id=\"die-wichtigsten-basistypen\">Die wichtigsten Basistypen</h2>\n<p>Die starke Typisierung ermöglicht es, die Schnittstellen der Software genau zu beschreiben.\nSo können schon während der Entwicklung hilfreiche Informationen und Warnungen bereitgestellt werden, wenn die API nicht korrekt verwendet wird.</p>\n<h3 id=\"primitive-typen-zahlen-zeichenketten-und-boolesche-werte\">Primitive Typen: Zahlen, Zeichenketten und boolesche Werte</h3>\n<p>Die wichtigsten primitiven Typen in TypeScript sind <code>number</code>, <code>string</code> und <code>boolean</code>.\nDer Typ <code>number</code> legt den Wert einer Variable auf eine Ganz- oder Kommazahl fest.\nZeichenketten werden mithilfe des Datentyps <code>string</code> definiert.\nWenn eine Variable logische Wahrheitswerte (<code>true</code> oder <code>false</code>) annehmen soll, verwenden wir den Typ <code>boolean</code>.</p>\n<p>Ein Typ wird immer mit einem Doppelpunkt hinter dem Variablennamen deklariert.\nWenn der Typ bereits aus dem Wert eindeutig bestimmbar ist, müssen wir diese Information nicht zwingend notieren.\nTypeScript ermittelt den passenden Typ automatisch – man spricht von <em>Typinferenz</em>.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-number\">30</span>;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&#x27;Angular&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">isActive</span>: <span class=\"hljs-built_in\">boolean</span> = <span class=\"hljs-literal\">true</span>;\n\n<span class=\"hljs-comment\">// Typinferenz: Typ wird automatisch erkannt</span>\n<span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// number</span>\n<span class=\"hljs-keyword\">let</span> title = <span class=\"hljs-string\">&#x27;Buch&#x27;</span>; <span class=\"hljs-comment\">// string</span>\n</code></pre><h3 id=\"typisierte-arrays\">Typisierte Arrays</h3>\n<p>In JavaScript ist es möglich, ein Array mit verschiedenen Typen zu befüllen.\nMit TypeScript können Arrays typisiert werden, sodass nur Elemente eines festgelegten Typs zulässig sind.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">numbers</span>: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">names</span>: <span class=\"hljs-built_in\">string</span>[] = [<span class=\"hljs-string\">&#x27;Angular&#x27;</span>, <span class=\"hljs-string\">&#x27;React&#x27;</span>, <span class=\"hljs-string\">&#x27;Vue&#x27;</span>];\n\n<span class=\"hljs-comment\">// Alternative Schreibweise mit Generic</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">items</span>: <span class=\"hljs-title class_\">Array</span>&lt;<span class=\"hljs-built_in\">number</span>&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n</code></pre><h3 id=\"beliebige-werte-mit-any-und-unknown\">Beliebige Werte mit <code>any</code> und <code>unknown</code></h3>\n<p>Eine mit <code>any</code> oder <code>unknown</code> typisierte Variable kann immer beliebige Werte mit beliebigen Typen annehmen.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-attribute\">let</span> flexible: any = <span class=\"hljs-string\">&#x27;text&#x27;</span>;\n<span class=\"hljs-attribute\">flexible</span> = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-attribute\">flexible</span> = <span class=\"hljs-literal\">true</span>;\n</code></pre><p>Diese beiden Basistypen haben jedoch einen wichtigen Unterschied:\nDer Wert einer mit <code>any</code> typisierten Variable kann zu jeder anderen Variable zugewiesen werden.\n<code>any</code> wird übrigens auch immer als Standardtyp verwendet, wenn wir eine Variable nicht explizit typisieren und der Typ von TypeScript nicht automatisch ermittelt werden kann.</p>\n<p>Der Typ <code>unknown</code> schafft Abhilfe.\nEine solche Variable kann ebenfalls beliebige Werte mit jedem Typ annehmen.\nAllerdings kann der Wert einer <code>unknown</code>-Variable nur dann einer anderen Variable zugewiesen werden, wenn diese auch den Typ <code>unknown</code> oder <code>any</code> trägt.\nUm den Wert einer mit <code>unknown</code> typisierten Variable dennoch zuweisen zu können, müssen wir mithilfe von <code>typeof</code> eine Typprüfung vornehmen.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">unknown</span> = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;\n\n<span class=\"hljs-comment\">// Typprüfung erforderlich</span>\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">&#x27;string&#x27;</span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">text</span>: <span class=\"hljs-built_in\">string</span> = value; <span class=\"hljs-comment\">// Jetzt erlaubt</span>\n}\n</code></pre><p>Praktisch solltest du es vermeiden, <code>any</code> zu verwenden, denn dieser Typ ist fast immer ein Indiz dafür, dass Unklarheit über die Typisierung herrscht.\nWillst du die konkrete Belegung einer Variable absichtlich im Unklaren lassen, ist <code>unknown</code> die bessere Wahl.</p>\n<h2 id=\"klassen\">Klassen</h2>\n<p>Um eine Klasse zu beschreiben, verwenden wir in JavaScript und TypeScript das Schlüsselwort <code>class</code>.\nMit Klassen können einfache Datenobjekte oder auch komplexe objektorientierte Logik abgebildet werden.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span> {\n  <span class=\"hljs-attr\">firstname</span>?: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">lastname</span>: <span class=\"hljs-built_in\">string</span>;\n  age = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-attr\">isAdmin</span>: <span class=\"hljs-built_in\">boolean</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">lastname</span>: <span class=\"hljs-built_in\">string</span></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastname</span> = lastname;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isAdmin</span> = <span class=\"hljs-literal\">false</span>;\n  }\n}\n</code></pre><p>Klassen besitzen drei wesentliche Bestandteile: Eigenschaften, Methoden und eine besondere Methode – den Konstruktor.</p>\n<h3 id=\"eigenschaftenpropertys\">Eigenschaften/Propertys</h3>\n<p>Eigenschaften (engl. <em>properties</em>) erweitern eine Klasseninstanz mit zusätzlichen Informationen.\nPropertys können mit den Zugriffsmodifizierern <code>public</code>, <code>private</code>, <code>static</code>, <code>protected</code> oder <code>readonly</code> versehen werden.\nLässt man die Angabe eines Zugriffsmodifizierers weg, so ist die Eigenschaft immer <code>public</code>.</p>\n<p>Ein Property kann als optional deklariert werden, indem wir ein Fragezeichen setzen.\nJedes Property einer Klasse muss immer entweder sofort einen Wert besitzen oder als optional markiert werden.</p>\n<h3 id=\"methoden\">Methoden</h3>\n<p>Methoden sind die Funktionen einer Klasse und erweitern die Klasse mit Logik.\nWir können die Methodensignatur präzisieren, indem wir Typen für die Argumente und den Rückgabewert angeben.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-built_in\">class</span> Calculator {\n  add(a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span> {\n<span class=\"hljs-built_in\">    return</span> a + b;\n  }\n\n  <span class=\"hljs-built_in\">log</span>(message: <span class=\"hljs-built_in\">string</span>): void {\n    console.<span class=\"hljs-built_in\">log</span>(message);\n  }\n}\n</code></pre><p>Der Typ <code>void</code> sagt aus, dass eine Methode keinen Rückgabewert besitzt.</p>\n<h3 id=\"getter-und-setter\">Getter und Setter</h3>\n<p>Mit den Schlüsselwörtern <code>get</code> und <code>set</code> können wir Methoden verstecken, indem eine Eigenschaft an diese gebunden wird.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> {\n  #<span class=\"hljs-attr\">birthYear</span>: <span class=\"hljs-built_in\">number</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">birthYear</span>: <span class=\"hljs-built_in\">number</span></span>) {\n    <span class=\"hljs-variable language_\">this</span>.#birthYear = birthYear;\n  }\n\n  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">age</span>(): <span class=\"hljs-built_in\">number</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">getFullYear</span>() - <span class=\"hljs-variable language_\">this</span>.#birthYear;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-number\">1990</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(person.<span class=\"hljs-property\">age</span>); <span class=\"hljs-comment\">// Berechnet das Alter</span>\n</code></pre><h3 id=\"konstruktor\">Konstruktor</h3>\n<p>Der Konstruktor ist eine besondere Methode, die bei der Instanziierung einer Klasse aufgerufen wird.\nEr muss immer den Namen <code>constructor()</code> tragen.</p>\n<p>TypeScript bietet für die Initialisierung von Propertys eine Kurzschreibweise:\nWenn wir in der Methodensignatur des Konstruktors für das Argument einen Zugriffsmodifizierer wie <code>public</code> oder <code>private</code> verwenden, so wird das zugehörige Property automatisch deklariert und initialisiert.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">firstname</span>: <span class=\"hljs-built_in\">string</span>,\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">lastname</span>: <span class=\"hljs-built_in\">string</span>\n  </span>) {}\n}\n\n<span class=\"hljs-comment\">// Entspricht:</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserLong</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">firstname</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">lastname</span>: <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">firstname</span>: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">lastname</span>: <span class=\"hljs-built_in\">string</span></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstname</span> = firstname;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastname</span> = lastname;\n  }\n}\n</code></pre><h3 id=\"vererbung\">Vererbung</h3>\n<p>Die Funktionalität einer Klasse kann auf andere Klassen übertragen werden.\nMit dem Schlüsselwort <code>extends</code> kann eine Klasse von einer anderen erben.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> </span>{\n  constructor(public name: string) {}\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PowerUser</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">User</span> </span>{\n  constructor(name: string, public permissions: string[]) {\n    <span class=\"hljs-keyword\">super</span>(name);\n  }\n}\n</code></pre><p>Mit <code>super()</code> kann der Konstruktor der Basisklasse ausgeführt werden.</p>\n<h2 id=\"interfaces\">Interfaces</h2>\n<p>Um die Typisierung in unserem Programmcode konsequent umzusetzen, stellt TypeScript sogenannte <em>Interfaces</em> bereit.\nInterfaces dienen dazu, die typisierte Struktur eines Objekts zu definieren, nicht jedoch die Werte.\nOptionale Eigenschaften werden durch ein Fragezeichen-Symbol gekennzeichnet.</p>\n<pre><code class=\"language-typescript\">interface <span class=\"hljs-keyword\">User</span> <span class=\"hljs-title\">{\n  firstname</span>: <span class=\"hljs-keyword\">string</span>;\n  lastname: <span class=\"hljs-keyword\">string</span>;\n  age?: <span class=\"hljs-keyword\">number</span>;\n}\n\nconst user: <span class=\"hljs-keyword\">User</span> <span class=\"hljs-title\">= {\n  firstname</span>: &#x27;Max&#x27;,\n  lastname: &#x27;Mustermann&#x27;\n};\n</code></pre><p>Fügen wir dem Objekt eine zusätzliche Eigenschaft hinzu oder hat eine der Eigenschaften nicht den Typ, der im Interface definiert wurde, so erhalten wir einen Fehler.</p>\n<h3 id=\"interface-für-klassen\">Interface für Klassen</h3>\n<p>Interfaces können auch dafür verwendet werden, die Struktur einer Klasse vorzugeben.\nDafür wird nach dem Klassennamen das Schlüsselwort <code>implements</code> angefügt.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">interface</span> Printable {\n  <span class=\"hljs-keyword\">print</span>(): <span class=\"hljs-keyword\">void</span>;\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Document</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_ inherited__\">Printable</span> {\n  <span class=\"hljs-keyword\">print</span>(): <span class=\"hljs-keyword\">void</span> {\n    console.log(<span class=\"hljs-string\">&#x27;Printing...&#x27;</span>);\n  }\n}\n</code></pre><!-- TODO: klären, ob wir das drin haben wollen -->\n<!-- Danny: sollte mittlerweile Standard sein und kann raus -->\n<!--\n## Template-Strings\n\nMit einem normalen String in einfachen Anführungszeichen ist es nicht möglich, einen Text über mehrere Zeilen anzugeben.\nEin *Template-String* wird mit schrägen `` ` ``Hochkommata`` ` `` (*Backtick*) eingeleitet und beendet, nicht mit Anführungszeichen.\nDer String kann sich über mehrere Zeilen erstrecken.\n\nMit Template-Strings können wir außerdem Ausdrücke direkt in einen String einbetten:\n\n```typescript\nconst name = 'Angular';\nconst version = 21;\n\nconst message = `Willkommen bei ${name}!\nDie aktuelle Version ist ${version}.`;\n```\n\nWir werden Template-Strings vor allem nutzen, um URLs mit Parametern zusammenzubauen.\n-->\n\n<!-- TODO: klären, ob wir das drin haben wollen -->\n<!-- Danny: sollte mittlerweile Standard sein und kann raus -->\n<!--\n## Arrow Functions\n\nEine *Arrow-Funktion* ist eine Kurzschreibweise für eine normale `function()` in JavaScript.\nAuch die Bezeichnung *Lambda-Ausdruck* ist verbreitet.\n\nDie Definition einer anonymen Funktion verkürzt sich damit elegant zu einem Pfeil `=>`.\nBesitzt die Funktion genau einen Parameter ohne Typ, können die runden Klammern auf der linken Seite weggelassen werden.\nAuch die geschweiften Klammern auf der rechten Seite können eingespart werden:\nLässt man die Klammern weg, ist das Ergebnis des rechtsseitigen Ausdrucks der Rückgabewert für die Funktion.\n\n```typescript\n// Diese vier Definitionen sind gleichwertig:\nconst fn1 = function(x: number) { return x * 2; };\nconst fn2 = (x: number) => { return x * 2; };\nconst fn3 = (x: number) => x * 2;\nconst fn4 = x => x * 2; // Nur ohne Typangabe\n```\n\nDas folgende Beispiel zeigt, wie wir alle geraden Zahlen aus einer Liste ermitteln können:\n\n```typescript\nconst numbers = [1, 2, 3, 4, 5, 6];\n\n// Herkömmliche Funktion\nconst even1 = numbers.filter(function(n) {\n  return n % 2 === 0;\n});\n\n// Arrow-Funktion – wesentlich kompakter\nconst even2 = numbers.filter(n => n % 2 === 0);\n```\n\nEin weiterer Vorteil der Arrow-Funktion ist, dass sie keinen eigenen `this`-Kontext besitzt.\nDas ist besonders dann interessant, wenn wir die Funktion innerhalb einer Klasse verwenden und mit `this` auf die Instanz der Klasse zugreifen möchten.\nMit Arrow-Funktionen wird die Variable `this` aus dem übergeordneten Kontext verwendet.\n\n```typescript\nclass Counter {\n  count = 0;\n\n  increment() {\n    // Arrow-Funktion: this zeigt auf die Klasseninstanz\n    setTimeout(() => {\n      this.count++;\n      console.log(this.count);\n    }, 1000);\n  }\n}\n```\n-->\n\n<!-- TODO: klären, ob wir das drin haben wollen -->\n<!-- Danny: haben wir im Buch und ist auch nicht spezifisch für TS, kann als raus -->\n<!--\n## Immutability\n\nIn JavaScript werden Objekte und Arrays stets nur als Referenzen auf eine zugehörige Speicherstelle gespeichert.\nÄndern wir also die Inhalte direkt im Objekt, so ändert sich die Referenz nicht!\nDas bedeutet auch, dass bei Zuweisung eines Objekts zu einer Variable lediglich ein Verweis auf das ursprüngliche Objekt erzeugt wird.\n\n```typescript\nconst book = { title: 'Angular', year: 2023 };\nconst copy = book;\ncopy.year = 2024;\n\nconsole.log(book.year); // 2024 – auch das Original wurde geändert!\n```\n\nUm gut wartbaren Code zu erhalten, dürfen wir niemals die Werte eines Objekts oder Arrays direkt verändern.\nWir behandeln ein Objekt oder Array als *unveränderlich* (engl. *immutable*) und erzeugen bei einer Änderung immer eine Kopie.\nHierfür nutzen wir in der Regel die Spread-Syntax.\n\n> **Merke:** Objekte und Arrays sollten nie direkt verändert werden. Stattdessen sollte immer eine Kopie mit neuer Referenz erzeugt werden, die die gewünschten Änderungen enthält.\n-->\n\n<!-- TODO: klären, ob wir das drin haben wollen -->\n<!-- Danny: haben wir im Buch und brauchen wir hier nicht. Auch nicht TS spezifisch -->\n<!--\n## Spread-Syntax und Rest-Parameter\n\nIn JavaScript können wir eine Syntax mit drei Punkten verwenden (`...`).\nDiese Schreibweise hat zwei Bedeutungen, je nachdem, wo sie eingesetzt wird:\nDie *Spread-Syntax* breitet Elemente aus, während *Rest-Parameter* übrige Argumente einsammeln.\n\n### Objekteigenschaften kopieren\n\nMit der Spread-Syntax können wir Objekte klonen und dabei Eigenschaften überschreiben:\n\n```typescript\nconst book = { title: 'Angular', year: 2023 };\nconst copy = { ...book, year: 2026 };\n\nconsole.log(book.year); // 2023 – Original unverändert\nconsole.log(copy.year); // 2026 – Kopie mit neuem Wert\n```\n\nBitte beachte, dass diese Idee nur für *Plain Objects* funktioniert und nur eine flache Kopie (*Shallow Copy*) erzeugt.\nTiefere Zweige eines Objekts müssen einzeln geklont werden.\nWird diese Aufgabe zu kompliziert, können wir die native Funktion `structuredClone()` verwenden, die eine *Deep Copy* erzeugt.\n\n### Array-Elemente kopieren\n\nDie Spread-Syntax funktioniert ähnlich auch für Arrays:\n\n```typescript\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\n\nconst copy = [...arr1];\nconst combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]\n```\n\n### Funktionsargumente übergeben\n\nWollen wir die Elemente eines Arrays einzeln als Argumente an eine Funktion übergeben, können wir die Spread-Syntax nutzen:\n\n```typescript\nconst numbers = [1, 2, 3];\nconsole.log(Math.max(...numbers)); // 3\n```\n\n### Funktionsargumente einsammeln\n\nIn einem anderen Kontext haben die drei Punkte eine andere Bedeutung:\nErhält eine Funktion mehrere Argumente, so können wir diese elegant in einem Array erfassen.\nEin solcher Parameter heißt *Rest-Parameter*.\n\n```typescript\nfunction sum(...numbers: number[]): number {\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4)); // 10\n```\n-->\n\n<h2 id=\"private-eigenschaften-von-klassen\">Private Eigenschaften von Klassen</h2>\n<p>Mit <em>Private Class Fields</em> in JavaScript können wir Datenkapselung in Klassen realisieren.\nEin privates Feld wird durch ein vorangestelltes <code>#</code>-Symbol definiert und ist nur innerhalb der Klasse zugänglich.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">User</span> {\n  #<span class=\"hljs-keyword\">password</span>: string;\n\n  constructor(<span class=\"hljs-keyword\">password</span>: string) {\n    this.#<span class=\"hljs-keyword\">password</span> = <span class=\"hljs-keyword\">password</span>;\n  }\n\n  checkPassword(<span class=\"hljs-keyword\">input</span>: string): <span class=\"hljs-type\">boolean</span> {\n    <span class=\"hljs-keyword\">return</span> this.#<span class=\"hljs-keyword\">password</span> === <span class=\"hljs-keyword\">input</span>;\n  }\n}\n\nconst <span class=\"hljs-keyword\">user</span> = <span class=\"hljs-built_in\">new</span> <span class=\"hljs-keyword\">User</span>(<span class=\"hljs-string\">&#x27;secret&#x27;</span>);\n// <span class=\"hljs-keyword\">user</span>.#<span class=\"hljs-keyword\">password</span>; // Fehler: Zugriff nicht möglich\n</code></pre><p>In TypeScript existiert außerdem der Access Modifier <code>private</code>, der die Sichtbarkeit einschränkt.\nDer Schutz ist allerdings zur Laufzeit nicht garantiert, da TypeScript zu JavaScript umgewandelt wird.\nWir empfehlen die moderne JavaScript-Variante mit <code>#</code>.</p>\n<h2 id=\"property-modifiers-readonly-und-protected\">Property Modifiers: <code>readonly</code> und <code>protected</code></h2>\n<p>TypeScript stellt uns eine Reihe von <em>Property Modifiers</em> zur Verfügung:</p>\n<p>Der Modifier <code>protected</code> sorgt für eine eingeschränkte Sichtbarkeit.\nEin Protected Property ist nicht von außen sichtbar, sondern kann nur innerhalb derselben Klasse und in vererbten Kindklassen verwendet werden.\nDazu gehört auch das Template einer Angular-Komponente.</p>\n<p>Mit <code>readonly</code> können wir sicherstellen, dass eine Eigenschaft nach der Initialisierung nicht mehr verändert werden kann.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Config</span> </span>{\n  readonly apiUrl = <span class=\"hljs-string\">&#x27;https://api.example.com&#x27;</span>;\n  protected secret = <span class=\"hljs-string\">&#x27;12345&#x27;</span>;\n}\n</code></pre><p>Für Angular-Projekte empfehlen wir folgende Konventionen:</p>\n<ul>\n<li>Propertys und Methoden, die nur innerhalb der Klasse verwendet werden, werden als privat markiert.</li>\n<li>Propertys, die im Template einer Komponente genutzt werden, werden mit <code>protected</code> gekennzeichnet.</li>\n<li>Propertys, die von Angular verwaltet werden, werden auf <code>readonly</code> gesetzt (z. B. <code>input()</code>, <code>output()</code>, <code>model()</code>).</li>\n</ul>\n<h2 id=\"decorators\">Decorators</h2>\n<p>Mit Decorators können wir Klassen, Methoden und Eigenschaften dekorieren und damit Metadaten hinzufügen.\nMan erkennt einen Decorator am <code>@</code>-Zeichen zu Beginn des Namens.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-variable\">@Component</span>({\n  selector: <span class=\"hljs-string\">&#x27;app-root&#x27;</span>,\n  template: <span class=\"hljs-string\">&#x27;&lt;h1&gt;Hello&lt;/h1&gt;&#x27;</span>\n})\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> </span>{}\n</code></pre><p>Angular nutzt dieses Sprachkonzept, um Klassen eine Semantik zu geben:\nDurch den Decorator <code>@Component()</code> wird diese Klasse als Komponente behandelt.\nAlle Decorators von Angular sind Funktionen, daher darf man die Funktionsklammern bei der Verwendung nicht vergessen.</p>\n<h2 id=\"generic-types\">Generic Types</h2>\n<p>Mit <em>Generics</em> können wir Typparameter für Klassen und Funktionen definieren.\nSie sind ein wichtiges Konzept in TypeScript, um wiederverwendbare und flexible Funktionen zu erstellen.</p>\n<pre><code class=\"language-typescript\">interface <span class=\"hljs-title\">Book</span> {\n  <span class=\"hljs-attribute\">title</span>: <span class=\"hljs-built_in\">string</span>;\n}\n\n<span class=\"hljs-comment\">// Generischer Typ wird automatisch erkannt</span>\n<span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-keyword\">signal</span><span class=\"hljs-string\"></span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// Signal&lt;number&gt;</span>\n<span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-keyword\">signal</span><span class=\"hljs-string\"></span>(<span class=\"hljs-string\">&#x27;Angular&#x27;</span>); <span class=\"hljs-comment\">// Signal&lt;string&gt;</span>\n\n<span class=\"hljs-comment\">// Bei Objekten muss der Typ explizit angegeben werden</span>\n<span class=\"hljs-keyword\">const</span> book = <span class=\"hljs-keyword\">signal</span><span class=\"hljs-string\">&lt;Book&gt;</span>({ <span class=\"hljs-attribute\">title</span>: <span class=\"hljs-string\">&#x27;Angular&#x27;</span> }); <span class=\"hljs-comment\">// Signal&lt;Book&gt;</span>\n</code></pre><!-- TODO: klären, ob wir das drin haben wollen -->\n<!-- Danny: haben wir schon im Buch und ist kein TS -->\n<!--\n## Promises und `async`/`await`\n\nEine *Promise* ist ein natives Objekt in JavaScript, das einen asynchronen Vorgang repräsentiert.\nSie liefert entweder einen Wert zurück, wenn die Operation erfolgreich war, oder einen Fehler, wenn die Ausführung fehlgeschlagen ist.\n\nMit den Schlüsselwörtern `async` und `await` können wir asynchronen Code schreiben, der wie synchroner Code aussieht.\n\n```typescript\n// Mit then()\nfetch('/api/data')\n  .then(response => response.json())\n  .then(data => console.log(data));\n\n// Mit async/await\nasync function loadData() {\n  const response = await fetch('/api/data');\n  const data = await response.json();\n  console.log(data);\n}\n```\n-->\n\n<h2 id=\"weitere-features\">Weitere Features</h2>\n<h3 id=\"union-types\">Union Types</h3>\n<p>Mit Union Types können wir zusammengesetzte Typen beschreiben:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">format</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-built_in\">string</span> {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">&#x27;string&#x27;</span>) {\n    <span class=\"hljs-keyword\">return</span> value.<span class=\"hljs-title function_\">toUpperCase</span>();\n  }\n  <span class=\"hljs-keyword\">return</span> value.<span class=\"hljs-title function_\">toFixed</span>(<span class=\"hljs-number\">2</span>);\n}\n</code></pre><h3 id=\"optional-chaining\">Optional Chaining</h3>\n<p>Optional Chaining ermöglicht einen sicheren Zugriff auf verschachtelte Objekte:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">const</span> user = { address: { city: &#x27;Berlin&#x27; } };\n<span class=\"hljs-keyword\">const</span> city = user?.address?.city; <span class=\"hljs-comment\">// &#x27;Berlin&#x27;</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">zip</span> = user?.address?.<span class=\"hljs-keyword\">zip</span>; <span class=\"hljs-comment\">// undefined (kein Fehler)</span>\n</code></pre><h3 id=\"nullish-coalescing\">Nullish Coalescing</h3>\n<p>Nullish Coalescing erlaubt die einfache Zuweisung von Rückfallwerten:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-keyword\">const</span> result = value ?? <span class=\"hljs-string\">&#x27;default&#x27;</span>; <span class=\"hljs-comment\">// &#x27;default&#x27;</span>\n\n<span class=\"hljs-comment\">// Unterschied zu ||</span>\n<span class=\"hljs-keyword\">const</span> zero = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(zero || <span class=\"hljs-string\">&#x27;fallback&#x27;</span>); <span class=\"hljs-comment\">// &#x27;fallback&#x27;</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(zero ?? <span class=\"hljs-string\">&#x27;fallback&#x27;</span>); <span class=\"hljs-comment\">// 0</span>\n</code></pre><h2 id=\"konfiguration\">Konfiguration</h2>\n<p>Um TypeScript-Code in Node.js oder im Browser ausführen zu können, muss dieser zunächst in JavaScript umgewandelt werden.\nDiese Aufgabe übernimmt der <em>Transpiler</em>.</p>\n<p>Die Konfiguration wird in der Datei <code>tsconfig.json</code> hinterlegt.\nDie wohl wichtigste Einstellung ist das <code>target</code>: Diese Option gibt an, in welche Version von JavaScript das Programm transpiliert werden soll.</p>\n<p>In einem Angular-Projekt müssen wir uns über die Konfiguration von TypeScript nur wenige Gedanken machen, denn die Einstellungen sind bereits mit sinnvollen Werten vordefiniert.</p>\n<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n<p>TypeScript erweitert den JavaScript-Sprachstandard um viele Features, die wir bereits aus etablierten Sprachen wie C# oder Java kennen.\nDadurch fällt auch der Umstieg von einer anderen objektorientierten Sprache nicht schwer.\nAuch wenn du bisher mit reinem JavaScript entwickelt hast, ist der Umstieg auf TypeScript keine große Hürde, weil alle bekannten Features aus JavaScript weiterhin verwendet werden können.</p>\n<p>Mit der Typisierung und Objektorientierung können wir die Schnittstellen unserer Software klar definieren.\nDer Editor kann uns bei der Arbeit mit TypeScript effizient unterstützen und schon zur Entwicklungszeit auf Fehler hinweisen.</p>\n<p>Damit unsere Anwendung später auch in jedem Browser lauffähig ist, wird TypeScript vor der Auslieferung immer in reines JavaScript umgewandelt.</p>\n","meta":{"title":"Einführung in TypeScript","published":"2026-02-10T00:00:00.000Z","lastModified":"2026-02-05T00:00:00.000Z","hidden":true}}
