{"slug":"2024-11-angular19","html":"<p>Neben grauen Herbsttagen hat der November in Sachen Angular einiges zu bieten: Am 19. November wurde die neue <strong>Major-Version Angular 19</strong> releaset!\nAngular bringt mit der Resource API und dem Linked Signal einige neue Features mit. Standalone Components m√ºssen au√üerdem nicht mehr explizit als solche markiert werden.\nWir stellen in diesem Blogpost alle wichtigen Neuerungen vor!</p>\n<!-- Im offiziellen [Angular-Blog](TODO) finden Sie alle offiziellen Informationen direkt vom Angular-Team. -->\n\n<p>F√ºr die Migration auf Angular 19 empfehlen wir, den Befehl <code>ng update</code> zu nutzen.\nDetaillierte Infos zu den Schritten liefert der <a href=\"https://angular.dev/update-guide\">Angular Update Guide</a>.</p>\n<h2 id=\"standalone-components-der-neue-standard\">Standalone Components: der neue Standard</h2>\n<p>Standalone Components wurden mit Angular 15 eingef√ºhrt und haben sich seitdem zum Standard bei der Komponentenentwicklung mit Angular etabliert.\nNgModules sind damit vollst√§ndig optional.\nAb Angular 19 ist es nicht mehr notwendig, eine Standalone Component explizit als solche zu markieren. Das Flag <code>standalone: true</code> in den Metadaten der Komponente entf√§llt, denn der neue Standardwert ist <code>true</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// vor Angular 19</span>\n<span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-attribute\">selector</span>: <span class=\"hljs-string\">&#x27;app-my&#x27;</span>,\n  <span class=\"hljs-attribute\">templateUrl</span>: <span class=\"hljs-string\">&#x27;./my.component.html&#x27;</span>,\n  <span class=\"hljs-attribute\">standalone</span>: true,\n  <span class=\"hljs-attribute\">imports</span>: []\n})\nexport class MyComponent {}\n</code></pre>\n<pre><code class=\"language-ts\">// ‚≠êÔ∏è ab Angular <span class=\"hljs-number\">19</span>\n<span class=\"hljs-variable\">@Component</span>({\n  selector: <span class=\"hljs-string\">&#x27;app-my&#x27;</span>,\n  templateUrl: <span class=\"hljs-string\">&#x27;./my.component.html&#x27;</span>,\n  imports: []\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{}\n</code></pre>\n<p>Modulbasierte Komponenten m√ºssen nun explizit mit <code>standalone: false</code> markiert werden.\nEine automatische Migration beim Update mit <code>ng update</code> sorgt daf√ºr, dass das Feld <code>standalone</code> korrekt gesetzt wird.</p>\n<p>Wir empfehlen unbedingt, durchgehend auf Standalone Components zu setzen und NgModules nur noch in Ausnahmef√§llen zu verwenden, wenn es f√ºr die Kompatibilit√§t notwendig ist.</p>\n<p>√úbrigens: Mit Angular 19 wurde eine neue Compiler-Option eingef√ºhrt, die Standalone Components erzwingt. Setzen wir <code>strictStandalone</code> in der Datei <code>tsconfig.json</code>, m√ºssen alle Komponenten im Projekt standalone sein.</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: { /* <span class=\"hljs-string\">...</span> */ },\n  <span class=\"hljs-string\">&quot;angularCompilerOptions&quot;</span>: {\n    <span class=\"hljs-string\">&quot;strictStandalone&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span>\n  }\n}\n</code></pre>\n<p>In einem ausf√ºhrlichen <a href=\"https://blog.angular.dev/the-future-is-standalone-475d7edbc706\">Blogpost</a> erkl√§rt Alex Rickabaugh vom Angular-Team die Zukunft von NgModules.\nAuch wenn &quot;die Zukunft standalone ist&quot;, bleiben NgModules weiterhin erhalten und werden nicht deprecated.\nProjekte k√∂nnen modulbasierte Komponenten weiterhin verwenden, ein Zwang zum Update besteht nicht.</p>\n<h2 id=\"lokale-variablen-mit-let\">Lokale Variablen mit <code>@let</code></h2>\n<p>Mit dem neuen Schl√ºsselwort <code>@let</code> k√∂nnen wir lokale Variablen direkt im Template definieren.\nDiese Syntax funktioniert schon seit Angular 18.1, wird mit Angular 19 aber als <em>stable</em> markiert.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-variable\">@let</span> name = expression;\n</code></pre>\n<p>Die Variablen k√∂nnen im Template flexibel eingesetzt werden, aber:\nGesch√§ftslogik sollte grunds√§tzlich in der TypeScript-Klasse untergebracht werden und <em>nicht</em> im Template (Trennung von Logik und Darstellung).\nDie <code>@let</code>-Syntax sollte deshalb sparsam eingesetzt werden.</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\">@for (book of books(); track book.isbn) {\n  @let preisBrutto = book.price * 1.19;\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"> ‚Äì </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">preisBrutto</span> | currency }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n}</span>\n</code></pre>\n<p>Um Daten aus Observables aufzul√∂sen, k√∂nnen wir im Template die AsyncPipe verwenden.\nMithilfe von <code>@let</code> k√∂nnen wir das Ergebnis der AsyncPipe elegant in eine Variable schreiben und anschlie√üend einsetzen:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\">@let book = book$ | async;\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.description</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</code></pre>\n<p>Der Conditional Control Flow (<code>@if</code>) und die Direktive <code>*ngIf</code> bieten seit jeher die M√∂glichkeit, das Ergebnis der Bedingung in eine lokale Variable zu schreiben:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\">@if (book$ | async; as book) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n}\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book$ | async as book&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span></span>\n</code></pre>\n<p>Falls die Daten aus dem Observable <code>book$</code> zeitverz√∂gert eintreffen oder als optional typisiert sind (<code>Book | undefined</code>), ist die Kombination mit <code>@if</code> der richtige Weg: Das Template soll nur angezeigt werden, wenn tats√§chlich Daten vorliegen.\nH√§ufig wird dieses Muster aber nur eingesetzt, um die Daten in eine Variable zu schreiben, ohne dass die if-Bedingung tats√§chlich ben√∂tigt wird.\nIn diesem Fall sollte <code>@let</code> verwendet werden.</p>\n<ul>\n<li><code>@if</code> + <code>as</code>: wenn Bedingung gepr√ºft werden muss, bevor die Variable verwendet wird</li>\n<li><code>@let</code>: wenn nur eine Variable ben√∂tigt wird</li>\n</ul>\n<h2 id=\"resource-api\">Resource API</h2>\n<p>Mit Angular 19 wurde die <em>experimentelle</em> Resource API vorgestellt.\nDamit k√∂nnen wir intuitiv Daten laden und in Komponenten verarbeiten.\nEine Resource repr√§sentiert einen Datensatz, der asynchron geladen wird, in der Regel per HTTP.\nDie Resource bietet eine Schnittstelle an, um die Daten zu verarbeiten, neuzuladen und sogar manuell zu √ºberschreiben.</p>\n<p>Eine Resource wird mit der Funktion <code>resource</code> und einer Loader-Funktion initialisiert.\nDieser Loader ist daf√ºr verantwortlich, die Daten asynchron zu laden. Die Funktion muss immer eine Promise zur√ºckgeben: Wir k√∂nnen hier also entweder direkt die native Fetch API verwenden, oder wir wandeln das Observable aus dem <code>HttpClient</code> von Angular mithilfe von <code>firstValueFrom()</code> in eine Promise um:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { resource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\nbooksResource = <span class=\"hljs-title function_\">resource</span>({\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">apiUrl</span> + <span class=\"hljs-string\">&#x27;/books&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-title class_\">Book</span>[]&gt;\n});\n\n<span class=\"hljs-comment\">// bs.getAll() gibt ein Observable&lt;Book[]&gt; zur√ºck</span>\nbooksResource = <span class=\"hljs-title function_\">resource</span>({\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">firstValueFrom</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getAll</span>())\n});\n</code></pre>\n<p>Der Loader wird automatisch ausgef√ºhrt, sobald die Resource initialisiert wird.\nUm mit den Daten zu arbeiten, stehen in der Resource drei Signals zur Verf√ºgung: <code>value</code> enth√§lt die Daten, <code>status</code> informiert √ºber den Zustand der Resource, und <code>error</code> liefert ein Fehler-Objekt:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">booksResource.value</span>() | json }}</span><span class=\"language-xml\">\n\n@for(book of booksResource.value(); track book.isbn) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n}</span>\n</code></pre>\n<p>Die Resource bietet uns die M√∂glichkeit, ohne gro√üen Aufwand einen Ladeindikator anzuzeigen.\nDaf√ºr besitzt das Objekt sogar ein eigenes Signal <code>isLoading()</code>:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-keyword\">@if</span> (booksResource.isLoading()) {\n  &lt;<span class=\"hljs-selector-tag\">div</span>&gt;LOADING&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;\n}\n</code></pre>\n<p>Eine Resource kann jederzeit neugeladen werden. Der Loader wird beim Aufruf der Methode <code>reload()</code> erneut ausgef√ºhrt, und die geladenen Daten stehen anschlie√üend in <code>value</code> zur Verf√ºgung:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListComponent</span> </span>{\n  booksResource = resource({ <span class=\"hljs-regexp\">/* ... */</span> });\n\n  reloadList() {\n    this.booksResource.reload();\n  }\n}\n</code></pre>\n<p>Au√üerdem kann der Wert einer Resource jederzeit manuell √ºberschrieben werden.\nDaf√ºr besitzt das Signal <code>value</code> die bekannten Methoden <code>set()</code> und <code>update()</code>.\nMit einem Observable oder einem Signal, das durch <code>toSignal()</code> aus einem Observable erstellt wurde, w√§re das nicht so einfach m√∂glich.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-title function_\">clearBookList</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksResource</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">set</span>([]);\n}\n</code></pre>\n<p>Die Loader-Funktion kann Parameter verarbeiten. Das ist sinnvoll, wenn der HTTP-Request weitere Informationen ben√∂tigt, z. B. die ID des zu ladenden Datensatzes.\nDaf√ºr k√∂nnen wir optional einen <code>request</code> definieren: Dieses Signal dient als Trigger f√ºr die Loader-Funktion.\nImmer wenn sich der Wert √§ndert, wird der Loader neu ausgef√ºhrt.\nDer Wert des <code>request</code>-Signals steht dann als Argument f√ºr den Loader zur Verf√ºgung.</p>\n<p>Immer wenn sich im folgenden Beispiel die ISBN √§ndert, wird der HTTP-Request f√ºr das dazugeh√∂rige Buch neu ausgef√ºhrt.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> {\n  <span class=\"hljs-keyword\">private</span> bs = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookStoreService</span>);\n  isbn = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  bookResource = <span class=\"hljs-title function_\">resource</span>({\n    <span class=\"hljs-attr\">request</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isbn</span>,\n    <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ request }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getSingle</span>(request)\n  });\n}\n</code></pre>\n<p>F√ºr die Kompatibilit√§t mit Observables aus der Bibliothek RxJS bietet Angular die sogenannte <code>rxResource</code> an.\nSie funktioniert wie <code>resource</code>, aber die Loader-Funktion gibt ein Observable zur√ºck.\nAuf diese Weise k√∂nnen wir Observables aus dem <code>HttpClient</code> direkt verwenden, ohne Umweg √ºber eine Promise:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { rxResource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> ...\n\nbooksResource = rxResource({\n  loader: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.bs.getAll()\n});\n</code></pre>\n<p>Bitte beachten Sie, dass die Resource API experimentell ist und sich die Schnittstelle vor dem finalen Release noch √§ndern k√∂nnte.</p>\n<blockquote>\n<p>üìù Wir erl√§utern die Resource API ausf√ºhrlich in einem separaten Blogpost:<br>\n<strong><a href=\"/blog/2024-10-resource-api/\">Neu in Angular 19: Daten laden mit der Resource API</a></strong></p>\n</blockquote>\n<h2 id=\"linked-signals\">Linked Signals</h2>\n<p>Das Linked Signal wurde mit Angular 19 als <em>Developer Preview</em> vorgestellt.\nEs handelt sich um ein Signal, das seinen Wert automatisch auf Basis anderer Signals berechnet ‚Äì √§hnlich wie ein Computed Signal mit <code>computed()</code>.\nDer Unterschied: Der Wert eines Linked Signals kann jederzeit mit den Methoden <code>set()</code> und <code>update()</code> von au√üen √ºberschrieben werden, so wie wir es von <code>signal()</code> kennen.\nEin Linked Signal vereint also das Beste aus beiden Welten, wie der folgende Vergleich zeigt.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { linkedSignal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\ntimestampMs = signal(<span class=\"hljs-built_in\">Date</span>.<span class=\"hljs-built_in\">now</span>());\n\n<span class=\"hljs-comment\">// Wert des Signals kann √ºberschrieben werden</span>\ntimestampMs.set(<span class=\"hljs-built_in\">Date</span>.<span class=\"hljs-built_in\">now</span>());\ntimestampMs.update(<span class=\"hljs-function\"><span class=\"hljs-params\">ms</span> =&gt;</span> ms + <span class=\"hljs-number\">1000</span>);\n\n<span class=\"hljs-comment\">// computed(): Signal (nicht schreibbar)</span>\nconst timestampSeconds = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> timestampMs() / <span class=\"hljs-number\">1000</span>);\ntimestampSeconds.set(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ‚ùå Compilation Error</span>\n\n<span class=\"hljs-comment\">// linkedSignal(): WritableSignal (schreibbar)</span>\nconst timestampSecondsLinked = linkedSignal(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> timestampMs() / <span class=\"hljs-number\">1000</span>);\ntimestampSecondsLinked.set(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ‚úÖ funktioniert</span>\n</code></pre>\n<p>Wir k√∂nnen alternativ eine ausf√ºhrlichere Schreibweise w√§hlen: In einem Optionsobjekt √ºbergeben wir dazu <code>source</code> und <code>computation</code>.\nDer aktuelle Wert des Signals in <code>source</code> wird als Argument an die Computation Function √ºbergeben.\nWelche Schreibweise zu w√§hlen ist, h√§ngt vom Anwendungsfall und Geschmack ab, beide Implementierungen von <code>timestampSecondsLinked</code> f√ºhren zum gleichen Ergebnis.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> timestampMs = <span class=\"hljs-keyword\">signal</span><span class=\"hljs-string\"></span>(<span class=\"hljs-built_in\">Date</span>.now());\n\n<span class=\"hljs-keyword\">const</span> timestampSecondsLinked = linkedSignal({\n  <span class=\"hljs-attribute\">source</span>: timestampMs,\n  <span class=\"hljs-attribute\">computation</span>: ms =&gt; ms / <span class=\"hljs-number\">1000</span>\n});\n</code></pre>\n<p>Ein Linked Signal ist besonders n√ºtzlich, wenn lokaler State mit dynamisch geladenen Daten synchronisiert werden soll.\nDas Signal berechnet seinen Wert aus einer Quelle, z. B. ein Component Input oder ein HTTP-Request, die Komponente kann das Signal aber weiterhin selbst mit Werten √ºberschreiben.</p>\n<blockquote>\n<p>üìù Wir stellen das Linked Signal ausf√ºhrlich in einem separaten Blogpost vor. Dort finden Sie mehrere praktische Anwendungsf√§lle f√ºr <code>linkedSignal()</code>:<br>\n<strong><a href=\"/blog/2024-11-linked-signal/\">Neu in Angular 19: LinkedSignal f√ºr reaktive Zustandsverwaltung</a></strong></p>\n</blockquote>\n<h2 id=\"migrationen-f√ºr-signal-based-apis\">Migrationen f√ºr Signal-based APIs</h2>\n<p>Angular hat in den vergangenen Versionen mehrere Komponenten-Schnittstellen auf funktionale Varianten umgestellt.</p>\n<ul>\n<li>Component Inputs mit der Funktion <code>input()</code> liefern die Daten als Signal.</li>\n<li>Querys f√ºr ViewChildren und ContentChildren k√∂nnen mit den Funktionen <code>viewChild</code>/<code>viewChildren</code> und <code>contentChild</code>/<code>contentChildren</code> als Signals erfasst werden.</li>\n<li>Component Outputs k√∂nnen mit der Funktion <code>output()</code> definiert werden. Das Ergebnis ist zwar kein Signal, aber die Schnittstelle steht in einer Reihe mit dem neuen <code>input()</code>.</li>\n</ul>\n<p>Bisher wurden daf√ºr Dekoratoren verwendet (z. B. <code>@Input()</code>), die nun nicht mehr notwendig sind.</p>\n<p>Angular bietet Migrationsskripte an, um die Propertys in den Komponenten korrekt auf die neuen Schnittstellen zu migrieren:</p>\n<pre><code class=\"language-bash\"># Updates `@Input` declarations to signal inputs\nng <span class=\"hljs-keyword\">generate</span> @angular/core:signal-<span class=\"hljs-keyword\">input</span>-migration\n\n# Updates query declarations to signal queries\nng <span class=\"hljs-keyword\">generate</span> @angular/core:signal-queries-migration\n\n# Updates @<span class=\"hljs-keyword\">output</span> declarations to the functional equivalent\nng <span class=\"hljs-keyword\">generate</span> @angular/core:<span class=\"hljs-keyword\">output</span>-migration\n</code></pre>\n<p>F√ºr Inputs und Querys (ViewChildren und ContentChildren) gibt es eine kombinierte Migration:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Combines all signals-related migrations into a single migration</span>\n<span class=\"hljs-attribute\">ng</span> generate <span class=\"hljs-variable\">@angular</span>/core:signals\n</code></pre>\n<h2 id=\"signals-schreiben-in-effects\">Signals schreiben in Effects</h2>\n<p>Ein Effect ist eine Funktion, die automatisch ausgef√ºhrt wird, wenn eins der darin verwendeten Signals seinen Wert √§ndert.\nDamit k√∂nnen wir Code ausf√ºhren, sobald ver√§nderte Daten vorliegen.</p>\n<pre><code class=\"language-ts\">counter = signal(<span class=\"hljs-number\">0</span>);\ncounter100 = signal(<span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">constructor</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">{\n  effect(() =&gt; {\n    console.log(&#x27;Aktueller Counter-Wert:&#x27;, this.counter());\n\n    // funktionierte bisher nur mit `allowSignalWrites: true`\n    this.counter100.set(this.counter() * 100);\n  }</span>);</span>\n}\n</code></pre>\n<p>Dabei galt bisher die Empfehlung, in Effects keine Werte von Signals zu ver√§ndern.\nSollte das doch m√∂glich sein, musste daf√ºr die Option <code>allowSignalWrites</code> gesetzt werden ‚Äì dann konnte der Effects auch in Signals schreiben.</p>\n<p>Mit Angular 19 entf√§llt diese Option. In Effects k√∂nnen wir nun ohne zus√§tzliche Konfiguration die Werte von Signals √§ndern.\nDiese Richtungs√§nderung hat das Angular-Team in einem eigenen <a href=\"https://blog.angular.dev/latest-updates-to-effect-in-angular-f2d2648defcd\">Blogpost</a> vorgestellt.\nEs gilt nun nicht mehr als schlechte Praxis, mit Effects weitere Signals zu setzen oder andere Seiteneffekte auszul√∂sen.</p>\n<p>Bitte verwenden Sie Effects grunds√§tzlich dennoch sparsam! H√§ufig ist ein Computed Signal oder Linked Signal das bessere Mittel:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-attribute\">counter</span> <span class=\"hljs-operator\">=</span> signal(<span class=\"hljs-number\">0</span>)<span class=\"hljs-comment\">;</span>\n<span class=\"hljs-attribute\">counter100</span> <span class=\"hljs-operator\">=</span> computed(() <span class=\"hljs-operator\">=</span>&gt; this.counter() * <span class=\"hljs-number\">100</span>)<span class=\"hljs-comment\">;</span>\n</code></pre>\n<h2 id=\"afterrendereffect-effects-f√ºr-dom-interaktionen\"><code>afterRenderEffect</code>: Effects f√ºr DOM-Interaktionen</h2>\n<p>Angular hat bereits vor einiger Zeit die neuen Lifecycle-Funktionen <a href=\"https://next.angular.dev/api/core/afterRender\"><code>afterRender</code></a> und <a href=\"https://next.angular.dev/api/core/afterNextRender\"><code>afterNextRender</code></a> vorgestellt.\nMit Angular 19 kommt nun das signalbasierte Pendant <a href=\"https://next.angular.dev/api/core/afterRenderEffect\"><code>afterRenderEffect</code></a> hinzu.\nDas Besondere an <code>afterRenderEffect</code>: Die Daten zwischen den Render-Phasen werden als Signals ausgetauscht.\nDie Phasen werden nur erneut ausgef√ºhrt, wenn sich gebundene Signals ge√§ndert haben.\nDOM-Manipulationen werden so auf das n√∂tige Minimum reduziert.</p>\n<p>Alle drei Hilfsmittel sind daf√ºr gedacht, sicher mit dem DOM einer Komponente zu interagieren.\nIn der Regel ist das f√ºr normale Gesch√§ftslogik nicht notwendig, weshalb die drei Funktionen eher f√ºr Spezialf√§lle gedacht sind.</p>\n<blockquote>\n<p>üìù Wenn Sie mehr √ºber das ge√§nderte Verhalten von <code>effect()</code> und die neuen Effects von <code>afterRenderEffect()</code> erfahren m√∂chten, empfehlen wir unseren ausf√ºhrlichen Blogpost dazu:<br>\n<strong><a href=\"https://angular.schule/blog/2024-11-effect-afterrendereffect\">Angular 19: Mastering effect and afterRenderEffect</a></strong></p>\n</blockquote>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Wir empfehlen, regelm√§√üig einen Blick in den Changelog von <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/main/CHANGELOG.md\">Angular CLI</a> zu werfen.\nNeben den gro√üen neuen Features gibt es auch einige kleinere interessante Neuerungen:</p>\n<ul>\n<li><strong>Zoneless Application generieren:</strong> Mit der Funktion <code>provideExperimentalZonelessChangeDetection()</code> k√∂nnen wir den √§lteren Mechanismus f√ºr die Change Detection auf Basis von Zone.js deaktivieren. Die Change Detection funktioniert dann vollst√§ndig mit Signals. Ab Angular 19 k√∂nnen wir diesen Modus bereits bei der Erstellung eines Projekts w√§hlen: <code>ng new --experimental-zoneless</code>. (siehe <a href=\"https://github.com/angular/angular-cli/commit/755f3a07f5fe485c1ed8c0c6060d6d5c799c085c\">Commit</a>)</li>\n<li><strong>Default Export f√ºr Komponenten:</strong> Komponenten werden standardm√§√üig als Named Export generiert: <code>export class FooComponent {}</code>. In manchen F√§llen kann es sinnvoll sein, stattdessen einen <em>Default Export</em> zu verwenden (<code>export default class FooComponent {}</code>), z. B. f√ºr eine verk√ºrzte Schreibweise beim Lazy Loading von Komponenten. Beim Anlegen einer Komponente mit der Angular CLI k√∂nnen wir nun auch einen Default Export generieren lassen: <code>ng g c foo --export-default</code>. (siehe <a href=\"https://github.com/angular/angular-cli/commit/a381a3db187f7b20e5ec8d1e1a1f1bd860426fcd\">Commit</a>)</li>\n<li><strong>typeof im Template:</strong> In Template Expressions wird jetzt auch das Schl√ºsselwort <code>typeof</code> unterst√ºtzt. Damit kann der Typ einer Variable direkt gepr√ºft werden, ohne den Umweg √ºber eine Methode der Komponente zu gehen: <code>@if (typeof foo === &#39;string&#39;) {}</code>. (siehe <a href=\"https://github.com/angular/angular/commit/0c9d721ac157662b2602cf0278ba4b79325f6882\">Commit</a>)</li>\n<li><strong>Ungenutzte Standalone Imports:</strong> Der Angular Language Service (in Visual Studio Code) erkennt ungenutzte Imports in Komponenten. Ein Hinweis erscheint, wenn eine Komponente/Pipe/Direktive importiert wird, aber nicht im Template genutzt wird.</li>\n</ul>\n<hr>\n\n\n<p>Wir w√ºnschen Ihnen viel Spa√ü mit Angular 19!\nHaben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>\n<p><strong>Viel Spa√ü w√ºnschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Cala Paquita, Mallorca, Spanien. Foto von Tom Torgau</small></p>\n","meta":{"title":"Angular 19 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2024-11-19T00:00:00.000Z","lastModified":"2024-11-19T00:00:00.000Z","keywords":["Angular","Angular 19","Linked Signal","Resource API","Standalone Components","Effects"],"language":"de","header":{"url":"angular19.jpg","width":2000,"height":960},"sticky":true}}
