{"slug":"2024-11-angular19","html":"<p>Neben grauen Herbsttagen hat der November in Sachen Angular einiges zu bieten: Am 19. November wurde die neue <strong>Major-Version Angular 19</strong> releaset!\nAngular bringt mit der Resource API und dem Linked Signal einige neue Features mit. Standalone Components müssen außerdem nicht mehr explizit als solche markiert werden.\nWir stellen in diesem Blogpost alle wichtigen Neuerungen vor!</p>\n<!-- Im offiziellen [Angular-Blog](TODO) finden Sie alle offiziellen Informationen direkt vom Angular-Team. -->\n\n<p>Für die Migration auf Angular 19 empfehlen wir, den Befehl <code>ng update</code> zu nutzen.\nDetaillierte Infos zu den Schritten liefert der <a href=\"https://angular.dev/update-guide\">Angular Update Guide</a>.</p>\n<h2 id=\"standalone-components-der-neue-standard\">Standalone Components: der neue Standard</h2>\n<p>Standalone Components wurden mit Angular 15 eingeführt und haben sich seitdem zum Standard bei der Komponentenentwicklung mit Angular etabliert.\nNgModules sind damit vollständig optional.\nAb Angular 19 ist es nicht mehr notwendig, eine Standalone Component explizit als solche zu markieren. Das Flag <code>standalone: true</code> in den Metadaten der Komponente entfällt, denn der neue Standardwert ist <code>true</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// vor Angular 19</span>\n<span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-attribute\">selector</span>: <span class=\"hljs-string\">&#x27;app-my&#x27;</span>,\n  <span class=\"hljs-attribute\">templateUrl</span>: <span class=\"hljs-string\">&#x27;./my.component.html&#x27;</span>,\n  <span class=\"hljs-attribute\">standalone</span>: true,\n  <span class=\"hljs-attribute\">imports</span>: []\n})\nexport class MyComponent {}\n</code></pre>\n<pre><code class=\"language-ts\">// ⭐️ ab Angular <span class=\"hljs-number\">19</span>\n<span class=\"hljs-variable\">@Component</span>({\n  selector: <span class=\"hljs-string\">&#x27;app-my&#x27;</span>,\n  templateUrl: <span class=\"hljs-string\">&#x27;./my.component.html&#x27;</span>,\n  imports: []\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{}\n</code></pre>\n<p>Modulbasierte Komponenten müssen nun explizit mit <code>standalone: false</code> markiert werden.\nEine automatische Migration beim Update mit <code>ng update</code> sorgt dafür, dass das Feld <code>standalone</code> korrekt gesetzt wird.</p>\n<p>Wir empfehlen unbedingt, durchgehend auf Standalone Components zu setzen und NgModules nur noch in Ausnahmefällen zu verwenden, wenn es für die Kompatibilität notwendig ist.</p>\n<p>Übrigens: Mit Angular 19 wurde eine neue Compiler-Option eingeführt, die Standalone Components erzwingt. Setzen wir <code>strictStandalone</code> in der Datei <code>tsconfig.json</code>, müssen alle Komponenten im Projekt standalone sein.</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: { /* <span class=\"hljs-string\">...</span> */ },\n  <span class=\"hljs-string\">&quot;angularCompilerOptions&quot;</span>: {\n    <span class=\"hljs-string\">&quot;strictStandalone&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span>\n  }\n}\n</code></pre>\n<p>In einem ausführlichen <a href=\"https://blog.angular.dev/the-future-is-standalone-475d7edbc706\">Blogpost</a> erklärt Alex Rickabaugh vom Angular-Team die Zukunft von NgModules.\nAuch wenn &quot;die Zukunft standalone ist&quot;, bleiben NgModules weiterhin erhalten und werden nicht deprecated.\nProjekte können modulbasierte Komponenten weiterhin verwenden, ein Zwang zum Update besteht nicht.</p>\n<h2 id=\"lokale-variablen-mit-let\">Lokale Variablen mit <code>@let</code></h2>\n<p>Mit dem neuen Schlüsselwort <code>@let</code> können wir lokale Variablen direkt im Template definieren.\nDiese Syntax funktioniert schon seit Angular 18.1, wird mit Angular 19 aber als <em>stable</em> markiert.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-variable\">@let</span> name = expression;\n</code></pre>\n<p>Die Variablen können im Template flexibel eingesetzt werden, aber:\nGeschäftslogik sollte grundsätzlich in der TypeScript-Klasse untergebracht werden und <em>nicht</em> im Template (Trennung von Logik und Darstellung).\nDie <code>@let</code>-Syntax sollte deshalb sparsam eingesetzt werden.</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\">@for (book of books(); track book.isbn) {\n  @let preisBrutto = book.price * 1.19;\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"> – </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">preisBrutto</span> | currency }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n}</span>\n</code></pre>\n<p>Um Daten aus Observables aufzulösen, können wir im Template die AsyncPipe verwenden.\nMithilfe von <code>@let</code> können wir das Ergebnis der AsyncPipe elegant in eine Variable schreiben und anschließend einsetzen:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\">@let book = book$ | async;\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.description</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</code></pre>\n<p>Der Conditional Control Flow (<code>@if</code>) und die Direktive <code>*ngIf</code> bieten seit jeher die Möglichkeit, das Ergebnis der Bedingung in eine lokale Variable zu schreiben:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\">@if (book$ | async; as book) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n}\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book$ | async as book&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span></span>\n</code></pre>\n<p>Falls die Daten aus dem Observable <code>book$</code> zeitverzögert eintreffen oder als optional typisiert sind (<code>Book | undefined</code>), ist die Kombination mit <code>@if</code> der richtige Weg: Das Template soll nur angezeigt werden, wenn tatsächlich Daten vorliegen.\nHäufig wird dieses Muster aber nur eingesetzt, um die Daten in eine Variable zu schreiben, ohne dass die if-Bedingung tatsächlich benötigt wird.\nIn diesem Fall sollte <code>@let</code> verwendet werden.</p>\n<ul>\n<li><code>@if</code> + <code>as</code>: wenn Bedingung geprüft werden muss, bevor die Variable verwendet wird</li>\n<li><code>@let</code>: wenn nur eine Variable benötigt wird</li>\n</ul>\n<h2 id=\"resource-api\">Resource API</h2>\n<p>Mit Angular 19 wurde die <em>experimentelle</em> Resource API vorgestellt.\nDamit können wir intuitiv Daten laden und in Komponenten verarbeiten.\nEine Resource repräsentiert einen Datensatz, der asynchron geladen wird, in der Regel per HTTP.\nDie Resource bietet eine Schnittstelle an, um die Daten zu verarbeiten, neuzuladen und sogar manuell zu überschreiben.</p>\n<p>Eine Resource wird mit der Funktion <code>resource</code> und einer Loader-Funktion initialisiert.\nDieser Loader ist dafür verantwortlich, die Daten asynchron zu laden. Die Funktion muss immer eine Promise zurückgeben: Wir können hier also entweder direkt die native Fetch API verwenden, oder wir wandeln das Observable aus dem <code>HttpClient</code> von Angular mithilfe von <code>firstValueFrom()</code> in eine Promise um:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { resource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\nbooksResource = <span class=\"hljs-title function_\">resource</span>({\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">apiUrl</span> + <span class=\"hljs-string\">&#x27;/books&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-title class_\">Book</span>[]&gt;\n});\n\n<span class=\"hljs-comment\">// bs.getAll() gibt ein Observable&lt;Book[]&gt; zurück</span>\nbooksResource = <span class=\"hljs-title function_\">resource</span>({\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">firstValueFrom</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getAll</span>())\n});\n</code></pre>\n<p>Der Loader wird automatisch ausgeführt, sobald die Resource initialisiert wird.\nUm mit den Daten zu arbeiten, stehen in der Resource drei Signals zur Verfügung: <code>value</code> enthält die Daten, <code>status</code> informiert über den Zustand der Resource, und <code>error</code> liefert ein Fehler-Objekt:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">booksResource.value</span>() | json }}</span><span class=\"language-xml\">\n\n@for(book of booksResource.value(); track book.isbn) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n}</span>\n</code></pre>\n<p>Die Resource bietet uns die Möglichkeit, ohne großen Aufwand einen Ladeindikator anzuzeigen.\nDafür besitzt das Objekt sogar ein eigenes Signal <code>isLoading()</code>:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-keyword\">@if</span> (booksResource.isLoading()) {\n  &lt;<span class=\"hljs-selector-tag\">div</span>&gt;LOADING&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;\n}\n</code></pre>\n<p>Eine Resource kann jederzeit neugeladen werden. Der Loader wird beim Aufruf der Methode <code>reload()</code> erneut ausgeführt, und die geladenen Daten stehen anschließend in <code>value</code> zur Verfügung:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListComponent</span> </span>{\n  booksResource = resource({ <span class=\"hljs-regexp\">/* ... */</span> });\n\n  reloadList() {\n    this.booksResource.reload();\n  }\n}\n</code></pre>\n<p>Außerdem kann der Wert einer Resource jederzeit manuell überschrieben werden.\nDafür besitzt das Signal <code>value</code> die bekannten Methoden <code>set()</code> und <code>update()</code>.\nMit einem Observable oder einem Signal, das durch <code>toSignal()</code> aus einem Observable erstellt wurde, wäre das nicht so einfach möglich.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-title function_\">clearBookList</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksResource</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">set</span>([]);\n}\n</code></pre>\n<p>Die Loader-Funktion kann Parameter verarbeiten. Das ist sinnvoll, wenn der HTTP-Request weitere Informationen benötigt, z. B. die ID des zu ladenden Datensatzes.\nDafür können wir optional einen <code>request</code> definieren: Dieses Signal dient als Trigger für die Loader-Funktion.\nImmer wenn sich der Wert ändert, wird der Loader neu ausgeführt.\nDer Wert des <code>request</code>-Signals steht dann als Argument für den Loader zur Verfügung.</p>\n<p>Immer wenn sich im folgenden Beispiel die ISBN ändert, wird der HTTP-Request für das dazugehörige Buch neu ausgeführt.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> {\n  <span class=\"hljs-keyword\">private</span> bs = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookStoreService</span>);\n  isbn = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  bookResource = <span class=\"hljs-title function_\">resource</span>({\n    <span class=\"hljs-attr\">request</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isbn</span>,\n    <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ request }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getSingle</span>(request)\n  });\n}\n</code></pre>\n<p>Für die Kompatibilität mit Observables aus der Bibliothek RxJS bietet Angular die sogenannte <code>rxResource</code> an.\nSie funktioniert wie <code>resource</code>, aber die Loader-Funktion gibt ein Observable zurück.\nAuf diese Weise können wir Observables aus dem <code>HttpClient</code> direkt verwenden, ohne Umweg über eine Promise:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { rxResource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> ...\n\nbooksResource = rxResource({\n  loader: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.bs.getAll()\n});\n</code></pre>\n<p>Bitte beachten Sie, dass die Resource API experimentell ist und sich die Schnittstelle vor dem finalen Release noch ändern könnte.</p>\n<blockquote>\n<p>📝 Wir erläutern die Resource API ausführlich in einem separaten Blogpost:<br>\n<strong><a href=\"/blog/2024-10-resource-api/\">Neu in Angular 19: Daten laden mit der Resource API</a></strong></p>\n</blockquote>\n<h2 id=\"linked-signals\">Linked Signals</h2>\n<p>Das Linked Signal wurde mit Angular 19 als <em>Developer Preview</em> vorgestellt.\nEs handelt sich um ein Signal, das seinen Wert automatisch auf Basis anderer Signals berechnet – ähnlich wie ein Computed Signal mit <code>computed()</code>.\nDer Unterschied: Der Wert eines Linked Signals kann jederzeit mit den Methoden <code>set()</code> und <code>update()</code> von außen überschrieben werden, so wie wir es von <code>signal()</code> kennen.\nEin Linked Signal vereint also das Beste aus beiden Welten, wie der folgende Vergleich zeigt.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { linkedSignal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\ntimestampMs = signal(<span class=\"hljs-built_in\">Date</span>.<span class=\"hljs-built_in\">now</span>());\n\n<span class=\"hljs-comment\">// Wert des Signals kann überschrieben werden</span>\ntimestampMs.set(<span class=\"hljs-built_in\">Date</span>.<span class=\"hljs-built_in\">now</span>());\ntimestampMs.update(<span class=\"hljs-function\"><span class=\"hljs-params\">ms</span> =&gt;</span> ms + <span class=\"hljs-number\">1000</span>);\n\n<span class=\"hljs-comment\">// computed(): Signal (nicht schreibbar)</span>\nconst timestampSeconds = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> timestampMs() / <span class=\"hljs-number\">1000</span>);\ntimestampSeconds.set(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ❌ Compilation Error</span>\n\n<span class=\"hljs-comment\">// linkedSignal(): WritableSignal (schreibbar)</span>\nconst timestampSecondsLinked = linkedSignal(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> timestampMs() / <span class=\"hljs-number\">1000</span>);\ntimestampSecondsLinked.set(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ✅ funktioniert</span>\n</code></pre>\n<p>Wir können alternativ eine ausführlichere Schreibweise wählen: In einem Optionsobjekt übergeben wir dazu <code>source</code> und <code>computation</code>.\nDer aktuelle Wert des Signals in <code>source</code> wird als Argument an die Computation Function übergeben.\nWelche Schreibweise zu wählen ist, hängt vom Anwendungsfall und Geschmack ab, beide Implementierungen von <code>timestampSecondsLinked</code> führen zum gleichen Ergebnis.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> timestampMs = <span class=\"hljs-keyword\">signal</span><span class=\"hljs-string\"></span>(<span class=\"hljs-built_in\">Date</span>.now());\n\n<span class=\"hljs-keyword\">const</span> timestampSecondsLinked = linkedSignal({\n  <span class=\"hljs-attribute\">source</span>: timestampMs,\n  <span class=\"hljs-attribute\">computation</span>: ms =&gt; ms / <span class=\"hljs-number\">1000</span>\n});\n</code></pre>\n<p>Ein Linked Signal ist besonders nützlich, wenn lokaler State mit dynamisch geladenen Daten synchronisiert werden soll.\nDas Signal berechnet seinen Wert aus einer Quelle, z. B. ein Component Input oder ein HTTP-Request, die Komponente kann das Signal aber weiterhin selbst mit Werten überschreiben.</p>\n<blockquote>\n<p>📝 Wir stellen das Linked Signal ausführlich in einem separaten Blogpost vor. Dort finden Sie mehrere praktische Anwendungsfälle für <code>linkedSignal()</code>:<br>\n<strong><a href=\"/blog/2024-11-linked-signal/\">Neu in Angular 19: LinkedSignal für reaktive Zustandsverwaltung</a></strong></p>\n</blockquote>\n<h2 id=\"migrationen-für-signal-based-apis\">Migrationen für Signal-based APIs</h2>\n<p>Angular hat in den vergangenen Versionen mehrere Komponenten-Schnittstellen auf funktionale Varianten umgestellt.</p>\n<ul>\n<li>Component Inputs mit der Funktion <code>input()</code> liefern die Daten als Signal.</li>\n<li>Querys für ViewChildren und ContentChildren können mit den Funktionen <code>viewChild</code>/<code>viewChildren</code> und <code>contentChild</code>/<code>contentChildren</code> als Signals erfasst werden.</li>\n<li>Component Outputs können mit der Funktion <code>output()</code> definiert werden. Das Ergebnis ist zwar kein Signal, aber die Schnittstelle steht in einer Reihe mit dem neuen <code>input()</code>.</li>\n</ul>\n<p>Bisher wurden dafür Dekoratoren verwendet (z. B. <code>@Input()</code>), die nun nicht mehr notwendig sind.</p>\n<p>Angular bietet Migrationsskripte an, um die Propertys in den Komponenten korrekt auf die neuen Schnittstellen zu migrieren:</p>\n<pre><code class=\"language-bash\"># Updates `@Input` declarations to signal inputs\nng <span class=\"hljs-keyword\">generate</span> @angular/core:signal-<span class=\"hljs-keyword\">input</span>-migration\n\n# Updates query declarations to signal queries\nng <span class=\"hljs-keyword\">generate</span> @angular/core:signal-queries-migration\n\n# Updates @<span class=\"hljs-keyword\">output</span> declarations to the functional equivalent\nng <span class=\"hljs-keyword\">generate</span> @angular/core:<span class=\"hljs-keyword\">output</span>-migration\n</code></pre>\n<p>Für Inputs und Querys (ViewChildren und ContentChildren) gibt es eine kombinierte Migration:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Combines all signals-related migrations into a single migration</span>\n<span class=\"hljs-attribute\">ng</span> generate <span class=\"hljs-variable\">@angular</span>/core:signals\n</code></pre>\n<h2 id=\"signals-schreiben-in-effects\">Signals schreiben in Effects</h2>\n<p>Ein Effect ist eine Funktion, die automatisch ausgeführt wird, wenn eins der darin verwendeten Signals seinen Wert ändert.\nDamit können wir Code ausführen, sobald veränderte Daten vorliegen.</p>\n<pre><code class=\"language-ts\">counter = signal(<span class=\"hljs-number\">0</span>);\ncounter100 = signal(<span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">constructor</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">{\n  effect(() =&gt; {\n    console.log(&#x27;Aktueller Counter-Wert:&#x27;, this.counter());\n\n    // funktionierte bisher nur mit `allowSignalWrites: true`\n    this.counter100.set(this.counter() * 100);\n  }</span>);</span>\n}\n</code></pre>\n<p>Dabei galt bisher die Empfehlung, in Effects keine Werte von Signals zu verändern.\nSollte das doch möglich sein, musste dafür die Option <code>allowSignalWrites</code> gesetzt werden – dann konnte der Effects auch in Signals schreiben.</p>\n<p>Mit Angular 19 entfällt diese Option. In Effects können wir nun ohne zusätzliche Konfiguration die Werte von Signals ändern.\nDiese Richtungsänderung hat das Angular-Team in einem eigenen <a href=\"https://blog.angular.dev/latest-updates-to-effect-in-angular-f2d2648defcd\">Blogpost</a> vorgestellt.\nEs gilt nun nicht mehr als schlechte Praxis, mit Effects weitere Signals zu setzen oder andere Seiteneffekte auszulösen.</p>\n<p>Bitte verwenden Sie Effects grundsätzlich dennoch sparsam! Häufig ist ein Computed Signal oder Linked Signal das bessere Mittel:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-attribute\">counter</span> <span class=\"hljs-operator\">=</span> signal(<span class=\"hljs-number\">0</span>)<span class=\"hljs-comment\">;</span>\n<span class=\"hljs-attribute\">counter100</span> <span class=\"hljs-operator\">=</span> computed(() <span class=\"hljs-operator\">=</span>&gt; this.counter() * <span class=\"hljs-number\">100</span>)<span class=\"hljs-comment\">;</span>\n</code></pre>\n<h2 id=\"afterrendereffect-effects-für-dom-interaktionen\"><code>afterRenderEffect</code>: Effects für DOM-Interaktionen</h2>\n<p>Angular hat bereits vor einiger Zeit die neuen Lifecycle-Funktionen <a href=\"https://next.angular.dev/api/core/afterRender\"><code>afterRender</code></a> und <a href=\"https://next.angular.dev/api/core/afterNextRender\"><code>afterNextRender</code></a> vorgestellt.\nMit Angular 19 kommt nun das signalbasierte Pendant <a href=\"https://next.angular.dev/api/core/afterRenderEffect\"><code>afterRenderEffect</code></a> hinzu.\nDas Besondere an <code>afterRenderEffect</code>: Die Daten zwischen den Render-Phasen werden als Signals ausgetauscht.\nDie Phasen werden nur erneut ausgeführt, wenn sich gebundene Signals geändert haben.\nDOM-Manipulationen werden so auf das nötige Minimum reduziert.</p>\n<p>Alle drei Hilfsmittel sind dafür gedacht, sicher mit dem DOM einer Komponente zu interagieren.\nIn der Regel ist das für normale Geschäftslogik nicht notwendig, weshalb die drei Funktionen eher für Spezialfälle gedacht sind.</p>\n<blockquote>\n<p>📝 Wenn Sie mehr über das geänderte Verhalten von <code>effect()</code> und die neuen Effects von <code>afterRenderEffect()</code> erfahren möchten, empfehlen wir unseren ausführlichen Blogpost dazu:<br>\n<strong><a href=\"https://angular.schule/blog/2024-11-effect-afterrendereffect\">Angular 19: Mastering effect and afterRenderEffect</a></strong></p>\n</blockquote>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Wir empfehlen, regelmäßig einen Blick in den Changelog von <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/main/CHANGELOG.md\">Angular CLI</a> zu werfen.\nNeben den großen neuen Features gibt es auch einige kleinere interessante Neuerungen:</p>\n<ul>\n<li><strong>Zoneless Application generieren:</strong> Mit der Funktion <code>provideExperimentalZonelessChangeDetection()</code> können wir den älteren Mechanismus für die Change Detection auf Basis von Zone.js deaktivieren. Die Change Detection funktioniert dann vollständig mit Signals. Ab Angular 19 können wir diesen Modus bereits bei der Erstellung eines Projekts wählen: <code>ng new --experimental-zoneless</code>. (siehe <a href=\"https://github.com/angular/angular-cli/commit/755f3a07f5fe485c1ed8c0c6060d6d5c799c085c\">Commit</a>)</li>\n<li><strong>Default Export für Komponenten:</strong> Komponenten werden standardmäßig als Named Export generiert: <code>export class FooComponent {}</code>. In manchen Fällen kann es sinnvoll sein, stattdessen einen <em>Default Export</em> zu verwenden (<code>export default class FooComponent {}</code>), z. B. für eine verkürzte Schreibweise beim Lazy Loading von Komponenten. Beim Anlegen einer Komponente mit der Angular CLI können wir nun auch einen Default Export generieren lassen: <code>ng g c foo --export-default</code>. (siehe <a href=\"https://github.com/angular/angular-cli/commit/a381a3db187f7b20e5ec8d1e1a1f1bd860426fcd\">Commit</a>)</li>\n<li><strong>typeof im Template:</strong> In Template Expressions wird jetzt auch das Schlüsselwort <code>typeof</code> unterstützt. Damit kann der Typ einer Variable direkt geprüft werden, ohne den Umweg über eine Methode der Komponente zu gehen: <code>@if (typeof foo === &#39;string&#39;) {}</code>. (siehe <a href=\"https://github.com/angular/angular/commit/0c9d721ac157662b2602cf0278ba4b79325f6882\">Commit</a>)</li>\n<li><strong>Ungenutzte Standalone Imports:</strong> Der Angular Language Service (in Visual Studio Code) erkennt ungenutzte Imports in Komponenten. Ein Hinweis erscheint, wenn eine Komponente/Pipe/Direktive importiert wird, aber nicht im Template genutzt wird.</li>\n</ul>\n<hr>\n\n\n<p>Wir wünschen Ihnen viel Spaß mit Angular 19!\nHaben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß wünschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Cala Paquita, Mallorca, Spanien. Foto von Tom Torgau</small></p>\n","meta":{"title":"Angular 19 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2024-11-19T00:00:00.000Z","lastModified":"2024-11-19T00:00:00.000Z","keywords":["Angular","Angular 19","Linked Signal","Resource API","Standalone Components","Effects"],"language":"de","header":{"url":"angular19.jpg","width":2000,"height":960},"sticky":true}}
