{"slug":"2024-10-resource-api","html":"<p>Eine interessante Neuerung mit Angular 19 ist die <em>Resource API</em>. Damit können wir intuitiv Daten laden und in Komponenten verarbeiten.\nIn diesem Blogartikel stellen wir die Ideen der neuen Schnittstelle vor.</p>\n<blockquote>\n<p>⚠️ Bitte beachten Sie, dass die Resource API mit Angular 19 als <em>experimental</em> veröffentlicht wird. Die Syntax und Semantik der API können sich noch ändern.</p>\n</blockquote>\n<p>Eine Resource repräsentiert einen Datensatz, der asynchron geladen wird. Dabei geht es in der Regel um HTTP-Requests, die Daten von einem Server abrufen. Die Resource geht allerdings einen Schritt weiter als nur einen einfachen HTTP-Request auszuführen: Die Daten können jederzeit neu geladen oder sogar manuell überschrieben werden. Außerdem bietet die Resource eigenständig Informationen zum Ladestatus an. Alle Informationen und Daten werden als Signals ausgegeben, sodass bei Änderungen stets der aktuelle Wert zur Verfügung steht.</p>\n<h2 id=\"was-bisher-geschah-beispiel-ohne-resource\">Was bisher geschah: Beispiel ohne Resource</h2>\n<p>Zur Einführung betrachten wir ein Szenario, das ganz klassisch und ohne die neue Resource API implementiert wird.</p>\n<p>Wir wollen in einer Komponente eine Liste von Büchern anzeigen, die per HTTP von einem Server geladen wird.\nDer dazu passende <code>BookStoreService</code> existiert bereits und wird per Dependency Injection angefordert. Die Methode <code>getAll()</code> im Service nutzt den <code>HttpClient</code> von Angular und gibt ein Observable zurück.</p>\n<p>In der Komponente benötigen wir ein Property <code>books</code>, das die Daten zwischenspeichert, um sie im Template anzuzeigen.\nDas Property wird ganz zeitgemäß mit einem Signal initialisiert.\nIm Konstruktor subscriben wir auf das von <code>getAll()</code> erzeugte Observable. Sobald die Buchliste vom Server eingetroffen ist, schreiben wir die Daten in das Signal <code>books</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookListComponent</span> {\n  <span class=\"hljs-keyword\">private</span> bs = inject(BookStoreService);\n  books = signal&lt;Book[]&gt;([]);\n\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">this</span>.bs.getAll().subscribe(receivedBooks =&gt; {\n      <span class=\"hljs-keyword\">this</span>.books.<span class=\"hljs-keyword\">set</span>(receivedBooks);\n    });\n  }\n}\n</code></pre>\n<p>In der Regel wird es aber nicht bei diesem einfachen Szenario bleiben, sondern weitere Anforderungen kommen hinzu:</p>\n<ul>\n<li><strong>Auf Knopfdruck soll die Buchliste neu geladen werden.</strong> Dazu müssen wir in einer neuen Methode (z. B. <code>reloadList()</code>) den HTTP-Request erneut starten, subscriben, usw. – und somit den Code aus dem Konstruktor duplizieren.</li>\n<li><strong>Es sollen keine parallelen Requests ausgeführt werden.</strong> Wenn die Daten neu geladen werden sollen, während noch ein vorheriger Request läuft, soll dieser entweder abgebrochen werden oder der neue Request soll ignoriert werden.</li>\n<li><strong>Es soll ein Ladeindikator angezeigt werden.</strong> Dafür könnten wir ein Property <code>loading</code> einführen, das wir an den richtigen Stellen im Code auf <code>true</code> oder <code>false</code> setzen, um den Zustand zu erfassen.</li>\n<li><strong>Die Daten sollen lokal verändert/überschrieben werden.</strong> Dazu können wir zwar das Signal mit einem neuen Wert setzen – wir wissen aber anschließend nicht mehr, ob der aktuelle Wert lokal gesetzt oder vom Server geladen wurde.</li>\n<li><strong>Die Subscription soll beendet werden, wenn die Komponente zerstört wird.</strong> Dafür können wir z. B. den Operator <a href=\"https://angular.dev/api/core/rxjs-interop/takeUntilDestroyed\"><code>takeUntilDestroyed()</code></a> verwenden oder auf eine andere Lösung mithilfe von RxJS zurückgreifen.</li>\n</ul>\n<p>All diese Aspekte lassen sich selbstverständlich mit moderatem Aufwand implementieren – aber wir müssen immer wieder ähnliche Schritte unternehmen, um zum Ziel zu kommen.\nAnstatt auf imperativen Stil zu setzen, wie in unserem Beispiel, können wir auch die Möglichkeiten der Bibliothek RxJS nutzen. Der Kern des Problems bleibt aber erhalten: Es ist vergleichsweise viel Aufwand nötig, um wiederkehrende alltägliche Aufgaben umzusetzen.</p>\n<p>Die neue Resource API soll diese Lücke schließen!</p>\n<h2 id=\"die-neue-resource-api\">Die neue Resource API</h2>\n<p>Eine Resource repräsentiert einen Datensatz, der mithilfe eines Loaders geladen wird.\nZur Initialisierung verwenden wir die Funktion <code>resource()</code>.\nDer hier übergebene Loader ist eine Funktion, die das asynchrone Laden der Daten durchführt.\nDieser Loader wird übrigens sofort ausgeführt, sobald die Resource initialisiert wird.</p>\n<p>In der Dokumentation wird die Resource wie folgt beschrieben:</p>\n<blockquote>\n<p>A Resource is an asynchronous dependency (for example, the results of an API call) that is managed and delivered through signals.\n[It] projects a reactive request to an asynchronous operation defined by a loader function, which exposes the result of the loading operation via signals.</p>\n</blockquote>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { resource } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\nmyResource = resource({\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-comment\">/* Daten laden */</span>\n});\n</code></pre>\n<p>Interessanterweise erwartet der Loader zwingend eine Promise als Rückgabewert. Grundsätzlich spricht zwar nichts dagegen, dieses native Modell des Browsers zu verwenden. Bisher wurden jedoch in Angular bei asynchronen Operationen üblicherweise Observables und die Bibliothek RxJS eingesetzt.\nAngular bricht hier also bewährte Prinzipien und setzt stattdessen auf das native Konstrukt des Browsers.</p>\n<p>Um mit der Resource also einen HTTP-Request durchzuführen, gibt es drei Möglichkeiten:</p>\n<ul>\n<li>1.) Wir verwenden einen HTTP-Client, der Promises zurückgibt, z. B. das native <code>fetch()</code> oder die Bibliothek <code>axios</code>.</li>\n<li>2.) Wir verwenden die Funktion <code>firstValueFrom()</code> aus der Bibliothek RxJS. Sie wandelt ein Observable in eine Promise um, die das erste Element des Datenstroms ausgibt.</li>\n<li>3.) Wir verwenden eine <code>rxResource</code>, die ein Observable als Loader verwendet. Dazu später mehr!</li>\n</ul>\n<h3 id=\"variante-1-promises-und-die-native-fetch-api\">Variante 1: Promises und die native Fetch API</h3>\n<p>Im <code>BookStoreService</code> verwenden wir die native Fetch API, sodass die Methode <code>getAll()</code> eine Promise zurückgibt. Im Loader können wir diese Promise direkt verwenden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStoreService</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  getAll(): Promise&lt;Book[]&gt; {\n    <span class=\"hljs-keyword\">return</span> fetch(<span class=\"hljs-keyword\">this</span>.apiUrl + <span class=\"hljs-string\">&#x27;/books&#x27;</span>).then(res =&gt; res.json());\n  }\n}\n</code></pre>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Komponente</span>\nbooksResource = resource({\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.bs.getAll()\n});\n</code></pre>\n<h3 id=\"variante-2-observables-und-der-httpclient-von-angular\">Variante 2: Observables und der <code>HttpClient</code> von Angular</h3>\n<p>Wir verwenden wie üblich den <code>HttpClient</code> von Angular, sodass die Methode <code>getAll()</code> ein Observable zurückgibt.\nUm den Loader zu definieren, müssen wir das Observable mithilfe von <code>firstValueFrom()</code> in eine Promise umwandeln.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStoreService</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  getAll(): Observable&lt;Book[]&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.http.<span class=\"hljs-keyword\">get</span>&lt;Book[]&gt;(<span class=\"hljs-keyword\">this</span>.apiUrl + <span class=\"hljs-string\">&#x27;/books&#x27;</span>);\n  }\n}\n</code></pre>\n<pre><code class=\"language-ts\">// Komponente\nbooksResource = resource({\n  loader: () =&gt; firstValueFrom(<span class=\"hljs-name\">this</span>.bs.getAll())\n})<span class=\"hljs-comment\">;</span>\n</code></pre>\n<h2 id=\"auf-die-daten-zugreifen\">Auf die Daten zugreifen</h2>\n<p>Der Loader wird sofort ausgeführt, sobald das Resource-Objekt initialisiert wird. Die Resource verarbeitet die Antwort und bietet folgende Signals an, um mit den Daten zu arbeiten:</p>\n<ul>\n<li><code>value</code>: geladene Daten, hier <code>Book[]</code></li>\n<li><code>status</code>: Zustand der Resource vom Typ <code>ResourceStatus</code>, z. B. <em>Resolved</em> oder <em>Loading</em>, siehe nächster Abschnitt</li>\n<li><code>error</code>: Fehler</li>\n</ul>\n<p>Die geladenen Bücher können wir also wir folgt im Template anzeigen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">booksResource.value</span>() | json }}</span><span class=\"language-xml\">\n\n@for(book of booksResource.value(); track book.isbn) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n}</span>\n</code></pre>\n<h2 id=\"status-der-resource\">Status der Resource</h2>\n<p>Mithilfe des Signals <code>status</code> können wir den Zustand der Resource auswerten, z. B. um einen Ladeindikator anzuzeigen. Alle Werte von <code>status</code> sind Felder aus dem <a href=\"https://next.angular.dev/api/core/ResourceStatus\">Enum <code>ResourceStatus</code></a>:</p>\n<table>\n<thead>\n<tr>\n<th>Status aus <code>ResourceStatus</code></th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Idle</code></td>\n<td>Es ist kein Request definiert und es wird nichts geladen. <code>value()</code> ist <code>undefined</code>.</td>\n</tr>\n<tr>\n<td><code>Error</code></td>\n<td>Das Laden ist fehlgeschlagen. <code>value()</code> ist <code>undefined</code>.</td>\n</tr>\n<tr>\n<td><code>Loading</code></td>\n<td>Die Resource lädt gerade.</td>\n</tr>\n<tr>\n<td><code>Reloading</code></td>\n<td>Die Resource lädt gerade neu, nachdem das Neuladen mit <code>reload()</code> angefordert wurde.</td>\n</tr>\n<tr>\n<td><code>Resolved</code></td>\n<td>Das Laden ist abgeschlossen.</td>\n</tr>\n<tr>\n<td><code>Local</code></td>\n<td>Der Wert wurde lokal überschrieben.</td>\n</tr>\n</tbody></table>\n<p>Für einen Ladeindikator könnten wir den Zustand z. B. in einem Computed Signal verarbeiten und ein Boolean zurückgeben, wenn die Resource gerade lädt:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { resource, computed, ResourceStatus } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> ...\n\nisLoading = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.booksResource.status() === ResourceStatus.Loading);\n</code></pre>\n<pre><code class=\"language-html\"><span class=\"hljs-keyword\">@if</span> (isLoading()) {\n  &lt;<span class=\"hljs-selector-tag\">div</span>&gt;LOADING&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;\n}\n</code></pre>\n<p>Damit alle Fälle erfasst werden, müssen wir hier aber auch den Zustand <code>Reloading</code> berücksichtigen.\nMit dem mitgelieferten Property <code>isLoading</code> ist das schnell gelöst: Dieses Signal gibt <code>true</code> aus, wenn sich die Resource im Zustand <code>Loading</code> oder <code>Reloading</code> befindet:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-keyword\">@if</span> (booksResource.isLoading()) {\n  &lt;<span class=\"hljs-selector-tag\">div</span>&gt;LOADING&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;\n}\n</code></pre>\n<h2 id=\"resource-neu-laden\">Resource neu laden</h2>\n<p>Eine Resource besitzt die Methode <code>reload()</code>.\nBeim Aufruf wird intern die Loader-Funktion erneut ausgeführt, und die Daten werden neu geladen.\nDas Ergebnis steht anschließend wieder im Signal <code>value</code> zur Verfügung.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">&quot;reloadList()&quot;</span>&gt;</span>Reload book list<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListComponent</span> </span>{\n  booksResource = resource({ <span class=\"hljs-regexp\">/* ... */</span> });\n\n  reloadList() {\n    this.booksResource.reload();\n  }\n}\n</code></pre>\n<p>Die Resource stellt sicher, dass stets nur ein einziger Request gleichzeitig ausgeführt wird.\nDas Neuladen ist erst möglich, wenn der vorherige Ladevorgang abgeschlossen ist.\nDieses Verhalten kann man im <a href=\"https://github.com/angular/angular/blob/19.0.0-next.11/packages/core/src/resource/resource.ts#L170-L176\">Quellcode von Angular</a> gut nachvollziehen.</p>\n<h2 id=\"wert-lokal-überschreiben\">Wert lokal überschreiben</h2>\n<p>Die Resource bietet die Möglichkeit, den Wert lokal zu überschreiben.\nDas Signal <code>value</code> ist ein <code>WritableSignal</code> und bietet die bekannten Methoden <code>set()</code> und <code>update()</code> an.</p>\n<p>Wir wollen die Buchliste lokal sortieren, z. B. auf Knopfdruck mit Sortierung nach dem Rating der Bücher.\nIn der Methode können wir nach erfolgter Sortierung den Wert des Signals <code>value</code> direkt überschreiben.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookListComponent</span> {\n  booksResource = <span class=\"hljs-title function_\">resource</span>({ <span class=\"hljs-comment\">/* ... */</span> });\n\n  <span class=\"hljs-title function_\">sortBookListLocally</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> currentBookList = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksResource</span>.<span class=\"hljs-title function_\">value</span>();\n\n    <span class=\"hljs-keyword\">if</span> (currentBookList) {\n      <span class=\"hljs-keyword\">const</span> sortedList = currentBookList.<span class=\"hljs-title function_\">toSorted</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> b.<span class=\"hljs-property\">rating</span> - a.<span class=\"hljs-property\">rating</span>);\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksResource</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">set</span>(sortedList);\n    }\n  }\n}\n</code></pre>\n<p>Wir möchten auf zwei Besonderheiten in diesem Code hinweisen:</p>\n<ul>\n<li>Das Signal <code>value</code> liefert den Typ <code>T | undefined</code>, in unserem Fall also <code>Book[] | undefined</code>. Solange die Daten noch nicht geladen wurden, ist der Wert also <code>undefined</code>. Deshalb ist hier eine Prüfung nötig, ob <code>currentBookList</code> überhaupt existiert. Es wäre wünschenswert, wenn man der Resource einen Startwert übergeben kann, sodass <code>undefined</code> entfällt.</li>\n<li>Anstelle von <code>Array.sort()</code> verwenden wir die neue Methode <code>Array.toSorted()</code>, die das Array unverändert lässt und eine sortierte Kopie zurückgibt. So bleibt die Immutability gewahrt. <code>toSorted()</code> kann nur verwendet werden, wenn die Option <code>lib</code> in der <code>tsconfig.json</code> mindestens den Eintrag <code>ES2023</code> enthält – aktuell ist das in neuen Angular-Projekten noch nicht der Fall.</li>\n</ul>\n<h2 id=\"request-loader-mit-parameter\"><code>request</code>: Loader mit Parameter</h2>\n<p>Unsere Anwendung soll eine Detailseite besitzen, auf der immer genau ein Buch angezeigt wird.\nFür den HTTP-Request muss also die Information übergeben werden, welches Buch jeweils geladen werden soll.\nBeim Wechsel auf eine andere Detailseite soll das Laden erneut angestoßen werden – aber für ein anderes Buch.</p>\n<p>Der Loader muss also mit Parametern arbeiten können.\nDazu gehen wir davon aus, dass die Komponente ein Input-Property <code>isbn</code> besitzt, über das die aktuelle ISBN stets verfügbar ist.</p>\n<p>Im Loader könnten wir nun das Signal <code>this.isbn</code> verwenden, um die ISBN an den Service zu übergeben:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookDetailsComponent</span> </span>{\n  isbn = input.<span class=\"hljs-keyword\">required</span>&lt;string&gt;();\n\n  bookResource = resource({\n    <span class=\"hljs-comment\">// ACHTUNG: Wird nur einmalig ausgeführt!</span>\n    loader: () =&gt; <span class=\"hljs-keyword\">this</span>.bs.getSingle(<span class=\"hljs-keyword\">this</span>.isbn())\n  });\n}\n</code></pre>\n<p>Dieser Code funktioniert grundlegend – aber nur ein einziges Mal! Die Loader-Funktion ist <em>untracked</em>. Das bedeutet, dass der Loader bei einer Änderung der darin verwendeten Signals nicht erneut ausgeführt wird (wie es bei <code>effect()</code> oder <code>computed()</code> der Fall wäre).</p>\n<p>Um dieses Problem zu lösen, können wir das Property <code>request</code> verwenden: Hier übergeben wir ein Signal. Immer wenn dieses Signal seinen Wert ändert, wird der Loader automatisch neu ausgeführt.</p>\n<p>Der Request stellt also die Parameter bereit, mit denen der Loader ausgeführt wird.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> {\n  isbn = input.required&lt;string&gt;();\n\n  bookResource = resource({\n    request: <span class=\"hljs-keyword\">this</span>.isbn,\n    loader: () =&gt; <span class=\"hljs-keyword\">this</span>.bs.getSingle(<span class=\"hljs-keyword\">this</span>.isbn())\n  });\n}\n</code></pre>\n<p>Um den Loader nun etwas generischer und wiederverwendbarer zu gestalten, können wir auf die direkte Verwendung von <code>this.isbn()</code> verzichten.\nDer Rückgabewert von <code>request</code> wird praktischerweise als Argument an die Loader-Funktion übergeben.\nAuf diese Weise könnte man den Loader auch in eine separate Funktion auslagern und in anderen Resources erneut einsetzen.</p>\n<p>Der Loader erhält automatisch ein Argument vom Typ <code>ResourceLoaderParams</code>, das ein Property <code>request</code> besitzt. Darin befindet sich in unserem Beispiel die ISBN, die vom Request zurückgegeben wird.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> {\n  isbn = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  bookResource = <span class=\"hljs-title function_\">resource</span>({\n    <span class=\"hljs-attr\">request</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isbn</span>,\n    <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ request }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getSingle</span>(request)\n  });\n}\n</code></pre>\n<blockquote>\n<p><strong>Routenparameter mit Component Input Binding:</strong> Damit das Input-Property <code>isbn</code> automatisch mit der aktuellen ISBN aus dem Routenparameter befüllt wird, können wir die Funktionalität <a href=\"https://netbasal.com/binding-router-information-to-routed-component-inputs-in-angular-78ee92f63e64\"><em>Component Input Binding</em></a> des Routers nutzen.</p>\n</blockquote>\n<h2 id=\"rxresource-resource-mit-observables\"><code>rxResource</code>: Resource mit Observables</h2>\n<p>In allen bisherigen Beispielen haben wir die Loader-Funktion mithilfe von Promises implementiert. Die Fetch API des Browsers gibt eine Promise zurück, und die Funktion <code>firstValueFrom()</code> aus der Bibliothek RxJS hat uns geholfen, eine Promise aus dem Observable zu erstellen, das der <code>HttpClient</code> von Angular erzeugt.</p>\n<p>Auch wenn Angular durch die Einführung von Signals an vielen Stellen nicht mehr direkt auf Observables setzt, haben die Möglichkeiten der reaktiven Programmierung mit RxJS für viele Szenarien weiterhin ihre Berechtigung.\nAngular bietet deshalb die Funktion <code>rxResource</code> an. Sie funktioniert genauso wie <code>resource</code>, die Loader-Funktion gibt allerdings ein Observable zurück.\nWir können die Observables aus dem <code>HttpClient</code> auf diese Weise also direkt verwenden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStoreService</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  getAll(): Observable&lt;Book[]&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.http.<span class=\"hljs-keyword\">get</span>&lt;Book[]&gt;(<span class=\"hljs-keyword\">this</span>.apiUrl + <span class=\"hljs-string\">&#x27;/books&#x27;</span>);\n  }\n}\n</code></pre>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { rxResource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> ...\n\nbooksResource = rxResource({\n  loader: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.bs.getAll()\n});\n</code></pre>\n<h2 id=\"laufende-requests-abbrechen\">Laufende Requests abbrechen</h2>\n<p>Die Resource bietet die Möglichkeit, einen laufenden Request abzubrechen, sobald ein neuer gestartet wird.\nBesonders bei Loadern mit Parameter (in unserem Beispiel die ISBN auf der Detailseite) ist es wichtig, dass nur der zuletzt angefragte Datensatz verarbeitet wird.</p>\n<p>Die <code>rxResource</code> verwaltet diese Mechanik ganz eigenständig, denn ein Observable stellt eine direkte Schnittstelle zum Abbrechen des Requests bereit.</p>\n<p>Für einen Loader auf Basis von Promises ist das Beenden etwas komplizierter.\nDer Loader erhält in seinem Parameter-Objekt auch ein sogenanntes <code>AbortSignal</code>.\nDas ist ein natives Objekt des Browsers, das Auskunft gibt, wann der Request beendet werden soll.</p>\n<p>Zusammen mit der nativen Fetch API lässt sich dieses Objekt direkt verwenden.\nLiegt in <code>this.isbn</code> eine neue ISBN vor, während der Loader noch lädt, wird der laufende Fetch Request abgebrochen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> {\n  isbn = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  bookResource = <span class=\"hljs-title function_\">resource</span>({\n    <span class=\"hljs-attr\">request</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isbn</span>,\n    <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ abortSignal }</span>) =&gt;</span> <span class=\"hljs-title function_\">fetch</span>(\n      detailsUrl + <span class=\"hljs-string\">&#x27;/&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isbn</span>(),\n      <span class=\"hljs-attr\">signal</span>: abortSignal\n    )\n  });\n}\n</code></pre>\n<p>Nutzen wir den <code>HttpClient</code> von Angular und die Funktion <code>firstValueFrom</code>, ist das Beenden sehr umständlich – wir müssten das <code>AbortSignal</code> in ein Observable umwandeln, um den Operator <code>takeUntil</code> zum Beenden des Datenstroms einzusetzen. In diesem Fall empfehlen wir unbedingt, die <code>rxResource</code> zu verwenden.</p>\n<p>Übrigens sorgt die Resource auch dafür, dass beim Beenden der Komponente der laufende Request gestoppt wird.</p>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Mit der neuen Resource API bietet Angular eine intuitive und gut integrierte Schnittstelle an, um Daten vom Server zu laden.\nAnwendungsfälle, die über einen einfachen HTTP-Request hinausgehen, insbesondere wiederholtes Laden und Anzeige eines Ladeindikators, können mit der Resource schnell umgesetzt werden.\nBisher war dafür viel manueller Aufwand nötig.</p>\n<p>Wir begrüßen, dass Angular hier ein häufiges Alltagsproblem adressiert. Die Lösung deckt die meisten Anwendungsfälle zuverlässig ab und sorgt für eine standardisierte Herangehensweise – nur bei Anforderungen, die über die gegebenen Funktionen hinausgehen, wird künftig eine eigene Implementierung notwendig sein.</p>\n<p>Damit macht Angular einen weiteren Schritt, um Signals im Framework zu etablieren. Die Notwendigkeit, RxJS und Observables für einfache Aufgaben zu verwenden, wird weiter reduziert.</p>\n<p>Die Resource API ist in Angular 19 ein experimenteller Baustein! Die Schnittstelle und das Verhalten können sich noch ändern, und es können Bugs auftreten.\nBitte probieren Sie das neue Tool trotzdem schon einmal aus! Das Feedback aus der Community ist wichtig, um die Schnittstelle vor dem finalen Release noch weiter zu verbessern.</p>\n<p>Fraglich ist, welche Rolle der <code>HttpClient</code> von Angular in Zukunft spielen wird. Mit dem Einsatz von Promises ermutigt Angular, für HTTP-Kommunikation auf die native Fetch API zu setzen. Wünschenswert wäre, dass der <code>HttpClient</code> und die neue Resource nahtlos miteinander arbeiten. Denkbar wäre beispielsweise, dass der <code>HttpClient</code> direkt eine Resource zurückgibt, ohne den sichtbaren Umweg über ein Observable oder eine Promise zu gehen.\nDie neue Schnittstelle ist aber aus unserer Sicht eine gute Basis – und wir sind gespannt, was in Zukunft folgt!</p>\n<hr>\n<small>Vielen Dank an Johannes Hoppe und Danny Koppenhagen für Review und Feedback.</small>\n\n<p><small><strong>Titelbild:</strong> Foto von <a href=\"https://unsplash.com/de/@thepaintedsquarejessica\">Jessica Lewis 🦋 thepaintedsquare</a> auf <a href=\"https://unsplash.com/de/fotos/geschnittene-erdbeeren-auf-blaugrunem-keramikteller-15nvaBz_doc\">Unsplash</a> (bearbeitet)\n  </small></p>\n","meta":{"title":"Neu in Angular 19: Daten laden mit der Resource API","author":"Ferdinand Malcher","mail":"ferdinand@malcher.media","published":"2024-10-29T00:00:00.000Z","lastModified":"2024-11-07T00:00:00.000Z","keywords":["Resource API","Promise","Observable","resource","rxResource","Fetch API"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2024-10-resource-api/header-resource-api.jpg"}}
