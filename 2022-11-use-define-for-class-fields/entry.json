{"slug":"2022-11-use-define-for-class-fields","html":"<p>Wussten Sie bereits, dass Propertys in JavaScript und TypeScript leicht unterschiedlich implementiert sind und es ein inkompatibles Verhalten gibt?\nIn Projekten mit Angular 15 wird deshalb in der TypeScript-Konfiguration die Option <code>useDefineForClassFields</code> gesetzt.\nWir zeigen Ihnen, was es damit auf sich hat und wie Sie Ihren Code schreiben m√ºssen, damit er zukunftssicher in beiden Programmiersprachen gleich funktioniert.</p>\n<h2 id=\"inhalt\">Inhalt</h2>\n<ul>\n<li><a href=\"/blog/2022-11-use-define-for-class-fields#propertys-initialisieren-mit-typescript\">Propertys initialisieren mit TypeScript</a></li>\n<li><a href=\"/blog/2022-11-use-define-for-class-fields#das-propriet%C3%A4re-verhalten-von-typescript\">Das propriet√§re Verhalten von TypeScript</a></li>\n<li><a href=\"/blog/2022-11-use-define-for-class-fields#propertys-zukunftssicher-initialisieren\">Propertys zukunftssicher initialisieren</a></li>\n<li><a href=\"/blog/2022-11-use-define-for-class-fields#auswirkungen-auf-bestehenden-angular-code\">Auswirkungen auf bestehenden Angular-Code</a></li>\n</ul>\n<blockquote>\n<p><strong>üá¨üáß This article is available in English language here: <a href=\"https://angular.schule/blog/2022-11-use-define-for-class-fields\">TypeScript: useDefineForClassFields ‚Äì How to avoid future Breaking Changes</a></strong></p>\n</blockquote>\n<h2 id=\"propertys-initialisieren-mit-typescript\">Propertys initialisieren mit TypeScript</h2>\n<p>Bei der Arbeit mit Angular initialisieren wir regelm√§√üig Propertys in unseren Klassen.\nEin Klassen-Property kann z. B. direkt bei der Deklaration mit einem Wert initialisiert werden.\nAu√üerdem gibt es eine Kurzschreibweise, mit der wir Propertys uÃàber den Konstruktor automatisch deklarieren k√∂nnen. \nDiese Kurzform verwendet man in Angular, um Abh√§ngigkeiten mittels Dependency Injection anzufordern.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> </span>{\n  // direkte Initialisierung\n  age = <span class=\"hljs-number\">25</span>;\n\n  <span class=\"hljs-regexp\">//</span> Kurzform\n  constructor(private currentYear: number) {}\n}\n</code></pre>\n<h2 id=\"das-propriet√§re-verhalten-von-typescript\">Das propriet√§re Verhalten von TypeScript</h2>\n<p>Diese beiden zuvor gezeigten Schreibweisen sind propriet√§re Features von TypeScript und existieren schon seit den fr√ºhesten Versionen der Sprache.\nDie Programmiersprache JavaScript bzw. der Standard ECMAScript unterst√ºtzte damals solche Klassen-Propertys nicht vollst√§ndig, da die Standardisierung noch nicht abgeschlossen war.\nBeim Design der Propertys von TypeScript ging man nach bestem Wissen und Gewissen davon aus, dass die gew√§hlte Implementierung exakt das Verhalten einer zuk√ºnftigen Version von JavaScript nachahmen w√ºrde.\nDas hat leider nicht ganz funktioniert ‚Äì die Standardisierung in ECMAScript ist √ºber die Jahre einen anderen Weg gegangen.</p>\n<p>Die originalen Klassen-Propertys von TypeScript sind so implementiert, dass die Initialisierung mit Werten immer als erste Anweisung im Konstruktor durchgef√ºhrt wird.\nDie beiden folgenden Schreibweisen waren bislang im Ergebnis absolut identisch:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> </span>{\n  age = <span class=\"hljs-number\">25</span>;\n}\n\n// ist in TypeScript exakt das gleiche wie:\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> </span>{\n  age: number;\n\n  constructor() {\n    this.age = <span class=\"hljs-number\">25</span>;\n  }\n}\n</code></pre>\n<p>In JavaScript verhalten sich die nativen Klassen-Propertys leider etwas anders:\nEs ist m√∂glich, zun√§chst die Propertys zu initialisieren und erst <em>danach</em> den Konstruktor auszuf√ºhren.\nEs handelt sich in JavaScript also um zwei voneinander unabh√§ngige Schritte ‚Äì bei der propriet√§ren Implementierung von TypeScript geschieht die Initialisierung der Propertys hingegen immer zusammen mit dem Aufruf des Konstruktors.</p>\n<p>Diese Diskrepanz zwischen TypeScript und JavaScript ist sehr unsch√∂n, da TypeScript als Obermenge so weit wie m√∂glich mit JavaScript kompatibel bleiben sollte.\nUm die beiden Programmiersprachen wieder einander anzugleichen, hat das TypeScript-Team den Schalter <code>useDefineForClassFields</code> eingefuÃàhrt.\nSobald das Target von TypeScript auf <code>ES2022</code> gesetzt wird, steht diese Option standardm√§√üig auf <code>true</code>.\nEs wird dadurch im Kompilat die native Implementierung von JavaScript verwendet, und die Propertys verhalten sich im Detail leicht anders als zuvor.\nDer folgende Code hat ‚Äì je nach Einstellung ‚Äì zwei unterschiedliche Ausgaben:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span> {\n  age = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">currentYear</span> - <span class=\"hljs-number\">1998</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">currentYear</span>: <span class=\"hljs-built_in\">number</span></span>) {\n    <span class=\"hljs-comment\">// useDefineForClassFields: false --&gt; Current age: 25</span>\n    <span class=\"hljs-comment\">// useDefineForClassFields: true --&gt; Current age: NaN</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Current age:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-number\">2023</span>);\n</code></pre>\n<p>Mit dem alten propriet√§ren Verhalten von TypeScript (<code>useDefineForClassFields: false</code>) wird ein Alter von <code>25</code> berechnet, sofern man den Konstruktor der Klasse mit dem Wert <code>2023</code> aufruft.\nDer Code hat den folgenden Ablauf:</p>\n<ol>\n<li>Der Konstruktor wird mit dem aktuellen Jahr aufgerufen.</li>\n<li>Der Wert f√ºr das aktuelle Jahr wird dem Property <code>currentYear</code> zugewiesen.</li>\n<li>Anschlie√üend wird das Property <code>age</code> initialisiert, wobei zur Berechnung alle Werte zur Verf√ºgung stehen.</li>\n<li>Auf der Konsole erscheint: <code>Current age: 25</code>.</li>\n</ol>\n<p>Setzen wir die Option <code>useDefineForClassFields</code> in der Datei <code>tsconfig.json</code> hingegen auf <code>true</code>, erhalten wir als Ergebnis <code>NaN</code>, was f√ºr <code>Not a Number</code> steht.\nDer Code folgt dann einem anderen Ablauf:</p>\n<ol>\n<li>Das Property <code>age</code> wird als Erstes initialisiert, wobei zur Berechnung nicht alle Werte zur Verf√ºgung stehen: Zu diesem Zeitpunkt ist das Property <code>currentYear</code> noch <code>undefined</code>, sodass die Subtraktion kein g√ºltiges Ergebnis liefern kann.</li>\n<li>Anschlie√üend wird der Konstruktor mit dem aktuellen Jahr aufgerufen.</li>\n<li>Der Wert wird dem Property <code>currentYear</code> zugewiesen.</li>\n<li>Auf der Konsole erscheint: <code>Current age: NaN</code>.</li>\n</ol>\n<p>Sie k√∂nnen das unterschiedliche Verhalten in diesem Stackblitz-Beispiel gerne selbst nachvollziehen:<br><strong><a href=\"https://stackblitz.com/edit/angular-buch-usedefineforclassfields?file=src%2Fapp%2Fapp.component.ts,tsconfig.json\">üëâ Demo auf Stackblitz: useDefineForClassFields</a></strong></p>\n<h2 id=\"propertys-zukunftssicher-initialisieren\">Propertys zukunftssicher initialisieren</h2>\n<p>Den zuvor gezeigten Quelltext wollen wir verbessern, sodass er unabh√§ngig von der jeweiligen Einstellung funktioniert.\nDazu f√ºhren wir die Initialisierung des Propertys explizit als erste Zeile im Konstruktor durch:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span>  {\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-built_in\">number</span>;\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">currentYear</span>: <span class=\"hljs-built_in\">number</span></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">currentYear</span> - <span class=\"hljs-number\">1998</span>;\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Current age:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-number\">2023</span>);\n</code></pre>\n<p>Durch diese Schreibweise ist es egal, ob das propriet√§re Verhalten von TypeScript oder das standardisierte Verhalten von JavaScript aktiv ist.\nEs wird immer das korrekte Ergebnis angezeigt.</p>\n<p>Nat√ºrlich f√ºhrt man in realen Projekten eher selten Arithmetik √ºber Propertys durch.\nIm Entwicklungsalltag mit Angular ist vor allem dann Vorsicht geboten, wenn wir einen Service innerhalb der Property-Initialisierung verwenden wollen.\nDiese Schreibweise birgt die Gefahr, zuk√ºnftig nicht mehr zu funktionieren:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ‚ö†Ô∏è ACHTUNG: Dieser Code ist nicht zukunftssicher! ‚ö†Ô∏è</span>\n\n<span class=\"hljs-meta\">@Component({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-comment\">// this.myService k√∂nnte undefined sein!</span>\n  <span class=\"hljs-keyword\">data</span> = <span class=\"hljs-keyword\">this</span>.myService.getData();\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-keyword\">private</span> myService: MyDataService) { }\n}\n</code></pre>\n<p>Um das Problem zu umgehen, sollten wir die Initialisierung grunds√§tzlich im Konstruktor durchf√ºhren.\nSo ist unser Code zukunftssicher:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-keyword\">data</span>: Data;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-keyword\">private</span> myService: MyDataService) {\n    <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">data</span> = <span class=\"hljs-keyword\">this</span>.myService.getData();\n  }\n}\n</code></pre>\n<p>Alternativ ist es m√∂glich, die Abh√§ngigkeit gar nicht √ºber den Konstruktor anzufordern, sondern die Funktion <code>inject()</code> einzusetzen, mit der man ebenso Dependency Injection durchf√ºhren kann.\nBen√∂tigen wir die Serviceinstanz mehrfach, k√∂nnen wir die angeforderte Abh√§ngigkeit in einem Property ablegen und von √ºberall in der Klasse aus verwenden.</p>\n<pre><code class=\"language-ts\">import { inject } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{\n  data = inject(MyDataService).getData();\n  otherService = inject(MyOtherService);\n}\n</code></pre>\n<blockquote>\n<p><strong>Tipp:</strong> Wenn wir bei der direkten Initialisierung von Propertys auf injizierte Services zugreifen wollen, sollten wir</p>\n<ul>\n<li>die Initialisierung im Konstruktor durchf√ºhren oder</li>\n<li>die Funktion <code>inject()</code> verwenden.</li>\n</ul>\n</blockquote>\n<h2 id=\"auswirkungen-auf-bestehenden-angular-code\">Auswirkungen auf bestehenden Angular-Code</h2>\n<p>Die gew√§hlte Einstellung f√ºr <code>useDefineForClassFields</code> hat eine gro√üe Tragweite.\nW√ºrde man den Schalter bei bestehenden Angular-Projekten in der Standardeinstellung belassen, so w√ºrde es mit sehr hoher Wahrscheinlichkeit an vielen Stellen zu Fehlern kommen.\nDaher hat das Angular-Team sowohl f√ºr bestehende als auch f√ºr neue Projekte die Einstellung mit Angular 15 explizit deaktiviert.\nIn der Datei <code>tsconfig.json</code> finden wir dazu die folgenden Angaben:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: {\n    <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span>\n    <span class=\"hljs-string\">&quot;useDefineForClassFields&quot;</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-string\">&quot;target&quot;</span>: <span class=\"hljs-string\">&quot;ES2022&quot;</span>\n  }\n}\n</code></pre>\n<p>Das seit vielen Jahren bekannte propriet√§re Verhalten bleibt also vorerst bestehen.</p>\n<p>√úblicherweise folgt Angular aber den Empfehlungen und Vorgaben von TypeScript.\nSo wurden z. B. in der Vergangenheit die strikten Typpr√ºfungen f√ºr neue Projekte standardm√§√üig aktiviert.\nEs ist davon auszugehen, dass in Angular irgendwann einmal die Einstellung <code>useDefineForClassFields</code> auf den Standardwert <code>true</code> gesetzt wird.\nWir empfehlen Ihnen also, Ihren Code jetzt schon m√∂glichst robust zu entwickeln und bereits heute die Einstellung von <code>useDefineForClassFields</code> auf <code>true</code> zu setzen.\nSollte in Zukunft die Standardeinstellung f√ºr ge√§ndert werden, so sind Sie dann von keinem Breaking Change betroffen!</p>\n<h2 id=\"neue-auflage-des-angular-buchs\">Neue Auflage des Angular-Buchs</h2>\n<p>Wir haben in den letzten Monaten intensiv an einer Neuauflage des deutschsprachigen Angular-Buchs gearbeitet!\nNat√ºrlich haben wir vorsorglich alle Quelltexte im Angular-Buch so geschrieben, dass sie bereits zukunftssicher funktionieren. \nDie Inhalte dieses Blogposts haben wir aus unserem Buch √ºbernommen.\nWenn Sie diesen Text hilfreich fanden, dann sollten Sie unbedingt das neue <a href=\"/kaufen\">Angular-Buch bestellen</a>.</p>\n<div style=\"text-align: center\">\n<img src=\"https://angular-buch.com/assets/img/book-cover-multiple-v4.png\" alt=\"Buchcover 4. Auflage\" style=\"width:500px\">\n</div>\n\n\n\n<hr>\n\n<p><small><strong>Titelbild:</strong> Mols Bjerge Nationalpark, D√§nemark, 2022. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"TypeScript: useDefineForClassFields ‚Äì zuk√ºnftige Breaking Changes vermeiden","author":"Johannes Hoppe und Ferdinand Malcher","mail":"team@angular.schule","published":"2022-11-25T00:00:00.000Z","lastModified":"2022-11-25T00:00:00.000Z","keywords":["Angular","JavaScript","ECMAScript","TypeScript","ES2022","Klassen-Propertys","useDefineForClassFields"],"language":"de","header":{"url":"usedefineforclassfields.jpg","width":2000,"height":881},"sticky":false}}
