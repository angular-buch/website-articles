{"slug":"2025-10-signal-forms-part3","html":"<p>We covered fundamentals and advanced validation patterns of Signal Forms in <a href=\"/blog/2025-10-signal-forms-part1\">Part 1</a> and <a href=\"/blog/2025-10-signal-forms-part2\">Part 2</a> of this blog series.\nIn this final part, we&#39;ll explore more specialized topics that are relevant for large and modular forms: child forms and custom UI controls.\nLast but not least, we&#39;ll have a look at providing a custom <code>SignalFormsConfig</code>.</p>\n<blockquote>\n<p>‚ö†Ô∏è <strong>Experimental Feature:</strong> Signal Forms are currently an experimental feature in Angular. The API and functionality may change in future releases.</p>\n</blockquote>\n<h2 id=\"related-blog-posts\">Related blog posts</h2>\n<p><strong>This blog post is part of our series about Signal Forms:</strong></p>\n<ul>\n<li><a href=\"/blog/2025-10-signal-forms-part1\">Part 1: Getting Started with Signal Forms</a></li>\n<li><a href=\"/blog/2025-10-signal-forms-part2\">Part 2: Advanced Validation and Schema Patterns</a></li>\n<li><em>Part 3: Child Forms, Custom UI Controls and SignalFormsConfig</em> (this post)</li>\n<li><a href=\"/blog/2025-12-signal-forms-part4\">Part 4: Metadata and Accessibility Handling</a></li>\n</ul>\n<h2 id=\"integrating-child-forms\">Integrating Child Forms</h2>\n<p>As forms grow in complexity, it becomes essential to break them down into smaller, reusable components.\nThis modular approach not only enhances code maintainability but also allows to reuse form parts across the application.</p>\n<p>The architectural idea is straightforward: Instead of defining the entire form in a single component, we create child components that contain specific sections of the HTML form.\nThe form and data models still live in the parent component, and the child components receive the relevant parts of the <code>FieldTree</code> via property binding.\nTo separate the data structure and validation logic, we can define individual schemas for each child form and apply them in the parent schema using the <code>apply()</code> function.</p>\n<p>In our registration form example, we want to allow new users to define identity information such as gender and an optional salutation and pronoun when the gender is set to <code>diverse</code>.\nAll these fields should be wrapped in a separate component <code>IdentityForm</code> that we want to use in our main <code>RegistrationForm</code>.</p>\n<h3 id=\"creating-a-child-form-component\">Creating a Child Form Component</h3>\n<p>In our new <code>IdentityForm</code> component, we start by defining the data model and initial state for the identity information.\nInstead of including these directly in the main registration form data model, we define a new interface <code>GenderIdentity</code> that holds the relevant fields.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// identity-form.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">GenderIdentity</span> {\n  <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;&#x27;</span> | <span class=\"hljs-string\">&#x27;male&#x27;</span> | <span class=\"hljs-string\">&#x27;female&#x27;</span> | <span class=\"hljs-string\">&#x27;diverse&#x27;</span>;\n  <span class=\"hljs-attr\">salutation</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// e. g. &quot;Mx.&quot;, &quot;Dr.&quot;, etc.</span>\n  <span class=\"hljs-attr\">pronoun</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// e.‚ÄØg. &quot;they/them&quot;</span>\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialGenderIdentityState</span>: <span class=\"hljs-title class_\">GenderIdentity</span> = {\n  <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n  <span class=\"hljs-attr\">salutation</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n  <span class=\"hljs-attr\">pronoun</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n};\n</code></pre>\n<p>As for every form, we define a schema that holds the validation and visibility logic.\nWe mark the fields for salutation and pronoun as <code>hidden</code> when the selected gender is not <code>diverse</code>.</p>\n<p>Also we want both fields to be required and validated.\nTo apply a schema conditionally, we can use the <code>applyWhen()</code> function as covered in <a href=\"/blog/2025-10-signal-forms-part2\">Part 2</a> of this series.\nHowever, here&#39;s an interesting detail of the <code>required</code> validator: We can add a <code>when</code> property to apply this validation conditionally ‚Äì without the need of using <code>applyWhen()</code>.\nThis way we define that <code>salutation</code> and <code>pronoun</code> are only required when the gender is set to <code>diverse</code>.</p>\n<p>We export the whole schema so that we can use it in the parent <code>RegistrationForm</code> component later and apply it to the main schema.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-regexp\">//</span> identity-form.ts\n<span class=\"hljs-keyword\">export</span> const identitySchema = schema&lt;GenderIdentity&gt;(<span class=\"hljs-function\"><span class=\"hljs-params\">(path)</span> =&gt;</span> {\n  hidden(path.salutation, <span class=\"hljs-function\"><span class=\"hljs-params\">(ctx)</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> !ctx.valueOf(path.gender) || ctx.valueOf(path.gender) !== <span class=\"hljs-string\">&#x27;diverse&#x27;</span>;\n  });\n  hidden(path.pronoun, <span class=\"hljs-function\"><span class=\"hljs-params\">(ctx)</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> !ctx.valueOf(path.gender) || ctx.valueOf(path.gender) !== <span class=\"hljs-string\">&#x27;diverse&#x27;</span>;\n  });\n\n  required(path.salutation, {\n    when: <span class=\"hljs-function\"><span class=\"hljs-params\">(ctx)</span> =&gt;</span> ctx.valueOf(path.gender) === <span class=\"hljs-string\">&#x27;diverse&#x27;</span>,\n    message: <span class=\"hljs-string\">&#x27;Please choose a salutation, when diverse gender selected&#x27;</span>,\n  });\n  required(path.pronoun, {\n    when: <span class=\"hljs-function\"><span class=\"hljs-params\">(ctx)</span> =&gt;</span> ctx.valueOf(path.gender) === <span class=\"hljs-string\">&#x27;diverse&#x27;</span>,\n    message: <span class=\"hljs-string\">&#x27;Please choose a pronoun, when diverse gender selected&#x27;</span>,\n  });\n});\n</code></pre>\n<p>The full form model still has to be defined in the parent component that manages the form.\nHowever, parts of the <code>FieldTree</code> can be passed to child components via property binding.\nFrom the perspective of our <code>IdentityForm</code>, we receive the model from the parent component via an <code>input()</code>.</p>\n<p>While we&#39;re at it, we also define a method <code>updateSalutationAndPronoun()</code> that resets the salutation and pronoun fields when the user changes the gender field.\nWe set an empty value for the fields and call <code>reset()</code> which resets the <code>touched</code> and <code>dirty</code> state.\nFinally, we import the <code>FormField</code> directive for binding the fields to our form elements in the template and our <code>FormError</code> component to be able to display validation errors.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-meta\">@Component({\n  // ...\n  imports: [Field, FormError]\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IdentityForm</span> {\n  readonly identity = model.required&lt;FieldTree&lt;GenderIdentity&gt;&gt;();\n\n  <span class=\"hljs-keyword\">protected</span> updateSalutationAndPronoun() {\n    <span class=\"hljs-keyword\">this</span>.identity().salutation().value.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n    <span class=\"hljs-keyword\">this</span>.identity().salutation().reset();\n    <span class=\"hljs-keyword\">this</span>.identity().pronoun().value.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n    <span class=\"hljs-keyword\">this</span>.identity().pronoun().reset();\n  }\n}\n</code></pre>\n<blockquote>\n<p>Note: Resetting the fields could have been solved with an <code>effect</code> as well.\nHowever, in our evaluation this led to an infinite loop, even if the value didn&#39;t change. This is most likely a bug that will be fixed in future releases of Signal Forms.</p>\n</blockquote>\n<p>In the template, things are straightforward and don&#39;t differ much from what we&#39;ve seen so far:\nWe use the <code>FormField</code> directive to bind our fields to the form model.\nTo conditionally show the fields for salutation and pronoun, we use the <code>hidden()</code> signal to determine whether the fields are marked as hidden.\nTo trigger the reset logic, we bind the <code>change</code> event of the gender <code>&lt;select&gt;</code> to our method <code>updateSalutationAndPronoun()</code>.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>\n  Gender\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span>\n    <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;gender-identity&quot;</span>\n    [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;identity().gender&quot;</span>\n    (<span class=\"hljs-attr\">change</span>)=<span class=\"hljs-string\">&quot;updateSalutationAndPronoun()&quot;</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">selected</span>&gt;</span>Please select<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;male&quot;</span>&gt;</span>Male<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;female&quot;</span>&gt;</span>Female<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;diverse&quot;</span>&gt;</span>Diverse<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;group-with-gap&quot;</span>&gt;</span>\n  @if (!identity().salutation().hidden()) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>\n    Salutation\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;e. g. Mx.&quot;</span> [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;identity().salutation&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-form-error</span> [<span class=\"hljs-attr\">fieldRef</span>]=<span class=\"hljs-string\">&quot;identity().salutation&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  }\n  @if (!identity().pronoun().hidden()) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>\n    Pronoun\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;e. g. they/them&quot;</span> [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;identity().pronoun&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-form-error</span> [<span class=\"hljs-attr\">fieldRef</span>]=<span class=\"hljs-string\">&quot;identity().pronoun&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  }\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<h3 id=\"integrating-the-child-form\">Integrating the Child Form</h3>\n<p>Our child form is now ready to be used: It receives a <code>FieldTree</code> and binds all its fields to the template.\nIt also exports the data model interface, initial state and schema for validation.\nThe next step is to integrate all these parts into our main <code>RegistrationForm</code>.</p>\n<p>This is the place where the data model and state of the whole form are defined, including the identity information.\nWe create a new data property <code>identity</code> which holds a nested object of type <code>GenderIdentity</code>.\nThe <code>initialState</code> has to be updated accordingly.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// registrsation-form.ts</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">GenderIdentity</span>, initialGenderIdentityState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../identity-form/identity-form&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">RegisterFormData</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">identity</span>: <span class=\"hljs-title class_\">GenderIdentity</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-title class_\">RegisterFormData</span> = {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">identity</span>: initialGenderIdentityState,\n};\n</code></pre>\n<p>Next, we use the <code>apply()</code> function within our main schema to integrate the child schema:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// registrsation-form.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">GenderIdentity</span>, <span class=\"hljs-title class_\">IdentityForm</span>, identitySchema, initialGenderIdentityState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../identity-form/identity-form&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> registrationSchema = schema&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">path</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-comment\">// apply child schema for identity checks</span>\n  <span class=\"hljs-title function_\">apply</span>(path.<span class=\"hljs-property\">identity</span>, identitySchema);\n});\n</code></pre>\n<p>Finally, we integrate the <code>IdentityForm</code> component in our main form template.\nTo make things work, we pass the <code>identity</code> field tree of our main form to the child component via property binding.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> (<span class=\"hljs-attr\">submit</span>)=<span class=\"hljs-string\">&quot;submit()&quot;</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-identity-form</span> [<span class=\"hljs-attr\">identity</span>]=<span class=\"hljs-string\">&quot;registrationForm.identity&quot;</span> /&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></pre>\n<p>The child form now integrates with the parent form.\n<code>RegistrationForm</code> as the main form component puts all things together: It holds the complete data model, applies the schemas (including the child schema), and manages form submission and validation.\nParts of the form are passed to sub components like <code>IdentityForm</code>, which bind to the fields and handle their own UI logic.</p>\n<h2 id=\"creating-custom-form-ui-controls\">Creating custom Form UI Controls</h2>\n<p>So far, we&#39;ve used standard HTML form elements like <code>&lt;input&gt;</code>, <code>&lt;select&gt;</code>, and <code>&lt;textarea&gt;</code> to build our forms.\nHowever, in real-world applications, we often need form controls that go beyond standard HTML input elements:\nThink of a date picker, a rich text editor, a multi-select dropdown, a counter control, wrappers for third-party component libraries, or custom UI elements that fit specific design requirements.\nThis is something that was relatively complicated with Angular&#39; <em>Reactive Forms</em> approach using <code>ControlValueAccessor</code>.</p>\n<p>Signal Forms provide a simple interface that allows us to create custom form components that integrate seamlessly with the Signal Forms ecosystem.\nOur goal is to create a custom component that can be used just like native HTML form elements with the <code>FormField</code> directive.</p>\n<h3 id=\"the-formuicontrol-interface\">The <code>FormUiControl</code> interface</h3>\n<p>Signal Forms provide the <code>FormUiControl</code> interface that defines the contract for custom form components:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">interface</span> FormUiControl {\n  <span class=\"hljs-keyword\">readonly</span> disabled?: InputSignal&lt;<span class=\"hljs-built_in\">boolean</span>&gt;;\n  <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-keyword\">readonly</span>?: InputSignal&lt;<span class=\"hljs-built_in\">boolean</span>&gt;;\n  <span class=\"hljs-keyword\">readonly</span> hidden?: InputSignal&lt;<span class=\"hljs-built_in\">boolean</span>&gt;;\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>This interface is the base structure, but typically we don&#39;t implement it directly.\nInstead, we use the more specific interfaces <code>FormValueControl</code> or <code>FormCheckboxControl</code> that extend the <code>FormUiControl</code> interface with specific properties needed for handling common value inputs or checkboxes:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">FormValueControl</span>&lt;<span class=\"hljs-symbol\">T</span>&gt; <span class=\"hljs-symbol\">extends</span> <span class=\"hljs-symbol\">FormUiControl</span> {\n  readonly value: ModelSignal&lt;TValue&gt;;\n  <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">FormCheckboxControl</span> <span class=\"hljs-symbol\">extends</span> <span class=\"hljs-symbol\">FormUiControl</span> {\n  readonly checked: ModelSignal&lt;<span class=\"hljs-built_in\">bool</span>ean&gt;;\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Our custom components need to implement this interface to work with the <code>FormField</code> directive.\nYou can see that most of the fields are optional, and only <code>value</code> or <code>checked</code> are required.</p>\n<h3 id=\"creating-a-custom-multiselect-component\">Creating a Custom Multiselect Component</h3>\n<p>We want to create a custom multiselect component that can later be used to select newsletter topics.\nUsers can choose one or multiple topics from a list.\nThe component must implement <code>FormValueControl</code> with the type that we use for the model value, which is a <code>string[]</code> in our case.</p>\n<p>The most important part is the <code>value</code> property that holds the current selection as a model signal.\n<code>model</code> is a semantic combination of <em>input</em> and <em>output</em>: It receives values from the parent component but can also be updated locally.\nAll local changes are automatically sent back to the parent component as an <em>output</em>.\nThis way, data flows bidirectionally between the parent form and the custom component.</p>\n<p>The inputs <code>errors</code> and <code>disabled</code> are optional: These values are automatically provided by the <code>FormField</code> directive when the control has errors or is disabled.\nWe can use the <code>disabled</code> input signal to clear the value when the control is disabled by using an <code>effect</code>.</p>\n<p>Our component can define additional inputs as needed:\nThe inputs <code>label</code> and <code>selectOptions</code> receive the label for the form control and the list of all options to select from.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, effect, input, model } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">FormValueControl</span>, <span class=\"hljs-title class_\">ValidationError</span>, <span class=\"hljs-title class_\">WithOptionalField</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Multiselect</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">FormValueControl</span>&lt;<span class=\"hljs-built_in\">string</span>[]&gt; {\n  <span class=\"hljs-keyword\">readonly</span> value = model&lt;<span class=\"hljs-built_in\">string</span>[]&gt;([]);\n  <span class=\"hljs-keyword\">readonly</span> errors = input&lt;<span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-title class_\">WithOptionalField</span>&lt;<span class=\"hljs-title class_\">ValidationError</span>&gt;[]&gt;([]);\n  <span class=\"hljs-keyword\">readonly</span> disabled = input&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">readonly</span> selectOptions = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>[]&gt;();\n  <span class=\"hljs-keyword\">readonly</span> label = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">effect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">disabled</span>()) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">set</span>([]);\n      }\n    });\n  }\n}\n</code></pre>\n<p>Next, we implement the template where we use native HTML elements.\nWe want to keep the example as simple as possible, so please remember that for a production-ready multiselect component we need to address a few more details, e.g. proper keyboard navigation.</p>\n<blockquote>\n<p>For styling we use <a href=\"https://picocss.com/\">picocss</a> which is a minimalistic and lightweight and accessible styling framework for semantic HTML.</p>\n</blockquote>\n<p>We wrap the selection in a <code>&lt;details&gt;</code> element and place the label in the <code>&lt;summary&gt;</code>.\nAlso we apply the attribute <code>aria-disabled</code> and hide the selection list when the component is marked as disabled.\nThe selection options are HTML <code>&lt;input&gt;</code> elements of type checkbox that we display by iterating over the list of <code>selectOptions</code>.\nTo show the current selection state, we can bind to the <code>checked</code> property: The component&#39;s <code>value</code> is a list of strings, and we can check whether the current option is part of this list.\nFor changing the input we call a method <code>changeInput()</code> (we create it right after) with the (un)selected name and the native event.</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">details</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;dropdown&quot;</span> [<span class=\"hljs-attr\">ariaDisabled</span>]=<span class=\"hljs-string\">&quot;disabled()&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">summary</span>&gt;</span>\n    </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">label</span>() }}</span><span class=\"language-xml\">\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">summary</span>&gt;</span>\n  @if (!disabled()) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      @for (option of selectOptions(); track $index) {\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n              <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span>\n              [<span class=\"hljs-attr\">name</span>]=<span class=\"hljs-string\">&quot;option&quot;</span>\n              [<span class=\"hljs-attr\">checked</span>]=<span class=\"hljs-string\">&quot;value().includes(option)&quot;</span>\n              (<span class=\"hljs-attr\">input</span>)=<span class=\"hljs-string\">&quot;changeInput(option, $event)&quot;</span>\n            /&gt;</span>\n            </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">option</span> }}</span><span class=\"language-xml\">\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n      }\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  }\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">details</span>&gt;</span></span>\n</code></pre>\n<p>Now we need to implement the method <code>changeInput()</code> that handles the changes of the checkbox inputs:</p>\n<ul>\n<li>When an option is checked, we have to add it to the list of selected options.</li>\n<li>When an option is unchecked, we have to remove it from the list.</li>\n</ul>\n<p>This is why the method needs to read the checkbox state from the native event to decide whether to add or remove the option from the list.\nWe update the list by changing the <code>value</code> signal.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Multiselect</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">FormValueControl</span>&lt;<span class=\"hljs-built_in\">string</span>[]&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-title function_\">changeInput</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">option</span>: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">e</span>: <span class=\"hljs-title class_\">Event</span></span>) {\n    <span class=\"hljs-keyword\">const</span> checked = (e.<span class=\"hljs-property\">target</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">HTMLInputElement</span>).<span class=\"hljs-property\">checked</span>;\n\n    <span class=\"hljs-keyword\">if</span> (checked) {\n      <span class=\"hljs-comment\">// option checked, add to list</span>\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">current</span>) =&gt;</span> [...current, option]);\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// option unchecked, remove from list</span>\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">current</span>) =&gt;</span> current.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">o</span>) =&gt;</span> o !== option));\n    }\n  }\n}\n</code></pre>\n<h3 id=\"using-the-custom-component\">Using the Custom Component</h3>\n<p>Our custom form control is now ready to be used!\nSince it implements the <code>FormValueControl</code> interface, we can use the component just like a native HTML form element.\nIn our <code>RegistrationForm</code> template, we include the <code>MultiSelect</code> component and pass the field tree <code>newsletterTopics</code> to the <code>FormField</code> directive.\nAll inputs defined in the <code>FormValueControl</code> interface are now automatically managed by the directive.</p>\n<p>Our additional custom inputs <code>selectOptions</code> and <code>label</code> are set via property binding.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!--- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-multiselect</span>\n  [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;registrationForm.newsletterTopics&quot;</span>\n  [<span class=\"hljs-attr\">selectOptions</span>]=<span class=\"hljs-string\">&quot;[&#x27;Angular&#x27;, &#x27;React&#x27;, &#x27;Vue&#x27;, &#x27;Svelte&#x27;]&quot;</span>\n  <span class=\"hljs-attr\">label</span>=<span class=\"hljs-string\">&quot;Topics (multiple possible):&quot;</span>\n/&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-form-error</span> [<span class=\"hljs-attr\">formField</span>]=<span class=\"hljs-string\">&quot;registrationForm.newsletterTopics&quot;</span> /&gt;</span>\n<span class=\"hljs-comment\">&lt;!--- ... --&gt;</span>\n</code></pre>\n<p>To make the form work, we have to change one last thing:\nWe need to adjust our data model to allow multiple topics: <code>newsletterTopics</code> becomes <code>string[]</code>;\nThe validation doesn&#39;t have to be changed, since we already check for the <code>length</code> property which works perfectly with the string array.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">RegisterFormData</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">newsletterTopics</span>: <span class=\"hljs-built_in\">string</span>[];\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-title class_\">RegisterFormData</span> = {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">newsletterTopics</span>: [<span class=\"hljs-string\">&#x27;Angular&#x27;</span>],\n};\n</code></pre>\n<p>And this is how we can create and use custom form UI controls with Signal Forms!\nAny component that implements the necessary interface can be directly integrated into Signal Forms with the <code>FormField</code> directive.</p>\n<h2 id=\"provide-a-custom-signalformsconfig\">Provide a custom <code>SignalFormsConfig</code></h2>\n<p>Now that we know how to create large and modular forms and how to implement validation rules, we want to explore how we can customize Signal Forms.\nSignal Forms offer us a way to configure how they behave in terms of automatically applying CSS classes based on a form field&#39;s state.\nTo do so, we need to create a <code>SignalFormsConfig</code> which accepts a <code>classes</code> object.\nThe keys of this object are the names of the CSS classes that should be applied whenever the assigned value, which is a predicate function with access to a form field&#39;s state, evaluates to <code>true</code>.\nLooking at the example below, the CSS class <code>error</code> is applied for each form field that is touched and has at least one error assigned to it.</p>\n<pre><code class=\"language-ts\">// signal-forms.config.ts\nimport { SignalFormsConfig } <span class=\"hljs-keyword\">from</span> &#x27;@angular/forms/signals&#x27;;\n\nexport <span class=\"hljs-keyword\">const</span> signalFormsConfig: SignalFormsConfig = {\n  classes: {\n    valid: (<span class=\"hljs-keyword\">state</span>) =&gt; <span class=\"hljs-keyword\">state</span>.valid(),\n    error: (<span class=\"hljs-keyword\">state</span>) =&gt; <span class=\"hljs-keyword\">state</span>.touched() &amp;&amp; <span class=\"hljs-keyword\">state</span>.errors().length &gt; <span class=\"hljs-number\">0</span>,\n  },\n};\n</code></pre>\n<p>If you used Angular Reactive or Template-Driven Forms before, you may have noticed that this behavior was applied automatically.\nFor example, valid input fields have always had the class <code>ng-valid</code> applied to them and we could use these classes in our CSS for styling elements.\nHowever, this wasn&#39;t really flexible, especially when working with CSS libraries that used their own classes.\nAlso, a bunch of CSS classes were applied even if we didn&#39;t use them.\nIf we still want to have the behavior from before, we can use the provided compatibility config:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// signal-forms.config.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">SignalFormsConfig</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">NG_STATUS_CLASSES</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals/compat&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">signalFormsConfig</span>: <span class=\"hljs-title class_\">SignalFormsConfig</span> = {\n  <span class=\"hljs-attr\">classes</span>: <span class=\"hljs-variable constant_\">NG_STATUS_CLASSES</span>,\n};\n</code></pre>\n<p>Once we create our config, we need to provide it.\nWe can either provide it at application level, route level or only for a specific component by passing it to <code>provideSignalFormsConfig()</code> into the <code>providers</code> array.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// app.config.ts</span>\n<span class=\"hljs-keyword\">import</span> { provideSignalFormsConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> { signalFormsConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./signal-forms.config&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-title function_\">provideSignalFormsConfig</span>(signalFormsConfig),\n  ],\n};\n</code></pre>\n<p>If we run the app with the form now and we investigate the DOM, we can see that the CSS classes are always applied based on our defined predicate function.</p>\n<h2 id=\"demo\">Demo</h2>\n<p>You can find a complete demo application for this blog series on GitHub and Stackblitz:</p>\n<ul>\n<li><strong>‚ö°Ô∏è Stackblitz:</strong> <a href=\"https://stackblitz.com/github/angular-buch/signal-forms-registration\">https://stackblitz.com/github/angular-buch/signal-forms-registration</a></li>\n<li><strong>‚öôÔ∏è Code on GitHub:</strong> <a href=\"https://github.com/angular-buch/signal-forms-registration\">https://github.com/angular-buch/signal-forms-registration</a></li>\n<li><strong>üíª Live Demo:</strong> <a href=\"https://angular-buch.github.io/signal-forms-registration/\">https://angular-buch.github.io/signal-forms-registration/</a></li>\n</ul>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>In this four-part series, we&#39;ve explored the full spectrum of Angular Signal Forms:</p>\n<p><strong><a href=\"/blog/2025-10-signal-forms-part1/\">Part 1</a></strong> covered the fundamentals:</p>\n<ul>\n<li>Data models and field structures</li>\n<li>Template connections with the <code>FormField</code> directive</li>\n<li>Basic form submission and validation</li>\n<li>Built-in validators and error display</li>\n</ul>\n<p><strong><a href=\"/blog/2025-10-signal-forms-part2/\">Part 2</a></strong> dove into schema validation patterns:</p>\n<ul>\n<li>Custom validation functions</li>\n<li>Cross-field and conditional validation</li>\n<li>Asynchronous validation</li>\n<li>Server-side error handling</li>\n</ul>\n<p><strong>Part 3</strong> explored specialized topics:</p>\n<ul>\n<li>Creating modular child forms and combining schemas with <code>apply()</code></li>\n<li>Building custom UI controls with <code>FormValueControl</code></li>\n<li>Providing custom <code>SignalFormsConfig</code> for CSS class management</li>\n</ul>\n<p><strong><a href=\"/blog/2025-12-signal-forms-part4/\">Part 4</a></strong> covers metadata and accessibility:</p>\n<ul>\n<li>Providing field metadata</li>\n<li>Provide a generic component for displaying form field information</li>\n<li>Creating a directive for adding ARIA attributes based on a field state</li>\n</ul>\n<p>Signal Forms are the third major approach of form handling in Angular.\nAfter Template-Driven Forms and Reactive Forms, Signal Forms aim to make form handling more type-safe, reactive, and declarative.\nAs the new approach continues to evolve from its experimental status, Signal Forms promise to become a cornerstone of modern Angular application development!</p>\n<p><small><strong>Cover image:</strong> Picture from <a href=\"https://pixabay.com/photos/journal-write-blank-pages-notes-2850091/\">Pixabay</a>, edited</small></p>\n","meta":{"title":"Angular Signal Forms Part 3: Child Forms, Custom UI Controls and SignalFormsConfig","author":"Danny Koppenhagen","mail":"mail@d-koppenhagen.de","author2":"Ferdinand Malcher","mail2":"mail@fmalcher.de","published":"2025-10-20T00:00:00.000Z","lastModified":"2026-01-08T00:00:00.000Z","keywords":["Angular","Signals","Forms","Angular 21","Signal Forms","Custom Controls","Child Forms","ControlValueAccessor","NG_STATUS_CLASSES","SignalFormsConfig"],"language":"en","header":{"url":"header-signalforms-part3.jpg","width":2000,"height":1133},"sticky":false}}
