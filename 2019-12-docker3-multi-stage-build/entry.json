{"slug":"2019-12-docker3-multi-stage-build","html":"<p><strong>Multi-Stage Builds für Angular:\nWie Sie Apps gleich im Container bauen und trotzdem schlanke Docker-Images erstellen.\nVermeiden Sie Risiken durch externe Abhängigkeiten!\nDies ist der letzte Teil unserer Artikelserie zu Angular und Docker.</strong></p>\n<p>Inhaltsverzeichnis:</p>\n<ul>\n<li><a href=\"/blog/2019-12-docker3-multi-stage-build#abhaengigkeiten\">Interne und externe Abhängigkeiten</a></li>\n<li><a href=\"/blog/2019-12-docker3-multi-stage-build#externe-abhaengigkeiten-handhaben\">Externe Abhängigkeiten handhaben</a></li>\n<li><a href=\"/blog/2019-12-docker3-multi-stage-build#docker-to-the-rescue\">Docker To The Rescue</a></li>\n<li><a href=\"/blog/2019-12-docker3-multi-stage-build#multi-stage-builds\">Multi-Stage Builds</a></li>\n<li><a href=\"/blog/2019-12-docker3-multi-stage-build#das-image-bauen\">Das Image bauen</a></li>\n<li><a href=\"#vergleich\">Vergleich</a></li>\n<li><a href=\"/blog/2019-12-docker3-multi-stage-build#grenzen-der-vorgestellten-loesung\">Grenzen der vorgestellten Lösung</a></li>\n<li><a href=\"/blog/2019-12-docker3-multi-stage-build#fazit\">Fazit</a></li>\n<li><a href=\"/blog/2019-12-docker3-multi-stage-build#rueckblick\">Rückblick</a></li>\n</ul>\n<blockquote>\n<p>Sie finden den Code zum Artikel auf\n<a href=\"https://github.com/MichaelKaaden/dockerized-app/tree/master/Part-3-Multi-Stage-Build\">GitHub</a>.</p>\n</blockquote>\n<p>In Teil I dieser Artikelserie haben Sie gelernt, wie Sie Ihre Angular-App in ein Docker-Image verpacken und in einem Container zur Ausführung bringen können.</p>\n<p>In Teil II haben wir uns damit beschäftigt, die Konfiguration der Angular-App mit Docker-Mitteln vorgeben zu können.</p>\n<p>In diesem letzten Teil der Serie kümmern wir uns darum, die Build-Umgebung deskriptiv in Ihr jeweiliges Projekt einzubinden und somit über die Projektlaufzeit hinweg unter Ihrer Kontrolle zu halten.</p>\n<hr>\n<h2 id=\"interne-und-externe-abhängigkeiten-\">Interne und externe Abhängigkeiten <a name=\"abhaengigkeiten\"></a></h2>\n<p>Kennen Sie das? Sie entwickeln ein Projekt nach allen Regeln der Ingenieurskunst durch, übergeben es dem Betrieb oder dem Kunden – und dann fassen Sie es nicht mehr an, bis sich jemand bei Ihnen meldet und nach Änderungen verlangt.</p>\n<p>Das ist dann der Moment, an dem Sie den Staub vom Projekt pusten und sich vielleicht als erstes fragen, wie Sie das damals gebaut haben.\nBeschränken wir uns auf TypeScript- oder JavaScript-Projekte, dann haben Sie vielleicht in der Sektion <code>scripts</code> in der <code>package.json</code> das entsprechende Kommando hinterlegt.\nVielleicht müssen Sie auch ins <code>gulpfile.js</code> schauen.</p>\n<p>Haben Sie sich besonnen und den Build angestoßen, stürzt Gulp unerwartet mit einer C++-Exception ab, und Sie fangen an, auf Google nach der Ursache zu suchen.\nSie stellen dann fest, dass es wohl daran liegt, dass Sie derzeit mit Node.js in Version 10 entwickeln, damals aber... Hm, war es Version 8 oder gar noch Version 6?\nUnd schon laden Sie beide Versionen herunter und probieren herum.\nSchnell ist dann die erste Stunde investiert, ohne dass Sie produktiv gewesen wären. Dabei ist Zeit doch Geld...</p>\n<p>Was ist schiefgelaufen? Sie haben nicht beachtet, dass Sie es in Ihrem Projekt nicht nur mit <em>internen</em> Abhängigkeiten zu tun haben, die Sie fein säuberlich in der <code>package.json</code> aufführen, sondern auch mit <em>externen</em> Abhängigkeiten, etwa der eingesetzten Node.js-Version.</p>\n<h2 id=\"externe-abhängigkeiten-handhaben-\">Externe Abhängigkeiten handhaben <a name=\"externe-abhaengigkeiten-handhaben\"></a></h2>\n<p>Natürlich gibt es Lösungen, um mehrere Versionen von Node.js gleichzeitig auf Ihrem Rechner vorzuhalten und zwischen diesen zu wechseln, etwa mit Tools wie <a href=\"https://github.com/tj/n\">n</a> oder <a href=\"https://github.com/creationix/nvm\">nvm</a>, aber das ist gar nicht mein Punkt. \nDer Punkt ist, dass Sie <em>daran denken</em> müssen, jeweils auf die richtige Version umzustellen, wenn Sie zwischen Ihren Projekten wechseln.</p>\n<p>Auf Ihrem Build-Server, etwa <a href=\"https://jenkins.io/\">Jenkins</a> oder Gitlab CI, können Sie für jedes Projekt eine individuelle Umgebung vorgeben.\nProjekt A baut dann mit Node.js in Version 10, während das ältere Projekt B mit Node.js 6 erstellt wird.\nDas ist eine tolle Sache, hilft Ihnen auf Ihrem Entwicklungsrechner aber nicht weiter.\nDie Idee ist jedoch die Richtige: Wir müssen die Build-Umgebung für das Projekt festlegen und einhalten, auch auf dem Entwicklungssystem.</p>\n<h2 id=\"docker-to-the-rescue\">Docker To The Rescue</h2>\n<p>Warum bauen wir die App nicht einfach von einem Docker-Container aus? Dank des Containers hätten wir feingranulare Kontrolle über die zu verwendende Node.js- und NPM-Version sowie das weitere Tooling, und all das könnten wir mittels eines Dockerfiles in unserem Projekt ablegen und zusammen mit dem Projekt versionieren.</p>\n<p>Die Antwort ist ganz einfach: Das würde prima funktionieren, nur leider würde das dabei entstehende Image sehr groß -- schließlich sind alle Tools und das komplette <code>node_modules</code>-Verzeichnis Teil des Images, obwohl Sie diese nach dem erfolgreichen Build nicht mehr benötigen.\nAlleine das Verzeichnis <code>node_modules</code> einer Angular-App ist schon fast 500 MB groß.\nZusammen mit Google Chrome für die Unit Tests und Node.js sind Sie somit bei rund 1 GB pro Image.\nUnd Sie wissen ja: Uns reicht ein nginx-Image mit der Kopie des Verzeichnisses <code>dist/&lt;meine app&gt;</code>, das lediglich rund 100 MB groß wäre.</p>\n<p>Damit ist unser Plan klar: Wir bauen die App trotzdem innerhalb eines Containers und erzeugen aus dem Ergebnis ein neues, minimales Image.\nZu unserem Glück ist das ein Problem, das nicht nur uns beschäftigt, sodass Docker eine Lösung für genau diesen\nAnwendungsfall bietet: den sog. <em>Multi-Stage Build</em>.</p>\n<h2 id=\"multi-stage-builds\">Multi-Stage Builds</h2>\n<p>Multi-Stage Builds kaskadieren den Build mehrerer Images und kopieren dabei Daten vom Vorgänger in den Nachfolger. \nLediglich das letzte Image ist dabei das Ergebnis, die Vorgänger spielen keine Rolle mehr (werden aber gecachet, um den nächsten Build zu beschleunigen).\nLetzten Endes können Sie sich das wie bei Prozessen und Pipes unter UNIX vorstellen: Die Ausgabe vom Vorgänger landet im Nachfolger.</p>\n<p>In unserem Fall muss das erste Image die App bauen, während das zweite die erzeugte App aufnimmt.\nDaher muss das erste Image Node.js, NPM, Angular CLI und Google Chrome enthalten.\nDas zweite Image ist identisch mit dem, das wir in den bisherigen Teilen der Artikelserie entwickelt haben.\nEs bezieht die App aber aus dem ersten Image statt aus dem lokalen Verzeichnis <code>dist</code>.</p>\n<p>Soviel zum Plan, nun setzen wir das Ganze um.\nAls erstes müssen wir unser <code>.dockerignore</code> bereinigen, denn nun legen wir sehr\nwohl Wert auf alle Dateien und Verzeichnisse, die wir brauchen, um unsere App zu\nerstellen. Andererseits benötigen wir jetzt das Verzeichnis <code>dist</code> nicht mehr, das zuvor noch essentiell für uns war, denn wir bauen die Anwendung ja nun nicht mehr lokal, sondern im Container.</p>\n<pre><code><span class=\"hljs-selector-class\">.editorconfig</span>\n<span class=\"hljs-selector-class\">.git</span>\n<span class=\"hljs-selector-class\">.gitignore</span>\n<span class=\"hljs-selector-class\">.idea</span>\nREADME<span class=\"hljs-selector-class\">.md</span>\ncoverage\ndist\nnode_modules\n</code></pre>\n<p>Außerdem müssen wir die Datei <code>src/karma.conf.js</code> anpassen, damit Google Chrome im Headless Mode in einem Container unter Debian GNU/Linux funktioniert.\nFügen Sie dazu im Abschnitt <code>config.set({...})</code> folgendes hinzu:</p>\n<pre><code><span class=\"hljs-symbol\">customLaunchers:</span> <span class=\"hljs-punctuation\">{</span>\n<span class=\"hljs-symbol\">   ChromeHeadlessNoSandbox:</span> <span class=\"hljs-punctuation\">{</span>\n<span class=\"hljs-symbol\">       base:</span> <span class=\"hljs-string\">&quot;ChromeHeadless&quot;</span>,\n<span class=\"hljs-symbol\">       flags:</span> [<span class=\"hljs-string\">&quot;--no-sandbox&quot;</span>],\n   <span class=\"hljs-punctuation\">}</span>,\n<span class=\"hljs-punctuation\">}</span>,\n</code></pre>\n<p>Hintergrund ist, dass wir das Sandboxing ausschalten müssen, damit die Tests\nausgeführt werden.\nDa Sie selbst den Container unter Kontrolle haben, sollte dieses Risiko akzeptabel sein.</p>\n<p>Als Nächstes müssen wir unser <code>Dockerfile</code> erweitern:</p>\n<pre><code class=\"language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:<span class=\"hljs-number\">10</span>-buster as node\n\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> npm install -g @angular/cli@7.3.5</span>\n\n<span class=\"hljs-comment\"># install Google Chrome</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - \\\n    &amp;&amp; sh -c <span class=\"hljs-string\">&#x27;echo &quot;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google.list&#x27;</span> \\\n    &amp;&amp; apt-get update &amp;&amp; apt-get install -yq google-chrome-stable</span>\n\n<span class=\"hljs-comment\"># now test and build the app</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /usr/src/app</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> . ./</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> yarn install</span>\n<span class=\"hljs-comment\"># ChromeHeadless needs to be run with --no-sandbox</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"language-bash\"> ng <span class=\"hljs-built_in\">test</span> --watch=<span class=\"hljs-literal\">false</span> --browsers=ChromeHeadlessNoSandbox &amp;&amp; ng build --prod</span>\n\n<span class=\"hljs-comment\"># Stage 2</span>\n<span class=\"hljs-keyword\">FROM</span> nginx\n\n<span class=\"hljs-keyword\">LABEL</span><span class=\"language-bash\"> maintainer=<span class=\"hljs-string\">&quot;Ihr Name &lt;you@your.domain&gt;&quot;</span></span>\n\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> nginx/default.conf /etc/nginx/conf.d</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"language-bash\"> --from=node /usr/src/app/dist/dockerized-app /usr/share/nginx/html</span>\n</code></pre>\n<p>Eine kurze Erklärung dazu: Dieses Dockerfile basiert auf einem Image mit Node.js 10 und legt darin <code>@angular/cli</code> in Version 7.3.5 (passend zur Version in der <code>package.json</code>-Datei) und den Chrome-Browser ab. \nAnschließend baut es die App, genau so, wie wir es bisher von Hand getan haben -- na, nicht ganz, wir lassen nun die Tests laufen, denn das gehört doch sicher auch bei Ihnen dazu, nicht wahr?\nAnsonsten kommentieren Sie die Zeile mit <code>RUN ng test ...</code> einfach aus.\nIm zweiten Schritt (gekennzeichnet durch den Kommentar &quot;Stage 2&quot;) kopiert es die fertiggestellte App aus dem ersten Image in das zweite.</p>\n<p>Die entscheidenden Stellen sind <code>FROM node:10-buster as node</code>, die die Bezeichnung <code>node</code> für das erste Image vorgibt, und <code>COPY --from=node ...</code>, die unter Verwendung dieser Bezeichnung aus dem ersten in das zweite Image kopiert.</p>\n<p>Jetzt entfernen wir noch den Build der App aus dem Skript <code>dockerize.sh</code>, da sich das <code>Dockerfile</code> ab jetzt um diesen Schritt kümmert:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-meta\">#!/bin/bash</span>\ndocker build -t dockerized-app .\n</code></pre>\n<h2 id=\"das-image-bauen\">Das Image bauen</h2>\n<p>Um das Image mit der App zu bauen, gehen wir genauso vor wie bisher: Wir führen erst <code>dockerize.sh</code> aus und dann <code>redeploy.sh</code>. Hier ein Beispiellauf:</p>\n<pre><code class=\"language-console\">$ <span class=\"hljs-string\">./dockerize.sh</span>\nSending build context to Docker daemon  370.7kB\nStep 1/11 : FROM node<span class=\"hljs-function\">:10-buster</span> as node\n <span class=\"hljs-params\">---</span>&gt; d71f0dc8e93b\nStep 2/11 : RUN npm install -g @angular/cli@7.3.5\n <span class=\"hljs-params\">---</span>&gt; Running in 0ddecfd06f16\n+ @angular/cli@7.3.5\nadded 289 packages from 181 contributors in 9.717s\nRemoving intermediate container 0ddecfd06f16\n <span class=\"hljs-params\">---</span>&gt; fd9b8afe37ec\nStep 3/11 : RUN wget -q -O - https:<span class=\"hljs-string\">//dl-ssl.google.com/linux/linux_signing_key.pub</span> | apt-key add -     &amp;&amp; sh -c &#x27;<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&quot;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&quot;</span> &gt;&gt; <span class=\"hljs-string\">/etc/apt/sources.list.d/google.list</span>&#x27;     &amp;&amp; apt-get update &amp;&amp; apt-get install -yq google-chrome-stable\n <span class=\"hljs-params\">---</span>&gt; Running in f85a552bb159\nGet<span class=\"hljs-function\">:1</span> http:<span class=\"hljs-string\">//deb.debian.org/debian</span> buster InRelease [122 kB]\n<span class=\"hljs-string\">...</span>\nFetched 8230 kB in 2s <span class=\"hljs-params\">(5416 kB/s)</span>\nReading package lists.<span class=\"hljs-string\">..</span>\nReading package lists.<span class=\"hljs-string\">..</span>\nBuilding dependency tree.<span class=\"hljs-string\">..</span>\nReading state information.<span class=\"hljs-string\">..</span>\nThe following additional packages will be installed:\n  adwaita-icon-theme at-spi2-core dbus dbus-user-session\n  <span class=\"hljs-string\">...</span>\nSetting up google-chrome-stable <span class=\"hljs-params\">(78.0.3904.97-1)</span> <span class=\"hljs-string\">...</span>\nRemoving intermediate container f85a552bb159\n <span class=\"hljs-params\">---</span>&gt; 92e5bb2bbaed\nStep 4/11 : WORKDIR <span class=\"hljs-string\">/usr/src/app</span>\n <span class=\"hljs-params\">---</span>&gt; Running in 86a7a6c9204f\nRemoving intermediate container 86a7a6c9204f\n <span class=\"hljs-params\">---</span>&gt; 0c06bb302e39\nStep 5/11 : COPY . <span class=\"hljs-string\">./</span>\n <span class=\"hljs-params\">---</span>&gt; 9d6b58feea14\nStep 6/11 : RUN yarn\n <span class=\"hljs-params\">---</span>&gt; Running in a35c44a28667\nyarn install v1.19.1\n[1/4] Resolving packages.<span class=\"hljs-string\">..</span>\n[2/4] Fetching packages.<span class=\"hljs-string\">..</span>\n[3/4] Linking dependencies.<span class=\"hljs-string\">..</span>\n[4/4] Building fresh packages.<span class=\"hljs-string\">..</span>\nDone in 17.33s.\nRemoving intermediate container a35c44a28667\n <span class=\"hljs-params\">---</span>&gt; 5959d3240af1\nStep 7/11 : RUN ng test <span class=\"hljs-params\">--watch=false</span> <span class=\"hljs-params\">--browsers=ChromeHeadlessNoSandbox</span> &amp;&amp; ng build <span class=\"hljs-params\">--prod</span>\n <span class=\"hljs-params\">---</span>&gt; Running in e8e73909da63\n11 11 2019 17<span class=\"hljs-function\">:51</span><span class=\"hljs-function\">:51.637</span><span class=\"hljs-function\">:INFO</span> [karma-server]: \u001bKarma v4.0.1 server started at http:<span class=\"hljs-string\">//0.0.0.0</span><span class=\"hljs-function\">:9876</span>/\n11 11 2019 17<span class=\"hljs-function\">:51</span><span class=\"hljs-function\">:51.638</span><span class=\"hljs-function\">:INFO</span> [launcher]: \u001bLaunching browsers ChromeHeadlessNoSandbox with concurrency unlimited\n11 11 2019 17<span class=\"hljs-function\">:51</span><span class=\"hljs-function\">:51.640</span><span class=\"hljs-function\">:INFO</span> [launcher]: \u001bStarting browser ChromeHeadless\n11 11 2019 17<span class=\"hljs-function\">:51</span><span class=\"hljs-function\">:53.962</span><span class=\"hljs-function\">:INFO</span> [HeadlessChrome 78.0.3904 <span class=\"hljs-params\">(Linux 0.0.0)</span>]: \u001bConnected on socket x67ZoJs6ERhBn45OAAAA with id 98052412\nTOTAL: 9 SUCCESS\nTOTAL: 9 SUCCESS\n\nDate: 2019-11-11T17<span class=\"hljs-function\">:52</span><span class=\"hljs-function\">:15.005Z</span>\nHash: 046f0c97454b9144a096\nTime: 17593ms\nchunk {0} runtime.a5dd35324ddfd942bef1.js <span class=\"hljs-params\">(runtime)</span> 1.41 kB [entry] [rendered]\nchunk {1} es2015-polyfills.4a4cfea0ce682043f4e9.js <span class=\"hljs-params\">(es2015-polyfills)</span> 56.4 kB [initial] [rendered]\nchunk {2} main.0c51b538c84777d5bf5e.js <span class=\"hljs-params\">(main)</span> 262 kB [initial] [rendered]\nchunk {3} polyfills.9f3702a215d30daac9b6.js <span class=\"hljs-params\">(polyfills)</span> 41 kB [initial] [rendered]\nchunk {4} styles.3ff695c00d717f2d2a11.css <span class=\"hljs-params\">(styles)</span> 0 bytes [initial] [rendered]\nRemoving intermediate container e8e73909da63\n <span class=\"hljs-params\">---</span>&gt; 3a3d2d063b02\nStep 8/11 : FROM nginx\n <span class=\"hljs-params\">---</span>&gt; 53f3fd8007f7\nStep 9/11 : LABEL maintainer=<span class=\"hljs-string\">&quot;Michael Kaaden &lt;github@kaaden.net&gt;&quot;</span>\n <span class=\"hljs-params\">---</span>&gt; Using cache\n <span class=\"hljs-params\">---</span>&gt; 974a15c23b4f\nStep 10/11 : COPY nginx/default.conf <span class=\"hljs-string\">/etc/nginx/conf.d</span>\n <span class=\"hljs-params\">---</span>&gt; Using cache\n <span class=\"hljs-params\">---</span>&gt; cb36b6c88fbc\nStep 11/11 : COPY <span class=\"hljs-params\">--from=node</span> <span class=\"hljs-string\">/usr/src/app/dist/dockerized-app</span> <span class=\"hljs-string\">/usr/share/nginx/html</span>\n <span class=\"hljs-params\">---</span>&gt; Using cache\n <span class=\"hljs-params\">---</span>&gt; 005ab4ca56a3\nSuccessfully built 005ab4ca56a3\nSuccessfully tagged dockerized-app-multistage<span class=\"hljs-function\">:latest</span>\n</code></pre>\n<p>Wenn Sie das Meldungspaar &quot;Successfully built .../Successfully tagged ...&quot; sehen, haben Sie es geschafft: Der Multi-Stage Build hat geklappt.\nFühren Sie Ihren Container nun aus:</p>\n<pre><code class=\"language-console\">$ ./redeploy.sh\nRemoving<span class=\"hljs-built_in\"> network </span>dockerized-app_default\nWARNING:<span class=\"hljs-built_in\"> Network </span>dockerized-app_default <span class=\"hljs-keyword\">not</span> found.\nCreating<span class=\"hljs-built_in\"> network </span><span class=\"hljs-string\">&quot;dockerized-app_default&quot;</span> with the<span class=\"hljs-built_in\"> default </span>driver\nCreating dockerized-app_web_1 <span class=\"hljs-built_in\">..</span>. done\n</code></pre>\n<p>Der so erzeugte Container sollte nun genauso funktionieren wie der aus dem vorigen Teil dieser Artikelserie.\nDie Verbesserung besteht jetzt darin, dass Sie alles, was Sie zum Build benötigen, in Ihrem Projekt beschreiben und das in Ihrer Quellcodeverwaltung mit versionieren können.\nSie haben dadurch keinen Performance-Nachteil, da Docker den ersten Stage cachet – lediglich der zweite Stage muss jedes Mal erstellt werden, wenn Sie etwas an Ihrer App ändern.</p>\n<h2 id=\"vergleich\">Vergleich</h2>\n<p>Hier ein Größenvergleich der Images, die wir in jedem der drei Teile der\nArtikelserie erstellt haben.</p>\n<pre><code>|<span class=\"hljs-string\"> REPOSITORY                </span>|<span class=\"hljs-string\"> TAG    </span>|<span class=\"hljs-string\"> IMAGE ID     </span>|<span class=\"hljs-string\"> CREATED            </span>|<span class=\"hljs-string\"> SIZE  </span>|\n|<span class=\"hljs-string\"> ------------------------- </span>|<span class=\"hljs-string\"> ------ </span>|<span class=\"hljs-string\"> ------------ </span>|<span class=\"hljs-string\"> ------------------ </span>|<span class=\"hljs-string\"> ----- </span>|\n|<span class=\"hljs-string\"> dockerized-app-simple     </span>|<span class=\"hljs-string\"> latest </span>|<span class=\"hljs-string\"> a90b35651f39 </span>|<span class=\"hljs-string\"> 18 minutes ago     </span>|<span class=\"hljs-string\"> 110MB </span>|\n|<span class=\"hljs-string\"> dockerized-app-env        </span>|<span class=\"hljs-string\"> latest </span>|<span class=\"hljs-string\"> 709da311ce4b </span>|<span class=\"hljs-string\"> 17 minutes ago     </span>|<span class=\"hljs-string\"> 110MB </span>|\n|<span class=\"hljs-string\"> dockerized-app-multistage </span>|<span class=\"hljs-string\"> latest </span>|<span class=\"hljs-string\"> 3ecfc4231dd5 </span>|<span class=\"hljs-string\"> About a minute ago </span>|<span class=\"hljs-string\"> 110MB </span>|\n</code></pre>\n<p>Wie Sie sehen, gibt es keinen spürbaren Unterschied zwischen den Image-Größen.\nDas ist natürlich kein Zufall: In den ersten beiden Teilen haben wir die App von Hand gebaut und das Verzeichnis <code>dist/dockerized-app</code> in das Image kopiert.\nIn diesem Teil der Artikelserie haben wir den Build in ein Image im ersten Stage verlagert und von dort aus kopiert.\nEs war also zu erwarten, dass sich die Größe des finalen Images nicht ändert.</p>\n<p>Spaßeshalber habe ich die Größe des ersten Stage des Multi-Stage Builds gemessen:</p>\n<pre><code>|<span class=\"hljs-string\"> REPOSITORY </span>|<span class=\"hljs-string\"> TAG    </span>|<span class=\"hljs-string\"> IMAGE ID     </span>|<span class=\"hljs-string\"> CREATED        </span>|<span class=\"hljs-string\"> SIZE  </span>|\n|<span class=\"hljs-string\"> ---------- </span>|<span class=\"hljs-string\"> ------ </span>|<span class=\"hljs-string\"> ------------ </span>|<span class=\"hljs-string\"> -------------- </span>|<span class=\"hljs-string\"> ----- </span>|\n|<span class=\"hljs-string\"> stage1     </span>|<span class=\"hljs-string\"> latest </span>|<span class=\"hljs-string\"> 19e76e412adc </span>|<span class=\"hljs-string\"> 25 seconds ago </span>|<span class=\"hljs-string\"> 989MB </span>|\n</code></pre>\n<p>1 GB ist eine stolze Größe. Das Image existiert allerdings nur auf dem Buildsystem und nicht auf dem Produktivserver.\nWürden wir unsere App mit diesem Image betreiben, hätten wir den zehnfachen Speicherbedarf...</p>\n<h2 id=\"grenzen-der-vorgestellten-lösung-\">Grenzen der vorgestellten Lösung <a name=\"grenzen-der-vorgestellten-loesung\"></a></h2>\n<p>Mit der vorgestellten Lösung können wir unsere App jederzeit mit den von uns festgelegten NPM-Paketen bauen, zumindest unter der Annahme, dass diese Pakete auch in Zukunft noch verfügbar sind. Die NPM Registry vergisst nichts, insofern bin ich da äußerst zuversichtlich.</p>\n<p>Mittelfristig verändern sich die Images natürlich, die die Basis der Lösung darstellen.\nNode 10 wird in neueren Versionen vorliegen, das Debian 10-Image wird ebenfalls mit Updates versorgt.\nUnsere App wird davon weitestgehend unbeeinflusst bleiben.\nAllerdings benötigen einige NPM-Pakete wie <code>node-gyp</code> beispielsweise sowohl den installierten Python-Interpreter als auch den C++-Compiler.\nDas kann im Einzelfall zu der einen oder anderen Änderungen in der von <code>ng build</code> erzeugten App führen, was meist nicht auffallen wird, weil Sie sowieso das eine oder andere Sicherheitsupdate für von Ihnen verwendete NPM-Pakete einpflegen müssen.</p>\n<p>Betrachten wir einen Zeitraum von zehn Jahren, sieht die Situation schon weniger rosig aus, weil es dann evtl. gar kein Node 10-Image mehr gibt...</p>\n<p>Damit sollte klar sein, dass die vorgestellte Lösung keine Art von Langzeit-Archivierung der Build-Umgebung bieten kann, weil kein Langzeit-Archiv der Abhängigkeiten wie der Basis-Images existiert.\nFalls dennoch genau das für Ihren Auftraggeber wichtig sein sollte, dann hat er das Problem typischerweise schon selbst für seine eigene Software im Griff, so dass Sie auf dessen Problemlösung zur Archivierung der Build-Umgebung zurückgreifen können (und sollten).\nFalls Sie sich selber darum kümmern müssten, müssen Sie letztendlich auf irgendeine Art für die Langzeitarchivierung der Abhängigkeiten aus obigem <code>Dockerfile</code> sorgen.</p>\n<p>Sie sehen, zumindest kurz- und mittelfristig brauchen Sie sich keine ernsthaften Gedanken um Ihre Build-Umgebung zu machen.\nLangfristig sieht das allerdings anders aus.</p>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Welche Methode sollten Sie also für Ihren Anwendungsfall wählen? Die Entscheidung ist meiner Meinung nach anhand der genannten Kriterien einfach zu treffen: \nWenn Sie mit den <code>environment.ts</code>-Dateien auskommen, bleiben Sie bei der Lösung aus Teil I, um Ihre App in einen Container zu packen.\nMöchten Sie die App in mehreren Umgebungen betreiben und deswegen die Konfiguration ändern, landen Sie automatisch bei der Lösung aus Teil II.\nUnd wenn es Ihnen wichtig ist, Ihre Build-Umgebung im Griff zu haben, verwenden Sie den Multi-Stage Build aus diesem Artikel, die Sie mit jeder der beiden zuvor genannten Methoden kombinieren können.</p>\n<p>Wie auch immer Sie sich entscheiden: Sie werden schnell merken, wie angenehm es ist, Ihre App mit Docker zum Laufen zu bringen.</p>\n<p>Und falls Sie sich doch einmal dafür entscheiden, einen Build Server wie Jenkins zu installieren und passend einzurichten, beschränkt sich Ihre finale Tätigkeit in jedem Projekt auf ein <code>git push</code>, woraufhin der Build Server die neueste Version Ihres Projekts auscheckt, den Multi-Stage Build auslöst und das Ergebnis\nauf dem Zielsystem zum Laufen bringt.</p>\n<p>Somit können Sie sich in Zukunft auf Ihre Kernkompetenzen beschränken und das tun, was Ihnen Spaß macht. Software entwickeln.\nUm den Build und das Deployment kümmern sich Ihre Automatismen, die dank Docker unkompliziert einzurichten sind.</p>\n<h2 id=\"rückblick-\">Rückblick <a name=\"rueckblick\"></a></h2>\n<p>Die Artikelserie besteht aus den folgenden Teilen:</p>\n<ol>\n<li><a href=\"https://angular-buch.com/blog/2019-12-docker0-intro\">Angular-Apps und Docker: Einleitung</a></li>\n<li><a href=\"https://angular-buch.com/blog/2019-12-docker1-simple-case\">Angular-App über Docker bereitstellen</a></li>\n<li><a href=\"https://angular-buch.com/blog/2019-12-docker2-build-once-run-anywhere\">Build Once, Run Anywhere oder: Konfiguration über Docker verwalten</a></li>\n<li><a href=\"https://angular-buch.com/blog/2019-12-docker3-multi-stage-build\">Multi-Stage Builds oder: Immer die Build-Umgebung dabei haben</a> <strong>(der aktuelle Artikel)</strong></li>\n</ol>\n<br>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Bild von <a href=\"https://unsplash.com/@chuttersnap\">chuttersnap</a> auf <a href=\"https://unsplash.com\">Unsplash</a>, bearbeitet</small></p>\n","meta":{"title":"[Docker Serie 4/4] Multi-Stage Builds oder: Immer die Build-Umgebung dabei haben","author":"Michael Kaaden","mail":"blog@kaaden.net","bio":"Michael Kaaden ist als Software-Architekt und Manager für ein mittelständisches Unternehmen in Nürnberg tätig. Dort ist er für die technische Seite einer Cloud-Produktline verantwortlich. In dieser Eigenschaft kümmert er sich trotz seiner grundsätzlichen Affinität zu Angular nicht nur um Frontends, sondern neben der Gesamtarchitektur unter anderem auch um APIs, Backends, Datenbanken sowie Software-Entwicklungs- und Build-Prozesse. Wenn er in seiner Freizeit nicht gerade mit seiner Familie unterwegs ist, Full-Stack Developer spielt oder seine Nase in neue Technologien steckt, versucht er, seinen Laufstil zu verbessern und endlich den für ihn perfekten Fotoapparat zu finden.","published":"2019-12-23T00:00:00.000Z","keywords":["Docker","Multi-Stage Builds"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2019-12-docker3-multi-stage-build/header3.jpg"}}
