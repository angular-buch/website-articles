{"slug":"2019-06-angular8","html":"<p>Der neueste Wurf aus der Softwareschmiede Google ist vollbracht: <strong>Angular 8 ist da!</strong>\nAm 28. Mai 2019 erschien die neue Major-Version 8.0.0 und bringt wieder einige interessante Neuerungen mit sich.</p>\n<p>Die wichtigsten Punkte sind Differential Loading und die neue Syntax für Lazy Loading.\nEs gibt kleine Breaking Changes, doch seien Sie beruhigt: Das Update geht leicht von der Hand, und es sind nur selten manuelle Anpassungen nötig.</p>\n<p>In diesem Artikel möchten wir kurz die wichtigsten Neuigkeiten vorstellen.\nDie offizielle Ankündigung zum neuen Release finden Sie im <a href=\"https://blog.angular.io/af0261112a27\">Angular Blog</a>.</p>\n<blockquote>\n<p><strong>Die Update-Infos für neuere Versionen von Angular finden Sie in separaten Blogartikeln. Wenn Sie das Update durchführen möchten, lesen Sie bitte alle Artikel in der gegebenen Reihenfolge.</strong></p>\n<ul>\n<li><a href=\"/blog/2020-02-angular9\">Angular 9 ist da!</a></li>\n<li><a href=\"/blog/2020-06-angular10\">Angular 10 ist da!</a></li>\n<li><a href=\"/blog/2020-11-angular11\">Angular 11 ist da!</a></li>\n<li><a href=\"/blog/2021-06-angular12\">Angular 12 ist da!</a></li>\n<li><a href=\"/blog/2021-11-angular13\">Angular 13 ist da!</a></li>\n<li><a href=\"/blog/2022-06-angular14\">Angular 14 ist da!</a></li>\n<li><a href=\"/blog/2022-11-angular15\">Angular 15 ist da!</a></li>\n<li><a href=\"/blog/2023-05-angular16\">Angular 16 ist da!</a></li>\n</ul>\n</blockquote>\n<h2 id=\"update-auf-angular-8\">Update auf Angular 8</h2>\n<p>Das Update zur neuen Angular-Version ist kinderleicht. Hierzu führen Sie einfach den folgenden Befehl in einem bestehenden Projekt aus:</p>\n<pre><code class=\"language-sh\"><span class=\"hljs-attribute\">ng</span> update <span class=\"hljs-variable\">@angular</span>/cli <span class=\"hljs-variable\">@angular</span>/core\n</code></pre>\n<p>Die Angular CLI führt automatisch alle nötigen Anpassungen am Code der Anwendung durch.\nAuf <a href=\"https://update.angular.io/#7.0:8.0\">update.angular.io</a> können Sie außerdem alle Migrationsschritte nachvollziehen.</p>\n<h2 id=\"differential-loading-mehrere-bundles-für-unterschiedliche-browser\">Differential Loading: Mehrere Bundles für unterschiedliche Browser</h2>\n<p>Ein bekanntes Praxisproblem mit Angular ist die Größe der ausgelieferten Bundles.\nWarum ein Bundle groß und &quot;unhandlich&quot; wird, kann verschiedene Ursachen haben und kann auf verschiedene Weise strategisch gelöst werden, z. B. durch Code Splitting, Tree Shaking oder Lazy Loading.</p>\n<p>Alle modernen Browser unterstützen mindestens den JavaScript-Standard ES2015.\nDennoch werden die meisten Angular-Anwendungen weiterhin in ES5 kompiliert, um auch in älteren Browsern lauffähig zu sein – ein wichtiger Grund für wachsende Bundles.\nAußerdem müssen Polyfills ausgeliefert werden, um Funktionalitäten in älteren Browsern nachzurüsten.</p>\n<p>An dieser Stelle kommt ein neues Feature der Angular CLI ins Spiel: Differential Loading.\nDie Angular CLI produziert dabei verschiedene Bundles der Anwendung – für ältere Browser in ES5 und für neuere Browser in ES2015 oder höher.\nDer Browser lädt schließlich nur die Bundles herunter, die für ihn relevant sind.\nSomit können moderne Browser auf neuere Features zugreifen und müssen nicht zusätzlich Polyfills für Features laden, die Sie bereits nativ unterstützen.\nÄltere Browser greifen auf die sogenannten &quot;Legacy Bundles&quot; zurück und laden Polyfills und fehlende Funktionen zusätzlich zum Anwendungscode.</p>\n<p>Die Neuerung führt vor allem bei modernen Browsern zu Performance-Verbessungen, weil weniger Code geladen werden muss.</p>\n<p><img src=\"https://website-articles.angular-buch.com/2019-06-angular8/diffloading.png\" alt=\"Screenshot Build mit Differential Loading\"></p>\n<h2 id=\"lazy-loading-dynamische-imports-statt-magic-strings\">Lazy Loading: Dynamische Imports statt Magic-Strings</h2>\n<p>Angular unterstützt nun von Haus aus das <code>import()</code>-Statement zum programmatischen Nachladen von Modulen.\nDadurch ändert sich die Schreibweise beim Routing, um Lazy Loading zu konfigurieren.\nDie bisherige Syntax verwendet einen &quot;Magic String&quot;, um das zu ladende Modul anzugeben:</p>\n<pre><code class=\"language-ts\">{\n  <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;mypath&#x27;</span>,\n  loadChildren: <span class=\"hljs-string\">&#x27;./foo/foo.module#FooModule&#x27;</span>\n}\n</code></pre>\n<p>Diese Schreibweise ist <strong>ab Angular 8</strong> <a href=\"https://github.com/angular/angular/pull/30073\">als <strong>deprecated</strong> gekennzeichnet</a>.\nStattdessen wird ein dynamischer Import verwendet, um das Modul beim Routing nachzuladen:</p>\n<pre><code class=\"language-ts\">{\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;mypath&#x27;</span>,\n  <span class=\"hljs-attr\">loadChildren</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./foo/foo.module&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> m.FooModule)\n}\n</code></pre>\n<p>Die Syntax sieht zunächst ungewohnt aus.\nIm Wesentlichen besteht der Befehl allerdings nur aus einer anonymen Funktion, die aufgerufen wird, wenn die Route aktiviert wird.\nSie ruft <code>import()</code> auf und extrahiert im zweiten Schritt das Angular-Modul <code>FooModule</code> aus dem heruntergeladenen Bundle.\nDiese neue Variante arbeitet vollständig mit nativen Features und ohne einen Magic String, der spezifisch für Angular ist.\nDadurch unterstützt die IDE den Entwickler mit Autovervollständigung und Typprüfung.</p>\n<p>Wenn Sie das Update mit der Angular CLI durchführen, werden die Magic Strings automatisch zur neuen Schreibweise migriert.\nIn der zweiten Auflage des Angular-Buchs, die im Juni 2019 erscheint, ist der neue Weg übrigens schon beschrieben.</p>\n<p>Mehr zur neuen Schreibweise für Lazy Loading erfahren Sie auch in der <a href=\"https://v8.angular.io/guide/deprecations#loadchildren-string-syntax\">Angular-Dokumentation</a>.</p>\n<h2 id=\"breaking-change-viewchild-und-contentchild\">Breaking Change: <code>@ViewChild()</code> und <code>@ContentChild()</code></h2>\n<p>Mit den Dekoratoren <code>@ViewChild()</code> und <code>@ContentChild()</code> können Querys auf DOM-Elemente in der View einer Komponente/Direktive gestellt werden.\nBisher war das Verhalten der Querys nicht gut nachvollziehbar.\nDas Verhalten ist nun besser dokumentiert, und man soll sich bei bestehendem Code über die Auswirkungen Gedanken machen.\nIn Angular 8 gibt zu diesem Zweck eine Übergangsphase, in der man das Verhalten explizit angeben muss. Hierzu müssen Querys zusätzlich mit dem Flag <code>static</code> versehen werden: Damit wird definiert, ob es sich bei der Abfrage um eine statisches oder dynamisch veränderbares Element handelt.\nStatische Elemente werden einmalig gerendert und sind dann zur Laufzeit der Komponente verfügbar, dynamische Elemente werden zur Laufzeit verändert.</p>\n<p><strong>Bis Angular 7</strong> wurden <code>@ViewChild()</code> und <code>@ContentChild()</code> wie folgt verwendet.\nDas Ergebnis ist dann im LifeCycle-Hook <code>ngOnInit()</code> <em>oder</em> <code>ngAfterViewInit()</code> verfügbar – das genaue Verhalten richtet sich jedoch nach der Struktur des Templates und ist nicht sicher vorhersehbar:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>) <span class=\"hljs-attribute\">foo</span>: ElementRef;\n<span class=\"hljs-variable\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>) <span class=\"hljs-attribute\">bar</span>: ElementRef;\n</code></pre>\n<p><strong>Ab Angular 8</strong> müssen <code>@ViewChild()</code> und <code>@ContentChild()</code> immer das Flag <code>static</code> tragen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Statische Query: Ergebnis ist im LifeCycle-Hook `ngOnInit()` verfügbar</span>\n<span class=\"hljs-variable\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: true }) <span class=\"hljs-attribute\">foo</span>: ElementRef;\n<span class=\"hljs-variable\">@ContentChild</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: true }) <span class=\"hljs-attribute\">bar</span>: ElementRef;\n\n<span class=\"hljs-comment\">// Dynamische Query: Ergebnis ist im LifeCycle-Hook `ngAfterViewInit()` verfügbar</span>\n<span class=\"hljs-variable\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: false }) <span class=\"hljs-attribute\">foo</span>: ElementRef;\n<span class=\"hljs-variable\">@ContentChild</span>(<span class=\"hljs-string\">&#x27;bar&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: false }) <span class=\"hljs-attribute\">bar</span>: ElementRef;\n</code></pre>\n<p><strong>Ab Angular 9</strong> wird der Wert <code>false</code> wieder das Standardverhalten sein.</p>\n<h3 id=\"automatische-migration\">Automatische Migration</h3>\n<p>Verwenden Sie die Angular CLI für das Update auf Angular 8, so wird die Migration automatisch durchgeführt.\nSollte das Migrationsskript nicht identifizieren können, welcher Wert für <code>static</code> gesetzt werden muss, so wird an der entsprechenden Stelle ein Hinweis eingefügt, und Sie müssen manuell „Hand anlegen“:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">/* <span class=\"hljs-doctag\">TODO:</span> add static flag */</span>\n</code></pre>\n<h3 id=\"statisch-oder-dynamisch--die-richtige-einstellung-wählen\">Statisch oder dynamisch? – die richtige Einstellung wählen</h3>\n<p>Wir empfehlen Ihnen, im Regelfall die Einstellung <code>false</code> zu verwenden.\nDas führt dazu, dass das Ergebnis der Abfrage im Lifecycle-Hook <code>ngAfterViewInit()</code> bzw. <code>ngAfterContentInit()</code> verfügbar ist.\nSomit können Sie sichergehen, dass die Change Detection vollständig ausgeführt wurde und das angefragte Element vollständig geladen wurde.</p>\n<p>Die Einstellung <code>{ static: true }</code> benötigen Sie nur in wenigen Fällen, beispielsweise wenn Sie auf ein <code>TemplateRef</code> zugreifen wollen, um daraus eine eingebettete View zu generieren.\nDiese Aktion können Sie nicht in <code>ngAfterViewInit()</code> ausführen, weil die Change Detection bereits ausgeführt wurde und die Aktion dann nicht in der View sichtbar wäre.</p>\n<p>Lesen Sie mehr zum Thema in der offiziellen <a href=\"https://v8.angular.io/guide/static-query-migration\">Angular-Dokumentation</a>.</p>\n<p>Übrigens: Falls Sie <code>@ViewChildren()</code> oder <code>@ContentChildren()</code> verwenden, müssen Sie nichts ändern – solche Querys sind immer dynamisch.</p>\n<h2 id=\"der-neue-ivy-renderer-opt-in-preview\">Der neue Ivy-Renderer: Opt-In Preview</h2>\n<p>Die neue Rendering-Engine <em>Ivy</em> kann in Angular 8 als freiwilliges Opt-In aktiviert und genutzt werden.\nZum Ausprobieren können Sie in einem Projekt mit Angular 8 in der Datei <code>src/tsconfig.app.json</code> das Flag <code>enableIvy</code> setzen:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">...</span>\n  <span class=\"hljs-string\">&quot;angularCompilerOptions&quot;</span>: {\n    <span class=\"hljs-string\">&quot;enableIvy&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">...</span>\n  }\n}\n</code></pre>\n<p>Alternativ können Sie beim Anlegen eines neuen Angular-Projekts auch direkt die Option <code>--enable-ivy</code> nutzen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> my-app <span class=\"hljs-comment\">--enable-ivy</span>\n</code></pre>\n<p>Ivy soll mit Angular 9 standardmäßig für alle Projekte aktiviert werden.\nBis dahin wird die neue Engine noch einem umfangreichen Praxistest unterzogen.\nEinige Features lassen auf sich warten, zum Beispiel die Integration für Internationalisierung (i18n).\nDas neue Tooling soll Übersetzungen zur Laufzeit erlauben und auch einen Service zur programmatischen Übersetzung mitbringen. Bis dahin müssen wir uns aber noch gedulden.\nSollte Ihre Anwendung die Internationalisierung von Angular verwenden, so können Sie Ivy noch nicht aktivieren.</p>\n<p>Für detaillierte Informationen zu Ivy können wir den Blogartikel <a href=\"https://blog.nrwl.io/243be844bf36\">&quot;Understanding Angular Ivy: Incremental DOM and Virtual DOM&quot;</a> von Victor Savkin empfehlen.</p>\n<h2 id=\"weitere-neuigkeiten\">Weitere Neuigkeiten</h2>\n<p>Wir haben in diesem Artikel natürlich nur die wichtigsten Änderungen und Neuigkeiten erwähnt.\nDas neue Major-Release bringt dazu eine Vielzahl von Bugfixes, Optimierungen unter der Haube und kleinere Features, die für die meisten Entwicklerinnen und Entwickler zunächst nicht relevant sind.</p>\n<p>Beispielsweise verfügt die Angular CLI 8 über die neue <strong>Builders API</strong>.\nDamit kann der Buildprozess für ein Projekt durch eigene Skripte gesteuert werden.\nEinen Einstieg in die neue Schnittstelle <a href=\"https://blog.angular.io/d012d4489f1b\">liefert Hans Larsen in einem Blogartikel</a>.\nAußerdem soll es perspektivisch möglich sein, die Anwendung mit der Angular CLI auf verschiedene Cloud Services zu deployen.</p>\n<p>Zusätzlich wird die Integration von <strong>Googles Buildwerkzeug <a href=\"https://bazel.angular.io/\">Bazel</a></strong> stetig verbessert – auch hierzu sind im neuen Release von Angular einige Commits zu finden.\nBazel für Angular ist derzeit als Opt-In Preview verfügbar.\nZum Thema möchten wir einen <a href=\"https://www.youtube.com/watch?v=J1lnp-nU4wM\">Vortrag von Alex Eagle von der ng-conf 2019</a> empfehlen.</p>\n<p>Außerdem sind die folgenden Änderungen interessant:</p>\n<ul>\n<li>Das <code>FormArray</code> verfügt jetzt über eine Methode <code>clear()</code>, um alle Bestandteile aus der Liste zu entfernen (siehe <a href=\"https://github.com/angular/angular/pull/28918\">#28918</a>).</li>\n<li><code>AbstractControl</code> (und damit auch <code>FormGroup</code>, <code>FormArray</code> und <code>FormControl</code>) besitzen eine Methode <code>markAllAsTouched()</code>, um alle Felder rekursiv als <code>touched</code> zu markieren. Das kann dann sinnvoll sein, wenn ein Formular vor dem Absenden alle fehlenden Felder visualisieren soll (siehe <a href=\"https://github.com/angular/angular/pull/26812\">#26812</a>).</li>\n<li><code>TestBed.get()</code> erhält ab sofort typisierte Argumente, liefert aber nach wie vor <code>any</code> zurück (siehe <a href=\"https://github.com/angular/angular/pull/29290\">#29290</a>).</li>\n<li>Das DI-Token <code>DOCUMENT</code> wird nur noch von <code>@angular/common</code> exportiert, nicht mehr von <code>@angular/platform-browser</code> (siehe <a href=\"https://github.com/angular/angular/pull/28117\">#28117</a>).</li>\n</ul>\n<p>Generell lohnt sich immer ein Blick in den <a href=\"https://github.com/angular/angular/CHANGELOG.md\">Changelog von Angular</a>, um die Entwicklung aktiv mitzuverfolgen.</p>\n<hr>\n\n<p>Haben Sie Fragen zur neuen Version, zum Update oder zu Angular? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß mit Angular wünschen<br>\nJohannes, Danny und Ferdinand</strong></p>\n<blockquote>\n<p><strong>Übrigens: Unser neues Angular-Buch erscheint am 14. Juni 2019 im Handel – vollständig aktualisiert und erweitert. Alle Beispiele sind bereits auf dem Stand von Angular 8. 😊</strong></p>\n</blockquote>\n<p><small><strong>Titelbild:</strong> Badwater Basin, Death Valley National Park, California, 2019. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 8 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2019-05-28T00:00:00.000Z","lastModified":"2019-05-28T00:00:00.000Z","keywords":["Angular","Angular 8","Differential Loading","Lazy Loading","Ivy"],"language":"de","header":{"url":"angular8.jpg","width":2200,"height":857},"sticky":false,"hidden":false}}
