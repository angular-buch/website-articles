{"slug":"2025-05-effect-afterrendereffect","html":"<p>Mit Angular 19 gibt es eine wichtige Neuerung: Die <code>effect()</code>-API wurde vereinfacht und die neue Funktion <code>afterRenderEffect()</code> wurde eingef√ºhrt (siehe <a href=\"https://github.com/angular/angular/pull/57549\">PR 57549</a>).\nDiese Neuerung hat Auswirkungen darauf, wie Angular Aufgaben nach dem Rendern behandelt, und ist besonders n√ºtzlich f√ºr Anwendungen, die auf pr√§zises Timing beim Rendern und bei DOM-Manipulationen angewiesen sind.\nIn diesem Artikel sehen wir uns an, wie sich diese beiden APIs unterscheiden und wie man die phasenbasierte Ausf√ºhrung mit <code>afterRenderEffect()</code> optimal nutzt.</p>\n<h2 id=\"angular-19-vs-vorherige-versionen-was-ist-anders\">Angular 19 vs. vorherige Versionen: Was ist anders?</h2>\n<p>Die <code>effect()</code>-Schnittstelle wurde als Teil des neuen Signal-basierten Reaktivit√§tsmodells von Angular <a href=\"https://blog.angular.dev/angular-v16-is-here-4d7a28ec680d\">in Angular 16</a> eingef√ºhrt .\nAngular 19 f√ºhrt nun ein bedeutendes Update f√ºr <code>effect()</code>: Es ist jetzt einfacher, Seiteneffekte direkt innerhalb von Effects auszuf√ºhren, sogar wenn darin Signals verwendet werden.\nVorher war der Einsatz von <code>effect()</code> stark eingeschr√§nkt: Es wurde davon abgeraten, innerhalb eines Effects die Werte von Signals zu setzen.\nUm dieses Verhalten zu erlauben, musste das Flag <code>allowSignalWrites</code> aktiviert werden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ALTER WEG</span>\neffect(() =&gt; {\n  <span class=\"hljs-keyword\">this</span>.mySignal.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&#x27;demo&#x27;</span>);\n}, { allowSignalWrites: <span class=\"hljs-keyword\">true</span> })\n</code></pre>\n<p>Fr√ºher riet die Angular-Dokumentation davon ab, Signals in <code>effect()</code> zu setzen, da dies zu Problemen wie dem Fehler <code>ExpressionChangedAfterItHasBeenChecked</code>, zyklischen Aktualisierungen oder unn√∂tigen Durchl√§ufen der Change Detection f√ºhren konnte.\nEs wurde empfohlen, Effects nur f√ºr bestimmte Seiteneffekte zu verwenden, wie z. B.:</p>\n<ul>\n<li>Logging von √Ñnderungen zu Analyse- oder Debugging-Zwecken,</li>\n<li>Synchronisierung der Daten mit lokalem Browserspeicher (z. B. <code>window.localStorage</code>),</li>\n<li>Implementierung von benutzerdefinierten DOM-Verhaltensweisen, die mit der Template-Syntax nicht erreicht werden k√∂nnen, oder</li>\n<li>Umgang mit UI-Bibliotheken von Drittanbietern, wie z. B. das Rendern auf ein <code>&lt;canvas&gt;</code>-Element oder die Integration von Charting-Bibliotheken.</li>\n</ul>\n<p>Allerdings stellte sich heraus, dass das Flag <code>allowSignalWrites</code> in der Praxis viel zu h√§ufig eingesetzt wurde. Das Flag war als Ausnahme geplant, doch es kam in der Praxis regelm√§√üig in legitimen F√§llen zum Einsatz, in denen das Setzen von Signals sinnvoll oder sogar notwendig war, wie z. B. das Aktualisieren eines Signals nach einer Reihe von √Ñnderungen oder das Verarbeiten von mehreren Signals.\nAls Reaktion darauf erlaubt der neue Ansatz von Angular nun standardm√§√üig das Setzen von Signals innerhalb von <code>effect()</code>, wodurch die Notwendigkeit von <code>allowSignalWrites</code> entf√§llt.\nDieses flexiblere Design spiegelt das Engagement von Angular wider, die Entwicklung zu vereinfachen.\nSiehe den <a href=\"https://blog.angular.dev/latest-updates-to-effect-in-angular-f2d2648defcd\">offiziellen Blog-Post</a>, der diese neue Anleitung best√§tigt.</p>\n<p>Wir interpretieren diese Neuerung wie folgt:</p>\n<blockquote>\n<p>üí° <strong>Es ist jetzt ein g√ºltiger Anwendungsfall, <code>effect()</code> f√ºr Zustands√§nderungen oder Seiteneffekte zu verwenden, die sich mit anderen reaktiven Konzepten wie <code>computed()</code> nur schwer umsetzen lassen.</strong></p>\n</blockquote>\n<p>Dieser Paradigmenwechsel steht im Einklang mit neuen Funktionen, die in Angular 19 eingef√ºhrt wurden, wie <a href=\"https://angular.schule/blog/2024-11-linked-signal\"><code>linkedSignal()</code></a> und <code>resource()</code>.\nBeide helfen dabei, saubereren und deklarativeren Code zu erreichen.\nGute Patterns werden nicht mehr durch das <code>allowSignalWrites</code>-Flag erzwungen, sondern durch n√ºtzliche High-Level-Signal-APIs, welche direkt vom Angular-Team bereitgestellt werden.</p>\n<p>Mit diesem Wandel ergibt sich eine neue Faustregel:</p>\n<ul>\n<li><strong>Verwende <code>effect()</code></strong>, f√ºr Aufgaben, die traditionell in <code>ngOnInit</code> oder <code>ngOnChanges</code> erledigt wurden.</li>\n<li><strong>Verwende <code>afterRenderEffect()</code></strong>, f√ºr Aufgaben, die typischerweise in <code>ngAfterViewInit</code> oder <code>ngAfterViewChecked</code> stattfinden ‚Äì oder wenn du direkt mit gerendertem DOM arbeiten musst.</li>\n</ul>\n<p>Wir wollen in den folgenden Abschnitten in die Details einsteigen! üöÄ</p>\n<h2 id=\"kernunterschiede-zwischen-effect-und-afterrendereffect\">Kernunterschiede zwischen <code>effect()</code> und <code>afterRenderEffect()</code></h2>\n<p>Sowohl <code>effect()</code> als auch <code>afterRenderEffect()</code> sind darauf ausgelegt, √Ñnderungen in Signals zu verfolgen und darauf zu reagieren, aber sie unterscheiden sich im Timing und in den Anwendungsf√§llen.</p>\n<ul>\n<li><strong><code>effect()</code></strong> wird als Teil der Change Detection ausgef√ºhrt und kann nun Signals sicher und ohne zus√§tzliche Flags ver√§ndern.</li>\n<li><strong><code>afterRenderEffect()</code></strong> ist eine Low-Level-API, die ausgef√ºhrt wird, nachdem der DOM aktualisiert wurde. \nSie eignet sich besonders f√ºr Aufgaben, die eine direkte Interaktion mit dem DOM erfordern, wie das Messen von Elementgr√∂√üen oder komplexe visuelle Aktualisierungen.</li>\n</ul>\n<p>Hier ist ein einfacher Vergleich, um die Funktionsweise dieser Funktionen zu veranschaulichen:</p>\n<pre><code class=\"language-typescript\">counter = signal(<span class=\"hljs-number\">0</span>);\n\neffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">`Aktueller Wert: <span class=\"hljs-subst\">${this.counter()}</span>`</span>);\n});\n\nafterRenderEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;DOM-Rendering f√ºr diese Komponente abgeschlossen&#x27;</span>);\n});\n</code></pre>\n<p>Wie erwartet, wird die Konsolenausgabe f√ºr <code>afterRenderEffect()</code> nach der Ausgabe von <code>effect()</code> ausgel√∂st.</p>\n<h2 id=\"vorstellung-von-effect\">Vorstellung von <code>effect()</code></h2>\n<p>In diesem Artikel behandeln wir Effects, die innerhalb einer Komponente erstellt werden. \nDiese werden <strong>Component Effects</strong> genannt und erm√∂glichen das sichere Lesen und Schreiben der Propertys und Signals aus der Komponentenklasse. \nEs ist auch m√∂glich, Effects in Services zu erstellen. \nWenn ein Dienst auf dem Root-Level der Anwendung bereitgestellt wird (auch bekannt als Singleton), werden diese Effekte <strong>root effects</strong> genannt.</p>\n<p>Der Hauptunterschied zwischen diesen Arten von Effects ist ihr Timing. \nComponent Effects arbeiten als Teil der Change Detection, so dass wir sicher andere Signals lesen und Views verwalten k√∂nnen, die vom Komponentenzustand abh√§ngen. \nRoot-Effekte hingegen laufen als Microtasks, unabh√§ngig vom Komponentenbaum oder der Change Detection.</p>\n<p>In diesem Artikel konzentrieren wir uns ausschlie√ülich auf <strong>Component Effects</strong>, die das sichere Lesen und Schreiben von Signals innerhalb von Komponenten erm√∂glichen.</p>\n<h3 id=\"beispiel-f√ºr-effect-mehrere-werte-setzen\">Beispiel f√ºr <code>effect()</code>: mehrere Werte setzen</h3>\n<p>Im folgenden Beispiel verwenden wir <code>effect()</code>, um Formularfelder basierend auf dem Eingabesignal <code>currentBook</code> zu synchronisieren.\nDie API f√ºr Reactive Forms wurde leider noch nicht aktualisiert - Signal Forms sind aktuell noch in einer fr√ºhen Entwicklungs-Phase (siehe das Projekt <a href=\"https://github.com/orgs/angular/projects/60\">Experimental Signal Forms</a>). Daher m√ºssen wir unsere Formulare immer noch patchen, sowie wir es in der Vergangenheit bereits stets tun mussten.\nWir wollen auch ein weiteres Signal setzen, nachdem wir das Formular gepatcht haben.</p>\n<p>Hier ist unser Beispiel f√ºr ein Formular, das ein neues Buch erstellen und ein bestehendes Buch bearbeiten kann:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-book-form&#x27;</span>,\n  imports: [ReactiveFormsModule],\n  template: `\n    @let c = bookForm.controls;\n\n    &lt;form [formGroup]=<span class=\"hljs-string\">&quot;bookForm&quot;</span> (ngSubmit)=<span class=\"hljs-string\">&quot;submitForm()&quot;</span>&gt;\n      &lt;label for=<span class=\"hljs-string\">&quot;isbn&quot;</span>&gt;ISBN&lt;/label&gt;\n      &lt;input id=<span class=\"hljs-string\">&quot;isbn&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;c.isbn&quot;</span> /&gt;\n\n      &lt;label for=<span class=\"hljs-string\">&quot;Titel&quot;</span>&gt;Titel&lt;/label&gt;\n      &lt;input id=<span class=\"hljs-string\">&quot;Titel&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;c.title&quot;</span> /&gt;\n\n      &lt;label for=<span class=\"hljs-string\">&quot;description&quot;</span>&gt;Beschreibung&lt;/label&gt;\n      &lt;textarea id=<span class=\"hljs-string\">&quot;description&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;c.description&quot;</span>&gt;&lt;/textarea&gt;\n\n      @let formLabel = isEditMode() ? <span class=\"hljs-string\">&#x27;Buch bearbeiten&#x27;</span> : <span class=\"hljs-string\">&#x27;Buch erstellen&#x27;</span>;\n      &lt;button type=<span class=\"hljs-string\">&quot;submit&quot;</span> [attr.aria-label]=<span class=\"hljs-string\">&quot;formLabel&quot;</span>&gt;\n        {{ formLabel }}\n      &lt;/button&gt;\n    &lt;/form&gt;\n  `,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookFormComponent</span> {\n\n  currentBook = input&lt;Book | undefined&gt;();\n\n  bookForm = new FormGroup({\n    isbn: new FormControl(<span class=\"hljs-comment\">/* ... */</span>),\n    title: new FormControl(<span class=\"hljs-comment\">/* ... */</span>),\n    description: new FormControl(<span class=\"hljs-comment\">/* ... */</span>),\n  });\n  \n  isEditMode = signal(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">constructor</span>() {\n    effect(() =&gt; {\n      <span class=\"hljs-keyword\">const</span> book = <span class=\"hljs-keyword\">this</span>.currentBook();\n      <span class=\"hljs-keyword\">if</span> (book) {\n        <span class=\"hljs-keyword\">this</span>.bookForm.patchValue(book);\n        <span class=\"hljs-keyword\">this</span>.bookForm.controls.isbn.disable();\n        <span class=\"hljs-keyword\">this</span>.isEditMode.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-literal\">true</span>);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>.bookForm.controls.isbn.enable();\n        <span class=\"hljs-keyword\">this</span>.isEditMode.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-literal\">false</span>);\n      }\n    });\n }\n\n  submitForm() {\n    <span class=\"hljs-comment\">// ...Logik f√ºr die Formular√ºbermittlung</span>\n  }\n}\n</code></pre>\n<p>In diesem Beispiel bietet sich <code>effect()</code> f√ºr die Behandlung des Seiteneffekts (√Ñnderung des Formulars) an, ohne dass unn√∂tige Berechnungen durchgef√ºhrt werden m√ºssen. \nZudem k√∂nnen wir jetzt problemlos Signals im Effekt setzen.\nUm zu zeigen, dass dieser Ansatz nun valide ist, haben wir w√§hrend dieser Phase ein weiteres Signal aktualisiert.\nWir haben ein Signal namens <code>isEditMode</code> definiert, das abh√§ngig vom Input-Signal <code>book</code> aktualisiert wird.\nIn der Vergangenheit h√§tte man <code>ngOnChanges</code> eingesetzt, um das Formular zu patchen, wenn Inputs ge√§ndert wurden.</p>\n<h3 id=\"wann-sollte-man-effect-anstatt-computed-verwenden\">Wann sollte man <code>effect()</code> anstatt <code>computed()</code> verwenden?</h3>\n<p>Die fr√ºheren Einschr√§nkungen f√ºr <code>effect()</code> wurden entfernt, so dass es jetzt schwieriger ist, zu entscheiden, wann <code>computed()</code> oder <code>effect()</code> verwendet werden soll.\nUnserer Meinung nach h√§ngt es vom Anwendungsfall ab:</p>\n<ul>\n<li><strong>Verwenden Sie <code>computed()</code></strong> f√ºr die Ableitung eines Werts, der auf anderen Signals basiert, insbesondere wenn Sie einen reinen, nur lesbaren reaktiven Wert ben√∂tigen. Innerhalb eines Computed-Signals ist es grunds√§tzlich nicht erlaubt, andere Signals zu setzen.\nWir haben <code>computed()</code> und <code>linkedSignal()</code> in diesem Artikel behandelt: <strong><a href=\"https://angular-buch.com/blog/2024-11-linked-signal\">Neu in Angular 19: LinkedSignal f√ºr reaktive Zustandsverwaltung</a></strong></li>\n<li><strong>Verwenden Sie <code>effect()</code></strong>, wenn die Operation komplexer ist, das Setzen mehrerer Signals beinhaltet oder Seiteneffekte au√üerhalb der Welt der Signals erfordert, wie zum Beispiel das Synchronisieren reaktiver Formularzust√§nde oder das Protokollieren von Ereignissen.</li>\n</ul>\n<p>F√ºr das Patchen von Formularen gibt es derzeit keinen besseren Ansatz als die Verwendung von Effekten. \nDer Einsatz von Effect kann auch gut f√ºr die Migration von bestehendem Code verwendet werden, der zuvor auf <code>ngOnChanges</code> gesetzt hat.\nEs bleibt √ºbrigens fraglich, ob ein Computed-Signal nicht besser f√ºr den Zustand <code>isEditMode</code> geeignet gewesen w√§re.\nFolgendes ist n√§mlich ebenso m√∂glich:</p>\n<pre><code class=\"language-ts\">isEditMode = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> !!this.currentBook());\n</code></pre>\n<p>Es ist nicht einfach, hier eine Entscheidung zu treffen, und die Umsetzung h√§ngt stark vom pers√∂nlichen Geschmack ab.\nWir akzeptieren, dass beide Optionen je nach Situation ihre volle Berechtigung haben. üôÇ</p>\n<h2 id=\"vorstellung-von-afterrendereffect\">Vorstellung von <code>afterRenderEffect()</code></h2>\n<p>W√§hrend <code>effect()</code> f√ºr die generelle reaktive Zustandsverwaltung gedacht ist und t√§glich zum Einsatz kommen wird, ist <code>afterRenderEffect()</code> spezieller und f√ºr fortgeschrittene F√§lle reserviert. \nDie API wurde speziell f√ºr Szenarien entwickelt, die ein pr√§zises Timing erfordern, nachdem Angular einen Rendering-Zyklus abgeschlossen hat. \nDies ist n√ºtzlich f√ºr komplexe DOM-Manipulationen, die nicht allein mit Angulars Reaktivit√§t erreicht werden k√∂nnen und oft an Low-Level-Updates gebunden sind:\nMessen von Elementgr√∂√üen, die direkte Verwaltung von Animationen oder die Orchestrierung von Drittanbieter-Bibliotheken.</p>\n<p>Mit der neuen Funktion <code>afterRenderEffect()</code> k√∂nnen wir steuern, wann bestimmte Aufgaben w√§hrend des DOM-Aktualisierungsprozesses ausgef√ºhrt werden.\nDie API selbst spiegelt die Funktionalit√§t von </p>\n<ul>\n<li><a href=\"https://angular.dev/api/core/afterEveryRender\"><code>afterEveryRender</code></a> <em>(registriert Callbacks, das jedes Mal aufgerufen wird, wenn die Anwendung das Rendern beendet)</em> und</li>\n<li><a href=\"https://angular.dev/api/core/afterNextRender\"><code>afterNextRender</code></a> <em>(registriert Callbacks, die das n√§chste Mal aufgerufen werden, wenn die Anwendung das Rendering beendet, w√§hrend der angegebenen Phasen)</em>.</li>\n</ul>\n<p>Die Dokumentation empfiehlt, explizite Phasen mit <code>afterNextRender</code> anzugeben, um erhebliche Leistungseinbu√üen zu vermeiden. \nEine √§hnliche Empfehlung gibt es auch f√ºr <code>afterRenderEffect()</code>: Es gibt eine Signatur, die f√ºr die Verwendung vorgesehen ist, und eine andere, die zwar existiert, aber nicht empfohlen wird.</p>\n<p>Es gibt zudem einen gro√üen Unterschied zwischen den bestehenden Hook-Funktionen und dem neuen <code>afterRenderEffect()</code>:</p>\n<blockquote>\n<p><strong>üí° Werte werden von Phase zu Phase als Signals und nicht als einfache Werte weitergegeben.</strong></p>\n</blockquote>\n<p>Dadurch ist es m√∂glich, dass sp√§tere Phasen nicht ausgef√ºhrt werden m√ºssen, wenn sich die von fr√ºheren Phasen zur√ºckgegebenen Werte nicht √§ndern und wenn keine anderen Abh√§ngigkeiten etabliert wurden (dazu gleich mehr).\nBevor wir beginnen, hier einige wichtige Fakten √ºber die Effects, die durch <code>afterRenderEffect()</code> erzeugt werden:</p>\n<ul>\n<li><strong>Post-Render Execution:</strong> Diese Effects werden ausgef√ºhrt, wenn es sicher ist, √Ñnderungen am DOM vorzunehmen. (<a href=\"https://docs.google.com/presentation/d/1puZmyZ-dgnt6_b0nOBaDMpyf_FmQld1h8yAmWxjA6gk/edit?usp=sharing\">Quelle: Keynote-Folien von ng-poland 2024</a>)</li>\n<li><strong>Phased Execution:</strong> Diese Effects k√∂nnen f√ºr bestimmte Phasen des Renderzyklus registriert werden. \nDas Angular-Team empfiehlt, diese Phasen f√ºr eine optimale Leistung einzuhalten.</li>\n<li><strong>Vollst√§ndig kompatibel mit Signals</strong> Diese Effects arbeiten nahtlos mit dem Signal-Reaktivit√§tssystem von Angular zusammen, und Signals k√∂nnen w√§hrend der Phasen gesetzt werden.</li>\n<li><strong>Selektive Ausf√ºhrung:</strong> Diese Effects werden mindestens einmal ausgef√ºhrt, aber nur dann erneut, wenn sie aufgrund von Signalabh√§ngigkeiten als &quot;dirty&quot; markiert sind. Wenn sich kein Signal √§ndert, wird der Effekt nicht erneut ausgel√∂st.</li>\n<li><strong>Kein SSR:</strong> Diese Effects werden nur in Browserumgebungen ausgef√ºhrt, nicht auf dem Server.</li>\n</ul>\n<h3 id=\"die-effekt-phasen-verstehen\">Die Effekt-Phasen verstehen</h3>\n<p>Die phasenweise Ausf√ºhrung hilft, unn√∂tige Neuberechnungen zu vermeiden.\nWir k√∂nnen Effekte f√ºr jede Phase registrieren, indem wir eine Callback-Funktion angeben:</p>\n<pre><code class=\"language-ts\">afterRenderEffect({\n\n  <span class=\"hljs-comment\">// DOM-Eigenschaften vor dem Schreiben lesen</span>\n  earlyRead: <span class=\"hljs-function\">(<span class=\"hljs-params\">onCleanup: EffectCleanupRegisterFn</span>) =&gt;</span> E,\n\n  <span class=\"hljs-comment\">// Ausf√ºhren von DOM-Schreiboperationen</span>\n  write: <span class=\"hljs-function\">(<span class=\"hljs-params\">signal1: firstAvailableSignal&lt;[E]&gt;, onCleanup: EffectCleanupRegisterFn</span>) =&gt;</span> W,\n\n  <span class=\"hljs-comment\">// Erm√∂glicht kombinierte Lese- und Schreibvorg√§nge, sollte aber sparsam eingesetzt werden!</span>\n  mixedReadWrite: <span class=\"hljs-function\">(<span class=\"hljs-params\">signal2: firstAvailableSignal&lt;[W, E]&gt;, onCleanup: EffectCleanupRegisterFn</span>) =&gt;</span> M,\n\n  <span class=\"hljs-comment\">// F√ºhrt DOM-Lesevorg√§nge aus, nachdem Schreibvorg√§nge abgeschlossen sind.</span>\n  read: <span class=\"hljs-function\">(<span class=\"hljs-params\">signal3: firstAvailableSignal&lt;[M, W, E]&gt;, onCleanup: EffectCleanupRegisterFn</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>\n}): AfterRenderRef;\n</code></pre>\n<p>Dies ist eine vereinfachte Version der <a href=\"https://github.com/angular/angular/blob/f3d931627523843281efb6f4207008ebbbbbb668/packages/core/src/render3/reactivity/after_render_effect.ts#L331\">echten Signatur von <code>afterRenderEffect()</code></a>.\nDer erste Callback erh√§lt keine Parameter.\nJedes nachfolgende Callback empf√§ngt den R√ºckgabewert der vorherigen Phase <strong>als Signal</strong>.\nWenn also der Effekt <code>earlyRead</code> einen Wert vom Typ <code>E</code> zur√ºckgibt und der n√§chste registrierte Effekt <code>write</code> ist, dann erh√§lt <code>write</code> ein Signal vom Typ <code>E</code>.\nWenn jedoch der n√§chste registrierte Effekt <code>mixedReadWrite</code> ist, wird dieser Effekt ein Signal vom Typ <code>E</code> erhalten, und so weiter.\nDer Effekt <code>read</code> hat keinen R√ºckgabewert.\nDie Weitergabe von Werten zwischen Phasen kann zur Koordination √ºber mehrere Phasen hinweg verwendet werden.</p>\n<p>Die Effekte laufen in der folgenden Reihenfolge ab, und zwar nur dann, wenn sie durch Signalabh√§ngigkeiten als &quot;dirty&quot; markiert wurden:</p>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Regel</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. <code>earlyRead</code></td>\n<td>Verwenden Sie diese Phase zum <strong>Lesen</strong> aus dem DOM vor einem nachfolgenden Write-Callback. Bevorzugen Sie die <code>read</code>-Phase, wenn das Lesen bis nach der <code>write</code>-Phase warten kann. <strong>Niemals</strong> in dieser Phase in den DOM schreiben!</td>\n</tr>\n<tr>\n<td>2. <code>write</code></td>\n<td>Verwenden Sie diese Phase zum <strong>Schreiben</strong> in das DOM. <strong>Niemals</strong> in dieser Phase aus dem DOM lesen.</td>\n</tr>\n<tr>\n<td>3. <code>mixedReadWrite</code></td>\n<td>Verwenden Sie diese Phase, um gleichzeitig vom DOM zu lesen und in den DOM zu schreiben. Verwenden Sie diese Phase <strong>nicht</strong>, wenn es m√∂glich ist, die Arbeit stattdessen auf die anderen Phasen aufzuteilen.</td>\n</tr>\n<tr>\n<td>4. <code>read</code></td>\n<td>Verwenden Sie diese Phase zum <strong>Lesen</strong> aus dem DOM. <strong>Niemals</strong> in dieser Phase in den DOM schreiben.</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://angular.dev/api/core/afterRenderEffect\">Laut der offiziellen Dokumentation</a> sollte man, wenn m√∂glich, die Phasen <code>read</code> und <code>write</code> den Phasen <code>earlyRead</code> und <code>mixedReadWrite</code> vorziehen, um Leistungseinbu√üen zu vermeiden.\nAngular ist nicht in der Lage, die korrekte Verwendung von Phasen zu verifizieren oder zu erzwingen, und verl√§sst sich stattdessen darauf, dass alle Entwickelnden die dokumentierten Richtlinien befolgen.</p>\n<p>Wie bereits erw√§hnt, gibt es auch eine zweite Signatur von <code>afterRenderEffect()</code>, die ein einzelnes Callback akzeptiert. \nDiese Funktion registriert einen Effekt, der nach Abschluss des Renderings ausgef√ºhrt werden soll, insbesondere w√§hrend der Phase <code>mixedReadWrite</code>.\nDie Angular-Dokumentation empfiehlt jedoch, wann immer m√∂glich, eine explizite Phase f√ºr den Effekt anzugeben, um m√∂gliche Leistungsprobleme zu vermeiden.\nDaher werden wir diese Signatur in unserem Artikel nicht behandeln, da ihre Verwendung nicht empfohlen wird.</p>\n<h3 id=\"neuausf√ºhrung-einer-phase-nur-bei-dirty\">Neuausf√ºhrung einer Phase: nur bei &quot;dirty&quot;</h3>\n<p>Wenn <code>afterRenderEffect()</code> zum ersten Mal aufgerufen wird, werden alle registrierten Effect einmal nacheinander ausgef√ºhrt.\nDamit ein Effekt jedoch erneut ausgef√ºhrt werden kann, muss er aufgrund einer √Ñnderung der Signalabh√§ngigkeiten als &quot;dirty&quot; markiert werden. \nDieses auf dem Tracking von Abh√§ngigkeiten basierende System hilft Angular, die Leistung zu optimieren, indem es √ºberfl√ºssige Ausf√ºhrungen verhindert.</p>\n<p>Damit ein Effekt als &quot;dirty&quot; markiert wird und erneut ausgef√ºhrt werden kann, muss zuvor er eine Abh√§ngigkeit zu einem Signal hergestellt worden sein, und dieses muss sich ge√§ndert haben. \nWenn der Effekt keine Signals trackt oder wenn die getrackten Signals unver√§ndert bleiben, wird der Effekt nicht als &quot;dirty&quot; markiert und der Code wird nicht erneut ausgef√ºhrt.</p>\n<p>Es gibt zwei M√∂glichkeiten, Abh√§ngigkeiten in <code>afterRenderEffect()</code> zu erstellen:</p>\n<ol>\n<li><p><strong>Wert einer vorherigen Phase tracken</strong>: \n  Jeder Effekt kann einen Wert zur√ºckgeben, der als Eingabe an den n√§chsten Effekt √ºbergeben wird (au√üer <code>earlyRead</code>, der keinen vorherigen Effekt hat). \n  Dieser Wert wird in ein Signal verpackt, und wenn wir dieses Signal dann im folgenden Effekt lesen, schaffen wir eine Abh√§ngigkeit. \n  Es ist wichtig zu verstehen, dass wir die Getter-Funktion des Signals tats√§chlich ausf√ºhren m√ºssen, da die einfache Weitergabe des Signals nicht ausreicht, um eine Abh√§ngigkeit herzustellen.</p>\n</li>\n<li><p><strong>Direktes Verfolgen von Komponenten-Signals</strong>: \n  Wir k√∂nnen auch Abh√§ngigkeiten herstellen, indem wir direkt auf andere Signals unserer Komponente innerhalb des Effekts zugreifen. \n  Im folgenden Beispiel lesen wir ein Signal von der Komponente innerhalb des Effekts <code>earlyRead</code>, um eine Abh√§ngigkeit zu schaffen und sicherzustellen, dass der Effekt mehrfach ausgef√ºhrt wird.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>üí° Angular stellt sicher, dass Effects nur dann erneut ausgef√ºhrt werden, wenn sich ihre verfolgten Signals √§ndern, und markiert den Effekt selbst als &quot;dirty&quot;.\n  Ohne diese Signalabh√§ngigkeiten wird jeder Effekt nur einmal ausgef√ºhrt!</strong></p>\n</blockquote>\n<h3 id=\"beispiel-f√ºr-afterrendereffect-gr√∂√üe-einer-textarea-dynamisch-√§ndern\">Beispiel f√ºr <code>afterRenderEffect()</code>: Gr√∂√üe einer Textarea dynamisch √§ndern</h3>\n<p>Lassen Sie uns mit Hilfe eines praktischen Beispiels einen genaueren Blick auf <code>afterRenderEffect()</code> werfen.</p>\n<p>In diesem Beispiel wird demonstriert, wie <code>afterRenderEffect()</code> verwendet werden kann, um die H√∂he einer <code>&lt;textarea&gt;</code> dynamisch anzupassen, und zwar sowohl auf der Basis von Benutzer- als auch von programmatischen √Ñnderungen.\nDie Textarea ist so konzipiert, dass sie durch Ziehen der unteren rechten Ecke in der Gr√∂√üe ver√§ndert werden kann, aber wir wollen auch, dass sie ihre H√∂he regelm√§√üig automatisch anpasst.\nUm dies zu erreichen, lesen wir die aktuelle H√∂he aus dem DOM und aktualisieren sie auf der Grundlage eines zentralen Signals namens <code>extraHeight</code>.</p>\n<p>Dieses Beispiel ist durch den Artikel <a href=\"https://medium.com/@amosisaila/angular-19-afterrendereffect-5cf8e6482256\">Angular 19: afterRenderEffect</a> von Amos Lucian Isaila Onofrei inspiriert, den wir an entscheidender Stelle modifiziert haben. (Das Originalbeispiel liest im <code>write</code>-Effekt aus dem DOM, was laut der Angular-Dokumentation ausdr√ºcklich nicht empfohlen wird).</p>\n<p>Unser Beispiel zeigt, wie man mehrere Phasen (<code>earlyRead</code>, <code>write</code> und <code>read</code>) in <code>afterRenderEffect()</code> verwendet, um DOM-Manipulationen effizient zu verarbeiten.\nDabei werden auch die Richtlinien f√ºr die Trennung von Lese- und Schreibvorg√§ngen eingehalten:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, viewChild, <span class=\"hljs-title class_\">ElementRef</span>, signal, afterRenderEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-resizable&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;textarea #myElement style=&quot;border: 1px solid black; height: 100px; resize: vertical;&quot;&gt;\n    Resizable Element\n  &lt;/textarea&gt;`</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ResizableComponent</span> {\n\n  myElement = viewChild.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-title class_\">ElementRef</span>&gt;(<span class=\"hljs-string\">&#x27;myElement&#x27;</span>);\n  extraHeight = <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n\n    <span class=\"hljs-keyword\">const</span> effect = <span class=\"hljs-title function_\">afterRenderEffect</span>({\n\n      <span class=\"hljs-comment\">// earlyRead: Erfasst die aktuelle H√∂he der Textarea aus dem DOM.</span>\n      <span class=\"hljs-attr\">earlyRead</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">onCleanup</span>) =&gt;</span> {\n\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">`earlyRead executes`</span>);\n\n        <span class=\"hljs-comment\">// Macht `extraHeight` zu einer Abh√§ngigkeit von `earlyRead`</span>\n        <span class=\"hljs-comment\">// Jetzt wird dieser Code immer wieder ausgef√ºhrt, wenn sich `extraHeight` √§ndert</span>\n        <span class=\"hljs-comment\">// Tipp: Entfernen Sie diese Anweisung, und `earlyRead` wird nur einmal ausgef√ºhrt!</span>\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;earlyRead: extra height:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">extraHeight</span>());\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">currentHeight</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">myElement</span>()?.<span class=\"hljs-property\">nativeElement</span>.<span class=\"hljs-property\">offsetHeight</span>;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;earlyRead: offset height:&#x27;</span>, currentHeight);\n\n        <span class=\"hljs-comment\">// √úbergabe der H√∂he an den n√§chsten Effekt</span>\n        <span class=\"hljs-keyword\">return</span> currentHeight;\n      },\n\n      <span class=\"hljs-comment\">// write: Setzt die neue H√∂he, indem `extraHeight` zur erfassten DOM-H√∂he addiert wird.</span>\n      <span class=\"hljs-attr\">write</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">currentHeight, onCleanup</span>) =&gt;</span> {\n\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">`write executes`</span>);\n\n        <span class=\"hljs-comment\">// Macht `extraHeight` zu einer Abh√§ngigkeit von `write`</span>\n        <span class=\"hljs-comment\">// Tipp: √Ñndern Sie diesen Code in `const newHeight = currentHeight();`, </span>\n        <span class=\"hljs-comment\">// damit wir keine Abh√§ngigkeit zu einem Signal haben, das ge√§ndert wird, und `write` nur einmal ausgef√ºhrt wird</span>\n        <span class=\"hljs-comment\">// Tipp 2: wenn sich `currentHeight` in `earlyRead` √§ndert, wird auch `write` neu ausgef√ºhrt. </span>\n        <span class=\"hljs-comment\">// √Ñndern Sie zum Ausprobieren die Gr√∂√üe der Textarea manuell.</span>\n        <span class=\"hljs-keyword\">const</span> newHeight = <span class=\"hljs-title function_\">currentHeight</span>() + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">extraHeight</span>();\n\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">myElement</span>().<span class=\"hljs-property\">nativeElement</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">height</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${newHeight}</span>px`</span>;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;write: written height:&#x27;</span>, newHeight);\n\n        <span class=\"hljs-title function_\">onCleanup</span>(<span class=\"hljs-function\">() =&gt;</span> {\n          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;write: cleanup is called&#x27;</span>, newHeight);\n        });\n\n        <span class=\"hljs-comment\">// √úbergeben Sie die H√∂he an den n√§chsten Effekt</span>\n        <span class=\"hljs-comment\">// Tipp: √ºbergeben Sie den gleichen Wert an `read`, z. B. `return 100`, um zu sehen, wie `read` √ºbersprungen wird</span>\n        <span class=\"hljs-keyword\">return</span> newHeight;\n      },\n\n      <span class=\"hljs-comment\">// Der `read`-Effekt protokolliert die aktualisierte H√∂he</span>\n      <span class=\"hljs-attr\">read</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">newHeight, onCleanup</span>) =&gt;</span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">&#x27;read executes&#x27;</span>);\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;read: new height:&#x27;</span>, <span class=\"hljs-title function_\">newHeight</span>());\n      }\n    });\n\n    <span class=\"hljs-comment\">// Triggert alle 4 Sekunden einen neuen Durchlauf, indem das Signal `extraHeight` gesetzt wird</span>\n    <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">&#x27;---- neue Runde ----&#x27;</span>);\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">extraHeight</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> ++x)\n    }, <span class=\"hljs-number\">4_000</span>);\n\n    <span class=\"hljs-comment\">// Probieren Sie diese Zeile aus, wenn der Signalwert gleich bleibt, passiert nichts</span>\n    <span class=\"hljs-comment\">// setInterval(() =&gt; this.extraHeight.update(x =&gt; x), 4_000);</span>\n\n    <span class=\"hljs-comment\">// Die `onCleanup`-Callbacks werden ausgef√ºhrt, wenn wir den Hook zerst√∂ren, hierzu folgende Zeile einkommentieren</span>\n    <span class=\"hljs-comment\">// setTimeout(() =&gt; effect.destroy(), 20_000);</span>\n  }\n}\n</code></pre>\n<p>In unserem Beispiel aktualisiert ein Intervall das Signal <code>extraHeight</code> alle 4 Sekunden.\nDurch die Aktualisierung von <code>extraHeight</code> schaffen wir den Zustand &quot;dirty&quot;. Daraufhin werden die Effect-Phasen neu gestartet und welche die H√∂he der <code>&lt;textarea&gt;</code> wird bei bei Bedarf √ºberpr√ºft und angepasst.</p>\n<p><strong>Erl√§uterung zu den Phasen</strong></p>\n<p>In unserem Beispiel aktualisiert ein Intervall das Signal <code>extraHeight</code> alle 4 Sekunden, wodurch ein neuer Durchlauf √ºber die Phasen hinweg entsteht. \nHier ist eine Aufschl√ºsselung der einzelnen Effekte:</p>\n<ol>\n<li><p><strong>Phase <code>earlyRead</code></strong>: \n  Der Effekt, der in der <code>earlyRead</code>-Phase ausgef√ºhrt wird, erfasst die aktuelle H√∂he der Textarea, indem er die <code>offsetHeight</code> direkt aus dem DOM liest. \n  Dieser Lesevorgang aus dem DOM ist notwendig, weil die Textarea auch manuell vom Benutzer in der Gr√∂√üe ver√§ndert werden kann, so dass ihre Gr√∂√üe vor jeder Anpassung √ºberpr√ºft werden muss.\n  Das Ergebnis, <code>currentHeight</code>, wird an den n√§chsten Effekt weitergegeben. \n  In diesem Effekt verwenden wir <code>extraHeight</code> als unsere verfolgte Abh√§ngigkeit, um sicherzustellen, dass der Code mehrfach ausgef√ºhrt werden kann.\n  Wir empfehlen Ihnen, diese Anweisung zu entfernen: <code>console.log(&#39;earlyRead: extra height:&#39;, this.extraHeight());</code>.\n  Wenn Sie dies tun, werden Sie sehen, dass der <code>earlyRead</code>-Effekt nur einmal ausgef√ºhrt wird und dass jede manuelle √Ñnderung der Textarea bei der n√§chsten Ausf√ºhrung ignoriert wird.</p>\n</li>\n<li><p><strong>Phase <code>write</code></strong>: \n  Der Effekt f√ºgt den <code>extraHeight</code>-Wert zur erfassten <code>currentHeight</code> hinzu und aktualisiert die Height-Style-Eigenschaft der Textarea.\n  Diese DOM-Schreiboperation passt die H√∂he des Elements direkt in Pixeln an.\n  Die Funktion <code>onCleanup</code> wird bereitgestellt, um alle erforderlichen Aufr√§umarbeiten vor dem n√§chsten Schreibvorgang zu erledigen.\n  In unserem Beispiel sind keine Aufr√§umarbeiten erforderlich. Wir weisen aber darauf hin, dass lang laufende Aufgaben (wie ein Timeout) immer sauber beendet werden sollten.\n  Die Bereinigung wird vor der erneuten Ausf√ºhrung der Phase aufgerufen, oder wenn der Effekt selbst zerst√∂rt wird.\n  Der <code>write</code>-Effekt √ºbergibt dann die neue H√∂he <code>newHeight</code> an den <code>read</code>-Effekt.\n  Tipp: √úbergeben Sie den gleichen Wert an <code>read</code> (z. B. <code>return 100</code>) und Sie werden sehen, dass die Folgephase nicht ausgef√ºhrt wird.\n  Wird dieselbe Zahl zweimal gesetzt, wird dies nicht als √Ñnderung betrachtet, so dass der Effekt <code>write</code> den Effekt <code>read</code> nicht als &quot;dirty&quot; markiert.</p>\n</li>\n<li><p><strong>Phase <code>read</code></strong>: \n  Der Effekt, der in der <code>read</code>-Phase ausgef√ºhrt wird, protokolliert die <code>newHeight</code>. \n  Wir k√∂nnten in dieser Phase auch aus dem DOM lesen und das Ergebnis in einem neuen Signal speichern.\n  Das ist in diesem Beispiel gar nicht notwendig, weil <code>earlyRead</code> diese Aufgabe bereits erledigt.</p>\n</li>\n</ol>\n<blockquote>\n<p>Wir empfehlen Ihnen, einen Blick auf unsere Demo-Anwendung zu werfen (siehe unten). \n  Folgen Sie den Hinweisen in den Kommentaren, um mit den Besonderheiten der einzelnen Phasen zu experimentieren.\n  So lassen sich die unterschiedlichen Phasen am besten verstehen.</p>\n</blockquote>\n<h2 id=\"migrationsleitfaden-von-angulars-lifecycle-hooks-zu-signalbasierter-reaktivit√§t\">Migrationsleitfaden: Von Angulars Lifecycle Hooks zu signalbasierter Reaktivit√§t</h2>\n<p>Im April 2023 skizzierte das Angular-Team in <a href=\"https://github.com/angular/angular/discussions/49682\">RFC #49682</a> seine Vision von signalbasierten Komponenten.\nDas langfristige Ziel ist es, die traditionellen Lifecycle Hooks abzuschaffen, obwohl der RFC diskutiert, die Hooks <code>ngOnInit</code> und <code>ngOnDestroy</code> beizubehalten. (Ein Ersatz f√ºr diese Hooks liegt nun aber vor, es w√§re also nicht √ºberraschend, wenn die Hooks ebenfalls bald verschwinden.)\nDas Dokument schlug die Einf√ºhrung von <code>afterRenderEffect()</code> als Teil einer Roadmap vor, und mit Angular 19 nimmt die finale Vision von signalbasierten Komponenten Gestalt an.</p>\n<p>Die Einf√ºhrung von <code>effect()</code> und <code>afterRenderEffect()</code> zeigt, wie Angular sich in diese Richtung bewegt. \nDiese Effekte sind intuitiver f√ºr die Verwaltung von Zustands√§nderungen und Interaktionen nach dem Rendern, wodurch die alten Lebenszyklus-Hooks √ºberfl√ºssig werden.\nSo √ºbernimmt <code>afterRenderEffect()</code> Aufgaben, die traditionell von <code>ngAfterViewInit</code> und <code>ngAfterViewChecked</code> erledigt wurden.</p>\n<p>Die Migration von Angular Lifecycle Hooks hin zu <code>effect()</code> und <code>afterRenderEffect()</code> ist relativ einfach zu bewerkstelligen:</p>\n<ul>\n<li><strong><code>ngOnInit</code> / <code>ngOnChanges</code></strong> ‚Üí <code>effect()</code>: Behandelt signalbasierte Logik und andere Zust√§nde.</li>\n<li><strong><code>ngAfterViewInit</code> / <code>ngAfterViewChecked</code></strong> ‚Üí <code>afterRenderEffect()</code>: Verwaltet DOM-Manipulationen nach dem Rendern.</li>\n</ul>\n<p>Eine direkte Gegen√ºberstellung:</p>\n<table>\n<thead>\n<tr>\n<th>Lifecycle Hook</th>\n<th>Wird ersetzt durch</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ngOnInit</code></td>\n<td><code>effect()</code></td>\n</tr>\n<tr>\n<td><code>ngOnChanges</code></td>\n<td><code>effect()</code></td>\n</tr>\n<tr>\n<td><code>ngAfterViewInit</code></td>\n<td><code>afterRenderEffect()</code></td>\n</tr>\n<tr>\n<td><code>ngAfterViewChecked</code></td>\n<td><code>afterRenderEffect()</code></td>\n</tr>\n</tbody></table>\n<p><strong>Hinweis:</strong> Wenn Sie von den klassischen Lifecycle-Hooks vollst√§ndig wegmigrieren wollen, k√∂nnen Sie <a href=\"https://angular.dev/api/core/DestroyRef\"><code>DestroyRef</code></a> verwenden.\nDamit k√∂nnen Sie Callbacks f√ºr Aufr√§um- oder Zerst√∂rungsaufgaben definieren, so dass Sie <code>ngOnDestroy</code> in Ihrer Codebasis im Prinzip nicht mehr ben√∂tigen.</p>\n<h2 id=\"erinnerung-afterrendereffect-sollte-nicht-in-business-code-verwendet-werden\">Erinnerung: <code>afterRenderEffect()</code> sollte nicht in Business-Code verwendet werden</h2>\n<p>Wenn Sie <code>ngAfterViewInit</code> oder <code>ngAfterContentChecked</code> in der Vergangenheit selten gebraucht haben, wird <code>afterRenderEffect()</code> in Ihrer Codebasis wahrscheinlich ebenso selten vorkommen. \nEs zielt auf spezielle Aufgaben ab und wird nicht so h√§ufig verwendet werden wie die grundlegenden Signal-APIs \n<a href=\"https://angular.dev/api/core/signal\"><code>signal()</code></a>, \n<a href=\"https://angular.dev/api/core/computed\"><code>computed()</code></a>, \n<code>effect()</code>, <code>linkedSignal()</code>, oder <code>resource()</code>.</p>\n<p>Betrachten Sie <code>afterRenderEffect()</code> in diesem Zusammenhang als √§hnlich wichtig wie <code>ngAfterViewInit</code>.\nDiese Effects sind eher ein fortgeschrittenes Lebenszyklus-Werkzeug als eine t√§gliche Notwendigkeit. \nVerwenden Sie <code>afterRenderEffect()</code> nur, wenn Sie eine pr√§zise Kontrolle √ºber DOM-Operationen, Low-Level-APIs oder Bibliotheken von Drittanbietern ben√∂tigen, die ein spezifisches Timing und eine Koordination √ºber Rendering-Phasen hinweg erfordern.\nWenn Sie also nicht Ihre eigene Komponentenbibliothek bauen (und es gibt bereits viele gute Komponentenbibliotheken), sollten Sie <code>afterRenderEffect()</code> nur selten sehen.</p>\n<p>Im allt√§glichen Anwendungscode werden <code>effect()</code> und andere signalbasierte APIs die meisten Anforderungen an Reaktivit√§t bedienen, ohne die zus√§tzliche Komplexit√§t, die <code>afterRenderEffect()</code> mit sich bringt. \nKurz: Greifen Sie nur dann zu <code>afterRenderEffect()</code>, wenn Standardans√§tze Ihren speziellen Anforderungen nicht mehr gerecht werden ‚Äì und wirklich erst dann!</p>\n<h2 id=\"best-practices-f√ºr-die-verwendung-von-effect-und-afterrendereffect\">Best Practices f√ºr die Verwendung von <code>effect()</code> und <code>afterRenderEffect()</code></h2>\n<p>Hier sind einige bew√§hrte Praxisempfehlungen, um das Optimum aus den neuen Signal-APIs herauszuholen:</p>\n<ol>\n<li><strong>Verwenden Sie <code>computed()</code> f√ºr einfache Abh√§ngigkeiten:</strong> Nutzen Sie <code>effect()</code> hingegen f√ºr komplexere oder zustandsabh√§ngige Operationen.</li>\n<li><strong>W√§hlen Sie die Phasen in <code>afterRenderEffect()</code> sorgf√§ltig aus:</strong> Halten Sie sich an die spezifischen Phasen und vermeiden Sie <code>mixedReadWrite</code> wenn m√∂glich.</li>\n<li><strong>Verwenden Sie <code>onCleanup()</code> zur Verwaltung von langlebigen Ressourcen:</strong> Verwenden Sie immer <code>onCleanup()</code> innerhalb von Effekten f√ºr jede Ressource, die entsorgt werden muss, insbesondere bei Animationen oder Intervallen.</li>\n<li><strong>Direkte DOM-Manipulationen nur wenn n√∂tig:</strong> Denken Sie daran, dass der reaktive Ansatz von Angular die Notwendigkeit manueller DOM-Manipulationen minimiert. \n  Verwenden Sie <code>afterRenderEffect()</code> nur, wenn Angulars Templating nicht mehr ausreicht.</li>\n</ol>\n<h2 id=\"demo-anwendung\">Demo-Anwendung</h2>\n<p>Um die beiden Effect-APIs in Aktion zu sehen, haben wir eine Demo-Anwendung erstellt, die alle in diesem Artikel besprochenen Beispiele vorf√ºhrt.\nDer erste Link f√ºhrt zum Quellcode auf GitHub, den Sie gerne herunterladen k√∂nnen.\nDer zweite Link √∂ffnet die Anwendung, die Sie direkt im Browser ausprobieren k√∂nnen.\nZu guter Letzt bietet der dritte Link eine interaktive Demo auf StackBlitz, wo Sie den Quellcode bearbeiten und die Ergebnisse in Echtzeit sehen k√∂nnen.</p>\n<blockquote>\n<p><strong><a href=\"https://github.com/angular-schule/demo-effect-and-afterRenderEffect\">1Ô∏è‚É£ Sourcecode auf GitHub: demo-effect-and-afterRenderEffect</a></strong><br>\n<strong><a href=\"https://angular-schule.github.io/demo-effect-and-afterRenderEffect/\">2Ô∏è‚É£ Ver√∂ffentlichte Anwendung</a></strong><br>\n<strong><a href=\"https://stackblitz.com/github/angular-schule/demo-effect-and-afterRenderEffect\">3Ô∏è‚É£ StackBlitz Demo</a></strong></p>\n</blockquote>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Beide APIs er√∂ffnen neue, elegante Wege zur Zustands- und DOM-Verwaltung in Angular: reaktiv, pr√§zise und klar. \nWer sich fr√ºhzeitig mit <code>effect()</code> und <code>afterRenderEffect()</code> vertraut macht, profitiert schon heute von der Architektur von morgen.\nNutzen Sie die Gelegenheit, die neuen Schnittstellen in Ihrer Anwendung auszuprobieren! Seit Angular 20 gelten die Funktionen als &quot;stable&quot;.</p>\n<hr>\n\n<p><strong>Vielen Dank an Ferdinand Malcher f√ºr intensive Redaktion und Feedback!</strong></p>\n<p><small><strong>Coverbild:</strong> Erstellt mit Dall-E und Adobe Firefly</small></p>\n","meta":{"title":"Reactive Angular: effect and afterRenderEffect verstehen und einsetzen","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2025-05-01T00:00:00.000Z","lastModified":"2025-06-18T00:00:00.000Z","keywords":["Angular","JavaScript","Signals","Reactive Programming","Effect","afterRenderEffect","Angular 19"],"language":"de","header":{"url":"effect.jpg","width":2000,"height":1089}}}
