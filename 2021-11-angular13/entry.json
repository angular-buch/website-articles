{"slug":"2021-11-angular13","html":"<p>Noch vor dem Jahresende erschien Anfang November 2021 die neue Major-Version 13 von Angular.\nAuch diese Version bringt keine großen Änderungen an der Oberfläche des Frameworks mit, sondern verbessert vor allem Details im Hintergrund. Es gibt ein paar wenige Breaking Changes, die aber für die meisten Entwicklerinnen und Entwickler nicht interessant sein dürften.</p>\n<p>Wir stellen in diesem Blogpost wie immer die wichtigsten Neuigkeiten vor.\nDen Code des Beispielprojekts <em>BookMonkey</em> aus dem Angular-Buch halten wir stets <a href=\"https://github.com/angular-buch/book-monkey4\">auf GitHub</a> aktuell.</p>\n<p>Die offizielle Mitteilung zum neuen Release finden Sie im englischsprachigen <a href=\"https://blog.angular.io/angular-v13-is-now-available-cce66f7bc296\">Angular-Blog</a>.\nIm Changelog von <a href=\"https://github.com/angular/angular/blob/master/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/master/CHANGELOG.md\">Angular CLI</a> finden Sie außerdem alle Details zum neuen Release.</p>\n<blockquote>\n<p><strong>Die Update-Infos für neuere Versionen von Angular finden Sie in separaten Blogartikeln. Wenn Sie das Update durchführen möchten, lesen Sie bitte alle Artikel in der gegebenen Reihenfolge.</strong></p>\n<ul>\n<li><a href=\"/blog/2022-06-angular14\">Angular 14 ist da!</a></li>\n<li><a href=\"/blog/2022-11-angular15\">Angular 15 ist da!</a></li>\n<li><a href=\"/blog/2023-05-angular16\">Angular 16 ist da!</a></li>\n</ul>\n</blockquote>\n<h2 id=\"projekt-updaten\">Projekt updaten</h2>\n<p>Wenn Sie Ihr bestehendes Projekt aktualisieren möchten, folgen Sie bitte den Instruktionen im <a href=\"https://update.angular.io\">Angular Update Guide</a>.\nMithilfe des Befehls <code>ng update</code> erhalten Sie außerdem Infos zu möglichen Updates direkt im Projekt.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Projekt auf Angular 13 aktualisieren</span>\nnpx <span class=\"hljs-variable\">@angular</span>/cli<span class=\"hljs-variable\">@13</span> update <span class=\"hljs-variable\">@angular</span>/core<span class=\"hljs-variable\">@13</span> <span class=\"hljs-variable\">@angular</span>/cli<span class=\"hljs-variable\">@1</span>3\n</code></pre>\n<p>Bitte beachten Sie, dass es noch einige Zeit dauern kann, bis Community-Projekte wie NgRx oder Nrwl Nx ebenso mit Angular 13 kompatibel sind.</p>\n<h2 id=\"neue-versionen-nodejs-typescript-und-rxjs\">Neue Versionen: Node.js, TypeScript und RxJS</h2>\n<p>Angular 13 benötigt die folgenden Versionen von Node.js, TypeScript und RxJS:</p>\n<ul>\n<li><strong>Node.js:</strong> mindestens Version 12.20.0. Außerdem wird jetzt auch <strong>Node 16</strong> unterstützt.</li>\n<li><strong>TypeScript:</strong> mindestens Version 4.4.2. Ältere Versionen werden nicht mehr unterstützt.</li>\n<li><strong>RxJS:</strong> Bei neu angelegten Angular-Projekten wird jetzt die Bibliothek RxJS in der aktuellen Version 7 genutzt. RxJS 6 wird weiterhin unterstützt. Bei bestehenden Projekten wird die Versionsnummer nicht automatisch erhöht.</li>\n</ul>\n<h2 id=\"test-module-teardown\">Test Module Teardown</h2>\n<p>Schon mit Angular 12.1 wurde das sogenannte <em>Test Module Teardown</em> eingeführt. <strong>Mit Angular 13 ist das Teardown nun automatisch aktiv, siehe <a href=\"https://github.com/angular/angular/commit/94ba59bc9db81ae04f20e8147b5133a0d3d45510\">Commit</a>.</strong>\nDiese Option, die bisher freiwillig aktiviert werden konnte, sorgt dafür, dass beim Unit-Testing mit dem <code>TestBed</code> das erzeugte Modul nach dem Test wieder zerstört wird. Dabei wird z. B. das DOM-Element der erzeugten Komponente wieder entfernt.\nDie Option <code>destroyAfterEach</code> kann für jeden Test separat aktiviert werden:</p>\n<pre><code class=\"language-ts\">TestBed.<span class=\"hljs-title function_ invoke__\">configureTestingModule</span>({\n  <span class=\"hljs-attr\">teardown</span>: { <span class=\"hljs-attr\">destroyAfterEach</span>: <span class=\"hljs-literal\">true</span> },\n  // ...\n});\n</code></pre>\n<p>Alternativ ist auch eine globale Einstellung in der Datei <code>test.ts</code> möglich.\nFür neue Projekte mit Angular 13 ist das Test Module Teardown per default eingeschaltet.\nFür existierende Apps wird das Teardown zunächst explizit deaktiviert, sodass keine Anpassungen im Code notwendig sind.</p>\n<p>Für weitere Informationen empfehlen wir den <a href=\"https://dev.to/this-is-angular/improving-angular-tests-by-enabling-angular-testing-module-teardown-38kh\">Blogpost von Lars Gyrup Brink Nielsen</a>.</p>\n<h2 id=\"vereinfachte-schnittstelle-für-dynamic-components\">Vereinfachte Schnittstelle für Dynamic Components</h2>\n<p>Mit der Schnittstelle der Klasse <code>ViewContainerRef</code> können Komponenteninstanzen dynamisch zur Laufzeit der Anwendung erzeugt werden.\nDafür war es bisher notwendig, den <code>ComponentFactoryResolver</code> zu verwenden, um zunächst eine Factory für die jeweilige Komponente zu erstellen. Das war aufwendig und erzeugte viel Code.</p>\n<p>Die Schnittstelle für die Methode <code>createComponent()</code> wurde mit Angular 13 vereinfacht, siehe <a href=\"https://github.com/angular/angular/commit/7dccbdd27be13eb7287f535f482b1de2c13fca74\">Commit</a>.\nJetzt ist es möglich, direkt eine Komponentenklasse zu übergeben, die dann in einem ViewContainer gerendert wird.\nDas folgende Beispiel zeigt (stark vereinfacht!), wie eine Komponente dynamisch im ViewContainer einer Direktive erstellt werden kann:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ViewContainerRef</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MyComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./my.component&#x27;</span>;\n\n<span class=\"hljs-meta\">@Directive</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyDirective</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">vcr</span>: <span class=\"hljs-title class_\">ViewContainerRef</span></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vcr</span>.<span class=\"hljs-title function_\">createComponent</span>(<span class=\"hljs-title class_\">MyComponent</span>);\n  }\n}\n</code></pre>\n<p>Zusammen mit Dynamic Imports kann die betreffende Komponente sogar &quot;lazy&quot; geladen werden.\nSie wird in ein eigenes Bundle verpackt und erst beim Aufruf von <code>import()</code> tatsächlich heruntergeladen.\nEs ist damit nun noch einfacher, einzelne Komponenten auszulagern separat bereitzustellen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./my.component&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> {\n  this.vcr.createComponent(m.MyComponent);\n});\n</code></pre>\n<h2 id=\"persistent-cache\">Persistent Cache</h2>\n<p>In Projekten mit Angular 13 ist der neue <em>Persistent Disk Cache</em> automatisch aktiv.\nDabei werden Teile der gebauten Anwendung zwischengespeichert, um zukünftige Builds zu beschleunigen.\nDer Cache kann über die <code>angular.json</code> konfiguriert werden:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span>\n  <span class=\"hljs-string\">&quot;cli&quot;</span>: {\n    <span class=\"hljs-string\">&quot;cache&quot;</span>: {\n      <span class=\"hljs-string\">&quot;enabled&quot;</span>: <span class=\"hljs-literal\">true</span>\n    }\n  }\n}\n</code></pre>\n<p>Informationen zur Konfiguration des Build Cache finden Sie in der <a href=\"https://angular.io/cli/cache\">Angular-Dokumentation</a>.</p>\n<h2 id=\"support-für-ie11-eingestellt\">Support für IE11 eingestellt</h2>\n<p>Die Unterstützung für den Internet Explorer 11 wurde entfernt.\nNachdem in der letzen Version der Support bereits &quot;deprecated&quot; wurde, ist Angular jetzt offiziell nicht mehr im Internet Explorer lauffähig.</p>\n<p>Bei der Migration zu Angular 13 werden deshalb einige Einträge aus der <code>polyfills.ts</code> entfernt.\nAußerdem ist <em>Differential Loading</em>, das mit Angular 8 eingeführt wurde, nicht mehr notwendig. Dabei wurden für ältere Browser separate Bundles in ES5 gebaut. Da alle aktuellen Browser auch modernere Varianten von JavaScript unterstützen, wird Differential Loading nicht mehr genutzt.</p>\n<h2 id=\"bibliotheken-mit-ivy-compilation\">Bibliotheken mit Ivy-Compilation</h2>\n<p>Nachdem der neue Renderer <em>Ivy</em> eingeführt wurde, musste die Kompatibilität mit Anwendungen gewährt werden, die noch auf die veraltete <em>View Engine</em> setzten.\nDafür wurde der Angular Compatibility Compiler (<code>ngcc</code>) entwickelt: Alle Bibliotheken, die auf NPM veröffentlicht werden, mussten zunächst weiterhin mit der View Engine kompiliert werden. Beim Build einer Ivy-Anwendung wurde automatisch der <code>ngcc</code> aktiv, um die Anweisungen in Ivy-Instruktionen zu übersetzen.</p>\n<p>Dieser Prozess braucht Zeit.\nMöglicherweise haben Sie diese Ausgabe beim <code>ng serve</code> schon einmal gesehen – sie stammt vom <code>ngcc</code>:</p>\n<pre><code><span class=\"hljs-type\">Compiling</span> <span class=\"hljs-meta\">@angular</span><span class=\"hljs-operator\">/</span>core : es2015 <span class=\"hljs-keyword\">as</span> esm2015\n<span class=\"hljs-type\">Compiling</span> <span class=\"hljs-meta\">@angular</span><span class=\"hljs-operator\">/</span>common : es2015 <span class=\"hljs-keyword\">as</span> esm2015\n<span class=\"hljs-type\">Compiling</span> <span class=\"hljs-meta\">@angular</span><span class=\"hljs-operator\">/</span>platform<span class=\"hljs-operator\">-</span>browser : es2015 <span class=\"hljs-keyword\">as</span> esm2015\n<span class=\"hljs-type\">Compiling</span> <span class=\"hljs-meta\">@angular</span><span class=\"hljs-regexp\">/common/</span>http : es2015 <span class=\"hljs-keyword\">as</span> esm2015\n</code></pre>\n<p>Seit Angular 13 können Bibliotheken direkt in Ivy-Instruktionen kompiliert und veröffentlicht werden.\nDer Code ist dann nicht mehr mit der <em>View Engine</em> kompatibel.\nDer <code>ngcc</code> wird damit weiter an Bedeutung verlieren und künftig entfernt werden können.\nDie View Engine wird seit Angular 13 nicht mehr unterstützt.</p>\n<p>Mehr Infos zum Veröffentlichen von Bibliotheken mit Ivy finden Sie in der <a href=\"https://angular.io/guide/creating-libraries#building-libraries-with-ivy\">Angular-Dokumentation</a>.</p>\n<h2 id=\"neue-methoden-für-reactive-forms\">Neue Methoden für Reactive Forms</h2>\n<p>Für die Formularverarbeitung mit Reactive Forms wurden neue Methoden hinzugefügt, siehe <a href=\"https://github.com/angular/angular/commit/1d9d02696eadbee2c2f719e432efca22f1e494e9\">Commit</a>:</p>\n<ul>\n<li><code>hasValidator</code>, <code>hasAsyncValidator</code></li>\n<li><code>addValidators</code>, <code>addAsyncValidators</code></li>\n<li><code>removeValidators</code>, <code>removeAsyncValidators</code></li>\n</ul>\n<p>Damit ist es möglich, programmatisch zu prüfen, ob ein bestimmter Validator auf einem Control vorhanden ist, um z. B. Required-Felder optisch zu markieren.\nAußerdem können <em>einzelne</em> Validatoren dynamisch hinzugefügt oder entfernt werden. Das kann z. B. in Abhängigkeit von anderen Formularwerten implementiert werden. Bisher war es nur möglich, <em>alle</em> Validatoren eines Controls zu setzen oder zu entfernen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// prüfen, ob required-Validator auf dem Control vorhanden ist</span>\n<span class=\"hljs-title function_\">isRequired</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">controlName</span>: <span class=\"hljs-built_in\">string</span></span>) {\n  <span class=\"hljs-keyword\">const</span> control = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">form</span>.<span class=\"hljs-title function_\">get</span>(controlName);\n  <span class=\"hljs-keyword\">return</span> !!control &amp;&amp; control.<span class=\"hljs-title function_\">hasValidator</span>(<span class=\"hljs-title class_\">Validators</span>.<span class=\"hljs-property\">required</span>)\n}\n\n<span class=\"hljs-comment\">// required-Validator dynamisch hinzufügen</span>\n<span class=\"hljs-title function_\">addRequired</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">controlName</span>: <span class=\"hljs-built_in\">string</span></span>) {\n  <span class=\"hljs-keyword\">const</span> control = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">form</span>.<span class=\"hljs-title function_\">get</span>(controlName)!;\n\n  control.<span class=\"hljs-title function_\">addValidators</span>(<span class=\"hljs-title class_\">Validators</span>.<span class=\"hljs-property\">required</span>);\n  control.<span class=\"hljs-title function_\">updateValueAndValidity</span>();\n}\n</code></pre>\n<p>Wir haben ein funktionierendes <a href=\"https://github.com/angular-buch/playground-ng13-validators/blob/main/src/app/app.component.ts\">Beispiel auf GitHub</a> bereitgestellt.</p>\n<p>Auch die Typisierung bei den Formularen hat sich verbessert. Es wurde ein neuer Typ <code>FormControlStatus</code> eingeführt, welcher nun bei <code>form.status</code>und <code>form.statusChanges</code> zum Einsatz kommt, siehe <a href=\"https://github.com/angular/angular/commit/e49fc96ed33c26434a14b80487dd912d8c76cace\">Commit</a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-built_in\">export</span><span class=\"hljs-built_in\"> type </span>FormControlStatus = <span class=\"hljs-string\">&#x27;VALID&#x27;</span>|<span class=\"hljs-string\">&#x27;INVALID&#x27;</span>|<span class=\"hljs-string\">&#x27;PENDING&#x27;</span>|<span class=\"hljs-string\">&#x27;DISABLED&#x27;</span>;\n</code></pre>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<ul>\n<li><strong>$localize stable:</strong> Die Funktion <code>$localize</code> zur Übersetzung von Texten in der Anwendung gilt jetzt als <em>stable</em>. Siehe auch dieser Beitrag im Angular-Blog: <a href=\"https://blog.angular.io/angular-localization-with-ivy-4d8becefb6aa\">Angular localization with Ivy</a>.</li>\n<li><strong>deployUrl</strong>: Die Option <code>deployUrl</code> für <code>ng build</code> ist nun deprecated. Falls Sie ein ähnliches Verhalten wiederherstellen möchten, eignet sich eine Kombination aus dem Parameter <code>baseHref</code> und dem InjectionToken <code>APP_BASE_HREF</code>.</li>\n<li><strong>Event für routerLinkActive:</strong> Die Direktive <code>routerLinkActive</code> emittiert das Event <code>isActiveChange</code>, wenn sich der Aktivitätsstatus dieses Links ändert. Das kann man nutzen, um weitere Aktionen anzustoßen, wenn ein RouterLink aktiviert oder deaktiviert wird, siehe <a href=\"https://github.com/angular/angular/commit/faf9f5a3bc444bb6cbf75916c8022f60e0742bca\">Commit</a>.</li>\n<li><strong>Adobe Fonts Inlining:</strong> Fonts Inlining wurde bisher &quot;out of the box&quot; für Google Fonts unterstützt. Dabei werden beim Build die Font-Dateien heruntergeladen und zusammen mit der gebauten Anwendung abgelegt. Dieses Verfahren wird jetzt auch für Adobe Fonts unterstützt.</li>\n<li><strong>loadChildren String Syntax:</strong> Die veraltete String-Syntax für Lazy-Loading mit <code>loadChildren</code> wurde entfernt. Die alte Schreibweise ist seit Angular 9 deprecated und sollte ohnehin nicht mehr genutzt werden. </li>\n<li><strong>Zeitzone für DatePipe:</strong> Die <code>DatePipe</code> nutzt ein neues InjectionToken <code>DATE_PIPE_DEFAULT_TIMEZONE</code>, mit dem die Zeitzone eingestellt werden kann, siehe <a href=\"https://github.com/angular/angular/commit/adf4481211ac0a2eabf560f42ef5193ca550ec98\">Commit</a>.</li>\n<li><strong>min/max-Validatoren mit <code>null</code>:</strong> Bei Template-Driven Forms können die Validatoren für <code>min</code> und <code>max</code> nun auch den Eingabewert <code>null</code> verarbeiten. Der Validator wird dadurch deaktiviert. Ein ähnliches Verhalten wird bereits von <code>minLength</code> und <code>maxLength</code> unterstützt. Siehe <a href=\"https://github.com/angular/angular/commit/d9d8f950e90567c79b43eb156b81810a9f3d5c93\">Commit</a>.</li>\n<li><strong>renderModuleFactory entfernt:</strong> Die Funktion <code>renderModuleFactory</code>, die im Zusammenhang mit Server-Side Rendering relevant ist, steht nicht mehr zur Verfügung. Stattdessen soll die Funktion <code>renderModule</code> genutzt werden.</li>\n</ul>\n<p>Es hat sich also einiges getan, und es wurden viele Punkte aus der Sektion &quot;In progress&quot; von der Roadmap (Stand: 19.05.2021) abgearbeitet. Als einer der wichtigsten offenen Punkte sind nun noch die optionalen NgModules zu sehen, für die es jüngst eine Befragung der Community gab (siehe <a href=\"https://github.com/angular/angular/discussions/43784\">RFC</a>). \nDie Roadmap für die zukünftige Entwicklung von Angular wird regelmäßig in der Dokumentation veröffentlicht: <a href=\"https://angular.io/guide/roadmap\">https://angular.io/guide/roadmap</a>.</p>\n<p>Wir wünschen Ihnen viel Spaß mit Angular 13!\nHaben Sie Fragen zur neuen Version, zum Update oder zu Angular? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß wünschen\nDanny, Ferdinand und Johannes</strong></p>\n<p><small><strong>Titelbild:</strong> Blick vom Poon Hill, Nepal, 2018. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 13 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2021-11-03T00:00:00.000Z","lastModified":"2022-06-02T00:00:00.000Z","keywords":["Angular","Angular 13","Ivy"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2021-11-angular13/angular13.jpg","sticky":false}}
