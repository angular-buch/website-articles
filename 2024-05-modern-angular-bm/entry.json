{"slug":"2024-05-modern-angular-bm","html":"<p>Angular erlebt einen Aufschwung: Mit den letzten Major-Versionen des Frameworks wurden einige wichtige neue Konzepte und Features eingeführt.\nWir berichten darüber regelmäßig in unseren Blogposts zu den Angular-Releases.\nIn diesem Artikel wollen wir das Beispielprojekt &quot;BookMonkey&quot; aus dem Angular-Buch aktualisieren und die neuesten Konzepte von Angular praktisch einsetzen.</p>\n<p>Besonders interessant sind die folgenden Neuerungen:</p>\n<ul>\n<li>Die <strong>Standalone Features</strong> sind inzwischen stark etabliert und Standard in jeder neuen Angular-Anwendung. <strong>Module</strong> sind dadurch optional geworden und werden früher oder später vermutlich ganz aus Angular verschwinden.</li>\n<li>Der <strong>Control Flow mit <code>@if</code> und <code>@for</code></strong> ist der empfohlene Weg, um Verzweigungen und Schleifen im Template abzubilden. Die Direktiven <code>ngIf</code> und <code>ngFor</code> werden vermutlich in einer späteren Version verschwinden.</li>\n<li><strong>Signals</strong> sind stable und werden immer mehr die Schnittstellen von Angular integriert. In der Community entstehen Patterns und Bibliotheken rund um Signals.</li>\n<li>Für die Dependency Injection geht der Trend dazu, die <strong>Funktion <code>inject()</code></strong> zu verwenden, anstatt Abhängigkeiten über den Konstruktor anzufordern.</li>\n<li><strong>Interceptoren, Guards und Resolver</strong> werden als einfache Funktionen definiert, anstatt Klassen zu verwenden.</li>\n<li>Mit dem neuen <strong>Application Builder</strong> wurde das Build-System auf ESBuild mit Vite umgestellt. Gleichzeitig wurde Server-Side Rendering (SSR) direkt in diesen neuen Builder integriert.</li>\n<li>Kleinere Features sind die <strong>View Transition API</strong> und die Direktive <code>NgOptimizedImage</code>.</li>\n</ul>\n<p>Die einzelnen Features haben wir bereits separat in den jeweiligen Artikeln zu den Major-Releases vorgestellt:</p>\n<ul>\n<li><a href=\"/blog/2022-11-angular15\">Angular 15 ist da!</a></li>\n<li><a href=\"/blog/2023-05-angular16\">Angular 16 ist da!</a></li>\n<li><a href=\"/blog/2023-11-angular17\">Angular 17 ist da!</a></li>\n</ul>\n<p>Zum Thema Server-Side Rendering mit Angular 17 haben wir einen separaten Artikel veröffentlicht:</p>\n<ul>\n<li><a href=\"/blog/2023-11-ssr-bm\">Book Monkey v5: Server-Side Rendering mit Angular 17</a></li>\n</ul>\n<p><strong>Inhaltsverzeichnis:</strong></p>\n<ul>\n<li><a href=\"/blog/2024-05-modern-angular-bm#die-ausgangsbasis\">Die Ausgangsbasis</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#inject-statt-constructor-injection\"><code>inject()</code> statt Constructor Injection</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#asyncvalidator-als-funktion-mit-inject\">AsyncValidator als Funktion mit <code>inject()</code></a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#standalone-components\">Standalone Components</a><ul>\n<li><a href=\"/blog/2024-05-modern-angular-bm#komponenten-direktiven-und-pipes-migrieren\">Komponenten, Direktiven und Pipes migrieren</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#bootstrapping-mit-standalone-api\">Bootstrapping mit Standalone API</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#applicationconfig-anlegen\">ApplicationConfig anlegen</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#routen-migrieren\">Routen migrieren</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#ngmodules-entfernen\">NgModules entfernen</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#functional-interceptors\">Functional Interceptors</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#control-flow-mit-if-und-for\">Control Flow mit <code>@if</code> und <code>@for</code></a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#application-builder-verwenden\">Application Builder verwenden</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#signals\">Signals</a><ul>\n<li><a href=\"/blog/2024-05-modern-angular-bm#signals-in-komponenten-einsetzen\">Signals in Komponenten einsetzen</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#observables-in-signals-konvertieren\">Observables in Signals konvertieren</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#signals-in-observables-konvertieren\">Signals in Observables konvertieren</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#signal-based-inputs\">Signal-based Inputs</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#Router-input-bindings-signals-und-rxjs\">Router Input Bindings, Signals und RxJS</a><ul>\n<li><a href=\"/blog/2024-05-modern-angular-bm#component-input-binding-aktivieren\">Component Input Binding aktivieren</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#kombination-mit-signal-inputs\">Kombination mit Signal Inputs</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#functional-outputs\">Functional Outputs</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#direktive-ngoptimizedimage-verwenden\">Direktive <code>NgOptimizedImage</code> verwenden</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#komponenten-stylesheets-styleurls--styleurl\">Komponenten-Stylesheets: <code>styleUrls</code> =&gt; <code>styleUrl</code></a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#migrations-schematics-von-ngxtension-verwenden\">Migrations-Schematics von ngxtension verwenden</a></li>\n<li><a href=\"/blog/2024-05-modern-angular-bm#demo-und-code\">Demo und Code</a></li>\n</ul>\n<h2 id=\"die-ausgangsbasis\">Die Ausgangsbasis</h2>\n<p>Als Grundlage verwenden wir das Projekt <em>BookMonkey</em> aus unserem Angular-Buch der 4. Auflage.\nIm letzten Praxiskapitel haben wir das Projekt bereits teilweise auf Standalone Components migriert. Der Code ist hier auf GitHub zu finden:</p>\n<ul>\n<li><a href=\"https://github.com/book-monkey5/17-standalone\">BookMonkey: 17-standalone</a></li>\n</ul>\n<p>Sollten Sie bisher nicht mit dem Buch gearbeitet haben, können sie gern trotzdem hier einsteigen: Sie können das Repository <a href=\"https://github.com/book-monkey5/17-standalone/archive/refs/heads/main.zip\">als ZIP herunterladen</a> oder direkt Git verwenden:</p>\n<pre><code class=\"language-sh\">git <span class=\"hljs-built_in\">clone</span> https://github.com/book-monkey5/17-standalone.git\n<span class=\"hljs-built_in\">cd</span> 17-standalone\n</code></pre>\n<p>Installieren Sie anschließend die Abhängigkeiten mithilfe von NPM und starten Sie das Projekt einmal, um sicherzustellen, dass alles korrekt funktioniert:</p>\n<pre><code class=\"language-sh\">npm <span class=\"hljs-keyword\">install</span>\nng serve\n</code></pre>\n<p>Wir werden in den folgenden Abschnitten alle Schritte für die Migration beschreiben.\nDie Inhalte lassen sich also auch ideal auf andere Projekte abbilden.</p>\n<p>Für alle vorgestellten Features setzen wir auf <strong>Angular in Version 17.3</strong>.</p>\n<h2 id=\"inject-statt-constructor-injection\"><code>inject()</code> statt Constructor Injection</h2>\n<p>Wir wollen damit starten, die Dependency Injection konsequent mit <code>inject()</code> umzusetzen.\nDie Funktion <code>inject()</code> wurde mit <a href=\"/blog/2022-06-angular14\">Angular 14</a> vorgestellt und erfreut sich seitdem großer Beliebtheit.\nViele Komponenten kommen inzwischen komplett ohne Konstruktor aus.\nIn einigen Situationen, zum Beispiel bei Functional Guards, Resolvers oder Interceptors, kommen wir um die Verwendung ohnehin nicht herum.</p>\n<p>Die Funktion <code>inject()</code> bringt gegenüber der klassischen Constructor Injection unter anderem die folgenden Vorteile:</p>\n<ul>\n<li>Vermeidung von Konflikten zwischen den unterschiedlichen Klassen-Implementierungen von TypeScript und JavaScript. Stichwort: <code>useDefineForClassFields</code>, wir haben hierzu bereits einen <a href=\"/blog/2022-11-use-define-for-class-fields\">separaten Artikel verfasst</a>.</li>\n<li>Konsistenz: Wir verwenden einen einheitlichen Stil</li>\n<li>Nutzung auch innerhalb von Funktionen möglich, solange diese in einem Injection Context aufgerufen werden.</li>\n</ul>\n<p>Um alle Stellen für die Migration zu finden, können wir im gesamten Projekt nach <code>constructor(</code> suchen.</p>\n<p>Wir schauen uns zunächst die Klasse <code>LoggedinOnlyDirective</code> an.\nVor der Migration sieht der Code wie folgt aus:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Directive</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoggedinOnlyDirective</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">OnDestroy</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">template</span>: <span class=\"hljs-title class_\">TemplateRef</span>&lt;<span class=\"hljs-built_in\">unknown</span>&gt;,\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">viewContainer</span>: <span class=\"hljs-title class_\">ViewContainerRef</span>,\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">authService</span>: <span class=\"hljs-title class_\">AuthService</span>\n  </span>) {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Die Argumente des Konstruktors werden nun entfernt.\nStattdessen importieren wir die Funktion <code>inject()</code> und verwenden sie, um die Propertys direkt zu initialisieren.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// loggedin-only.directive.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, <span class=\"hljs-keyword\">inject</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n@Directive({ <span class=\"hljs-comment\">/* ... */</span> })\nexport <span class=\"hljs-keyword\">class</span> LoggedinOnlyDirective <span class=\"hljs-keyword\">implements</span> OnDestroy {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">private</span> template = <span class=\"hljs-keyword\">inject</span>(TemplateRef);\n  <span class=\"hljs-keyword\">private</span> viewContainer = <span class=\"hljs-keyword\">inject</span>(ViewContainerRef);\n  <span class=\"hljs-keyword\">private</span> authService = <span class=\"hljs-keyword\">inject</span>(AuthService);\n\n  constructor() {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Sollte der Konstruktor nach der Migration keinen Inhalt mehr besitzen, können wir die Methode vollständig entfernen.</p>\n<blockquote>\n<p>Übrigens: Das Projekt <em>ngxtension</em> stellt zur Migration auf <code>inject()</code> ein Migrationsskript als <a href=\"https://ngxtension.netlify.app/utilities/migrations/inject-migration/\">Schematic</a> bereit.</p>\n</blockquote>\n<h2 id=\"asyncvalidator-als-funktion-mit-inject\">AsyncValidator als Funktion mit <code>inject()</code></h2>\n<p>Dank <code>inject()</code> können wir den <code>AsyncValidatorsService</code> zu einer einfachen Funktion umbauen.\nDieser Service für die asynchrone Formularvalidierung war ursprünglich nur notwendig, weil wir den Konstruktor brauchten, um den <code>BookStoreService</code> per Dependency Injection anzufordern.\nWir können den Validator <code>isbnExists</code> jetzt ebenso als einfache Funktion definieren, wie wir es bei den synchronen Validatoren in der Datei <code>validators.ts</code> bereits getan haben.\nDen <code>BookStoreService</code> fordern wir mithilfe von <code>inject()</code> an und nutzen dafür die Variable <code>service</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// validators.ts</span>\n<span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, <span class=\"hljs-title class_\">AsyncValidatorFn</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { map } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>;\n\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BookStoreService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../../shared/book-store.service&#x27;</span>;\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isbnExists</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">AsyncValidatorFn</span> {\n  <span class=\"hljs-keyword\">const</span> service = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookStoreService</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">control: AbstractControl</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> service\n      .<span class=\"hljs-title function_\">check</span>(control.<span class=\"hljs-property\">value</span>)\n      .<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">exists</span>) =&gt;</span> (exists ? { <span class=\"hljs-attr\">isbnexists</span>: <span class=\"hljs-literal\">true</span> } : <span class=\"hljs-literal\">null</span>)));\n  };\n};\n</code></pre>\n<p>Wichtig ist, dass <code>isbnExists()</code> weiterhin eine Factory-Funktion ist, die den Validator erst beim Aufruf generiert.\nNur so ist gewährleistet, dass <code>inject()</code> bei der Verwendung in einem Injection Context aufgerufen wird, nämlich bei Instanziierung der Komponentenklasse.</p>\n<p>In der <code>BookFormComponent</code> fordern wir nun nicht mehr den <code>AsyncValidatorsService</code> an, sondern nutzen direkt die neu erstellte Funktion <code>isbnExists()</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// book-form.component.ts</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> { atLeastOneValue, isbnFormat, isbnExists } from <span class=\"hljs-string\">&#x27;../shared/validators&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookFormComponent</span> </span>{\n  <span class=\"hljs-comment\">// ...</span>\n\n  form = <span class=\"hljs-keyword\">new</span> FormGroup({\n    <span class=\"hljs-comment\">// ...</span>\n    isbn: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, {\n      nonNullable: <span class=\"hljs-keyword\">true</span>,\n      validators: [Validators.<span class=\"hljs-keyword\">required</span>, isbnFormat],\n      asyncValidators: isbnExists(),\n    }),\n    <span class=\"hljs-comment\">// ...</span>\n  });\n\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Die Datei <code>async-validators.service.ts</code> kann anschließend gelöscht werden.\nDer Code für den asychronen Validator hat sich damit stark vereinfacht, und der Overhead durch die Serviceklasse entfällt.</p>\n<h2 id=\"standalone-components\">Standalone Components</h2>\n<p>Im nächsten Schritt wollen wir die Anwendung konsistent mit Standalone APIs implementieren.\nDas Feature <code>books</code> haben wir im Praxiskapitel zu Standalone Components bereits migriert.\nUm das Projekt vollständig ohne Module umzusetzen, müssen wir noch folgende Anpassungen durchführen:</p>\n<ol>\n<li>Die restlichen Komponenten zu Standalone Components migrieren: <code>SearchComponent</code>, <code>HomeComponent</code>, gesamtes <code>AdminModule</code> mit allen Komponenten</li>\n<li>alle nicht mehr benötigten Module entfernen</li>\n<li>Anwendung direkt mit <code>AppComponent</code> bootstrappen, ohne <code>AppModule</code></li>\n</ol>\n<p>Wenn wir diese Schritte manuell durchführen wollen, liegt eine ganze Menge Arbeit vor uns.\nGlücklicherweise bietet Angular ein Migrationsskript an, um einen Großteil der Aufgaben zu automatisieren.</p>\n<pre><code class=\"language-sh\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:standalone\n</code></pre>\n<p>Führen wir diesen Befehl aus, können wir aus drei Migrationsschritten wählen:</p>\n<pre><code>? Choose <span class=\"hljs-keyword\">the</span> type <span class=\"hljs-keyword\">of</span> migration: (Use arrow <span class=\"hljs-built_in\">keys</span>)\n❯ Convert all components, directives <span class=\"hljs-keyword\">and</span> pipes <span class=\"hljs-built_in\">to</span> standalone\n  Remove unnecessary NgModule classes\n  Bootstrap <span class=\"hljs-keyword\">the</span> application <span class=\"hljs-keyword\">using</span> standalone APIs\n</code></pre>\n<h3 id=\"komponenten-direktiven-und-pipes-migrieren\">Komponenten, Direktiven und Pipes migrieren</h3>\n<p>Wir starten mit der ersten Option, um alle Komponenten, Direktiven und Pipes zu migrieren.\nDabei wird automatisch für alle diese Klassen das Flag <code>standalone</code> mit dem Wert <code>true</code> gesetzt.\nAußerdem wird das Template analysiert, und alle verwendeten Komponenten, Pipes und Direktiven werden automatisch unter <code>imports</code> im Kopf der Komponente eingetragen.</p>\n<p>Im Anschluss sollten wir alle durchgeführten Änderungen noch einmal überprüfen.\nDie <code>HomeComponent</code> sieht nach der Migration zum Beispiel wie folgt aus:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { SearchComponent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../search/search.component&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { RouterLink } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/router&#x27;</span>;\n\n@Component({\n  <span class=\"hljs-regexp\">//</span> ...\n  standalone: <span class=\"hljs-literal\">true</span>,\n  imports: [RouterLink, SearchComponent]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomeComponent</span> {}\n</code></pre>\n<p>Damit die Anwendung weiterhin funktioniert, wurden alle migrierten Komponenten, Direktiven und Pipes innerhalb der Module verschoben: Sie stehen nun nicht mehr unter <code>declarations</code>, sondern unter <code>imports</code>:</p>\n<pre><code class=\"language-ts\">// admin.module.ts\n<span class=\"hljs-variable\">@NgModule</span>({\n  declarations: []\n  imports: [\n    <span class=\"hljs-regexp\">//</span> ...\n    BookFormComponent,\n    BookCreateComponent,\n    BookEditComponent,\n    FormErrorsComponent\n  ],\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdminModule</span> </span>{ }\n</code></pre>\n<h3 id=\"bootstrapping-mit-standalone-api\">Bootstrapping mit Standalone API</h3>\n<p>Wir führen den Migrationsbefehl erneut aus und wählen die dritte Option: die Anwendung bootstrappen mit Standalone APIs.\nBei diesem Schritt wird das <code>AppModule</code> entfernt, und in der <code>main.ts</code> wird die Funktion <code>bootstrapApplication()</code> genutzt, um die Anwendung direkt mit der <code>AppComponent</code> zu bootstrappen.</p>\n<p>Alle Providers aus dem <code>AppModule</code> werden dabei in die Datei <code>main.ts</code> verschoben.\nDie Funktion <code>importProvidersFrom()</code> erlaubt es uns, die Providers aus den referenzierten Modulen zu extrahieren.\nDabei können wir das <code>BrowserModule</code> aus der Liste entfernen: Es wird in einer reinen Standalone-Anwendung nicht mehr benötigt.</p>\n<p>Anstatt das <code>HttpClientModule</code> einzubinden, wird nach der Migration die Funktion <code>provideHttpClient()</code> verwendet.\nDamit der klassenbasierte Interceptor, der per Provider bereitgestellt wird, weiterhin funktioniert, wird die Funktion <code>withInterceptorsFromDi()</code> angegeben.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// main.ts</span>\n<span class=\"hljs-keyword\">import</span> { importProvidersFrom } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { bootstrapApplication } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">HTTP_INTERCEPTORS</span>, provideHttpClient, withInterceptorsFromDi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-title function_\">bootstrapApplication</span>(<span class=\"hljs-title class_\">AppComponent</span>, {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">importProvidersFrom</span>(<span class=\"hljs-title class_\">AppRoutingModule</span>),\n    <span class=\"hljs-title function_\">provideHttpClient</span>(<span class=\"hljs-params\">withInterceptorsFromDi()</span>)\n    {\n      <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">HTTP_INTERCEPTORS</span>,\n      <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">AuthInterceptor</span>,\n      <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>\n    },\n  ]\n}).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err));\n</code></pre>\n<p>In unserem Test blieb in der <code>main.ts</code> der Import für die Funktion <code>platformBrowserDynamic</code> übrig, der allerdings nicht benötigt wird.\nSie können diese Zeile entfernen.</p>\n<p>Übrigens empfehlen wir, auch in einer modulbasierten Anwendung die neue Funktion <code>provideHttpClient()</code> zu nutzen und nicht mehr das alte <code>HttpClientModule</code>.\nDieses Modul wird mit Angular 18 <a href=\"https://github.com/angular/angular/commit/f914f6a3628847c06cbdde9c90cd417fb2f4c61f\">als <em>deprecated</em> markiert</a>.\nFür den Umstieg bietet das Framework beim Update auf Angular 18 eine automatische Migration an.</p>\n<h3 id=\"applicationconfig-anlegen\">ApplicationConfig anlegen</h3>\n<p>In neu angelegten Angular-Projekten werden die globalen Providers in einer separaten Datei <code>app.config.ts</code> abgelegt. Damit bleibt die Datei <code>main.ts</code> schlank und beinhaltet nur den reinen Aufruf für das Bootstrapping.</p>\n<p>Um die Struktur an neu angelegte Anwendungen anzugleichen, empfehlen wir Ihnen, selbst manuell die Datei <code>src/app/app.config.ts</code> anzulegen.\nSie beinhaltet unsere <code>ApplicationConfig</code> mit den Providers:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// app.config.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">HTTP_INTERCEPTORS</span>, provideHttpClient, withInterceptorsFromDi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ApplicationConfig</span>, importProvidersFrom } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AuthInterceptor</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./shared/auth.interceptor&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppRoutingModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app-routing.module&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">importProvidersFrom</span>(<span class=\"hljs-title class_\">AppRoutingModule</span>),\n    {\n      <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">HTTP_INTERCEPTORS</span>,\n      <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">AuthInterceptor</span>,\n      <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>\n    },\n    <span class=\"hljs-title function_\">provideHttpClient</span>(<span class=\"hljs-title function_\">withInterceptorsFromDi</span>())\n  ]\n};\n</code></pre>\n<p>Die Datei <code>main.ts</code> importiert dann diese Variable:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// main.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app/app.component&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { bootstrapApplication } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { appConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app/app.config&#x27;</span>;\n\n<span class=\"hljs-title function_\">bootstrapApplication</span>(<span class=\"hljs-title class_\">AppComponent</span>, appConfig)\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err));\n</code></pre>\n<h3 id=\"routen-migrieren\">Routen migrieren</h3>\n<p>Unser Feature-Modul <code>AdminModule</code> ist nun fast überflüssig, denn es importiert nur einige Komponenten und Module.\nDamit die Klasse aber entfernt werden kann, müssen wir zuvor das zugehörige <code>AdminRoutingModule</code> auflösen.</p>\n<p>Dazu entfernen wir aus der Datei <code>app-routing.module.ts</code> zunächst die Modulklasse und exportieren das Array mit Routen direkt unter dem Namen <code>ADMIN_ROUTES</code>.\nDie Datei nennen wir außerdem um zu <code>admin.routes.ts</code>:</p>\n<pre><code class=\"language-ts\">// admin<span class=\"hljs-selector-class\">.routes</span><span class=\"hljs-selector-class\">.ts</span>\n// ...\nexport const ADMIN_ROUTES: Routes = [\n  {\n    <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n    redirectTo: <span class=\"hljs-string\">&#x27;create&#x27;</span>,\n    pathMatch: <span class=\"hljs-string\">&#x27;full&#x27;</span>\n  },\n  {\n    <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;create&#x27;</span>,\n    component: BookCreateComponent,\n  },\n  {\n    <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;edit/:isbn&#x27;</span>,\n    component: BookEditComponent,\n  }\n];\n</code></pre>\n<p>In der Datei <code>admin.module.ts</code> können wir nun den Import für das <code>AdminRoutingModule</code> entfernen.</p>\n<p>Anschließend migrieren wir auf die gleiche Weise das <code>AppRoutingModule</code>:</p>\n<ul>\n<li>Modulklasse entfernen</li>\n<li>Array von Routen direkt exportieren</li>\n<li>Datei umbenennen zu <code>app.routes.ts</code></li>\n</ul>\n<p>Außerdem müssen wir die Basisroute <code>admin</code> anpassen: Bisher wurde hier mittels Lazy Loading das <code>AdminRoutingModule</code> eingebunden.\nDiesen Pfad müssen wir ändern, sodass unsere direkt exportierten <code>ADMIN_ROUTES</code> geladen werden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// app.routes.ts</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">export</span> const routes: Routes = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n    <span class=\"hljs-attr\">redirectTo</span>: <span class=\"hljs-string\">&#x27;home&#x27;</span>,\n    <span class=\"hljs-attr\">pathMatch</span>: <span class=\"hljs-string\">&#x27;full&#x27;</span>\n  },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;home&#x27;</span>,\n    <span class=\"hljs-attr\">component</span>: HomeComponent,\n  },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books&#x27;</span>,\n    <span class=\"hljs-attr\">loadChildren</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./books/books.routes&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> m.BOOKS_ROUTES)\n  },\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;admin&#x27;</span>,\n    <span class=\"hljs-attr\">loadChildren</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./admin/admin.routes&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> m.ADMIN_ROUTES),\n    <span class=\"hljs-attr\">canActivate</span>: [authGuard]\n    <span class=\"hljs-comment\">/* VORHER: loadChildren: () =&gt; import(&#x27;./admin/admin.module&#x27;).then(m =&gt; m.AdminModule), */</span>\n  }\n];\n</code></pre>\n<p>Damit die App-Routen genutzt werden, müssen wir das Array an den Router übergeben.\nDazu verwenden wir in der ApplicationConfig in <code>app.config.ts</code> die Funktion <code>provideRouter()</code>.\nDer Aufruf von <code>importProvidersFrom()</code> mit dem <code>AppRoutingModule</code> ist jetzt nicht mehr notwendig.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// app.config.ts</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> { provideRouter } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/router&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { routes } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app/app.routes&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideRouter</span>(routes),\n    <span class=\"hljs-comment\">// ...</span>\n  ]\n})\n</code></pre>\n<p>Entfernen Sie bitte auf dem Weg alle nicht mehr genutzten Imports aus den Köpfen der Dateien.</p>\n<h3 id=\"ngmodules-entfernen\">NgModules entfernen</h3>\n<p>Das <code>AdminModule</code> ist nun nur noch eine leere Hülle:\nEs wird nirgendwo mehr genutzt, sodass wir die Datei <code>admin.module.ts</code> gefahrlos entfernen können.\nWir haben damit die Anwendung erfolgreich auf die Standalone APIs migriert.</p>\n<h2 id=\"functional-interceptors\">Functional Interceptors</h2>\n<p>Als Nächstes wollen wir den Interceptor zur Authentifizierung in eine Funktion umwandeln.\nDie bisherige Implementierung als Klasse sieht so aus:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Injectable()</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AuthInterceptor</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">HttpInterceptor</span> {\n  <span class=\"hljs-keyword\">private</span> authService = inject(AuthService);\n\n  intercept(\n    request: HttpRequest&lt;unknown&gt;,\n    next: HttpHandler\n  ): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {\n    <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-string\">&#x27;1234567890&#x27;</span>;\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.authService.isAuthenticated) {\n      <span class=\"hljs-comment\">// ...</span>\n      <span class=\"hljs-keyword\">return</span> next.handle(reqWithToken);\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> next.handle(request);\n    }\n  }\n}\n</code></pre>\n<p>Ein Functional Interceptor ist grundsätzlich ähnlich aufgebaut, er besteht aber nur aus der Funktion, die bisher als Methode <code>intercept()</code> in der Klasse existierte.\nDiese Funktion vom Typ <code>HttpInterceptorFn</code> erhält als Argumente den eingehenden Request und eine <code>HttpHandlerFn</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">authInterceptor</span>: <span class=\"hljs-title class_\">HttpInterceptorFn</span> = (\n  <span class=\"hljs-attr\">req</span>: <span class=\"hljs-title class_\">HttpRequest</span>&lt;<span class=\"hljs-built_in\">unknown</span>&gt;,\n  <span class=\"hljs-attr\">next</span>: <span class=\"hljs-title class_\">HttpHandlerFn</span>\n): <span class=\"hljs-title class_\">Observable</span>&lt;<span class=\"hljs-title class_\">HttpEvent</span>&lt;<span class=\"hljs-built_in\">unknown</span>&gt;&gt; =&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Durch den Typ <code>HttpInterceptorFn</code> ist die Signatur der Funktion schon vollständig beschrieben, sodass wir die Typen für die Argumente gar nicht explizit im Code notieren müssen.\nDer Auth-Interceptor kann also wie folgt eingekürzt werden.\nAnstelle von <code>next.handle()</code> rufen wir jetzt direkt die <code>HttpHandlerFn</code> mit <code>next()</code> auf.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// auth.interceptor.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpEvent</span>, <span class=\"hljs-title class_\">HttpHandlerFn</span>, <span class=\"hljs-title class_\">HttpRequest</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">authInterceptor</span>: <span class=\"hljs-title class_\">HttpInterceptorFn</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">req, next</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> authService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">AuthService</span>)\n  <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-string\">&#x27;1234567890&#x27;</span>;\n\n  <span class=\"hljs-keyword\">if</span> (authService.<span class=\"hljs-property\">isAuthenticated</span>) {\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">next</span>(reqWithToken);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">next</span>(req);\n  }\n}\n</code></pre>\n<p>Mit einem solchen Functional Interceptor ist auch die Registrierung in der Anwendung etwas einfacher:\nIn der Datei <code>main.ts</code> entfernen wir den Provider für das DI-Token <code>HTTP_INTERCEPTORS</code>.\nStattdessen nutzen wir im Aufruf von <code>provideHttpClient()</code> die Funktion <code>withInterceptors()</code> (statt <code>withInterceptorsFromDi()</code>) und übergeben den neuen Interceptor in einem Array.\nDer Interceptor wird damit direkt registriert.</p>\n<p>Übrigens können wir den HttpClient noch weiter konfigurieren:\nMit der Funktion <code>withFetch()</code> verwendet Angular im Hintergrund die modernere <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">Fetch API</a>.\nDamit wäre auch ein Deployment in einer Edge-Computing-Infrastruktur wie zum Beispiel CloudFlare Workers möglich, bei der nur die Fetch API unterstützt wird.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// app.config.ts</span>\n<span class=\"hljs-keyword\">import</span> {\n  provideHttpClient,\n  withInterceptors,\n  withFetch\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> { authInterceptor } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app/shared/auth.interceptor&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-title function_\">provideHttpClient</span>(\n      <span class=\"hljs-title function_\">withFetch</span>(),\n      <span class=\"hljs-title function_\">withInterceptors</span>([authInterceptor])\n    ),\n  ]\n};\n</code></pre>\n<h2 id=\"control-flow-mit-if-und-for\">Control Flow mit <code>@if</code> und <code>@for</code></h2>\n<p>Mit Angular 17 wurde die neue Ablaufsteuerung im Template vorgestellt:\nAnstatt die Direktiven <code>ngIf</code> und <code>ngFor</code> einzusetzen, nutzen wir für Verzweigungen und Schleifen die neuen Ausdrücke <code>@if</code> und <code>@for</code>.\nDas hat den Vorteil, dass wir die Direktiven nicht einzeln importieren müssen. Der Control Flow wird direkt vom Compiler ausgewertet.</p>\n<p>Auch wenn der Control Flow mit Angular 17 noch im Status <em>Developer Preview</em> ist, empfehlen wir die Nutzung bereits jetzt.</p>\n<p>Um nicht alle Komponenten von Hand migrieren zu müssen, gibt uns Angular auch hier ein Migrationswerkzeug mit an die Hand.\nEs erfolgt eine Migration der Template-Syntax, und im Nachgang werden auch automatisch die unnötigen Imports der Direktiven <code>NgIf</code> und <code>NgFor</code> entfernt:</p>\n<pre><code class=\"language-sh\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:control-flow\n</code></pre>\n<p>Bitte prüfen Sie anschließend noch einmal alle Änderungen gründlich. In komplexen Fällen kann die Migration unter Umständen nicht komplett automatisch durchgeführt werden.</p>\n<p>Nach der Ausführung können wir noch zwei Punkte an den Komponenten <code>BookListComponent</code> und <code>SearchComponent</code> optimieren.</p>\n<p>Mit <code>@for</code> ist es verpflichtend, eine Tracking-Information mithilfe von <code>track</code> anzugeben.\nAngular verwendet dieses Merkmal, um die Elemente der iterierten Liste zu identifizieren.\nWenn wir eine Liste von Entitäten anzeigen, die eine ID besitzen, verwenden wir diese ID als Unterscheidungsmerkmal.\nDa wir in den beiden Komponenten über ein Array von Buch-Objekten iterieren, eignet sich hier die ISBN am besten, sodass wir <code>book.isbn</code> als Trackingmerkmal verwenden.\nSollten die Elemente keine eindeutige ID besitzen, können Sie das Element selbst verwenden, oder – wenn die Liste sich zur Laufzeit nicht ändern wird – auch den Index (<code>$index</code>).</p>\n<p>Für die Anzeige leerer Resultate brauchen wir übrigens nicht zwingend ein gesondertes <code>@if</code>.\nStattdessen bietet <code>@for</code> einen eigenen <code>@empty</code>-Block an:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- book-list.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Books<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n@if (books$ | async; as books) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;book-list&quot;</span>&gt;</span>\n    @for (book of books; track book.isbn) {\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bm-book-list-item</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;book&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bm-book-list-item</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    } @empty {\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>No books available.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    }\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n}\n</code></pre>\n<p>Die <code>SearchComponent</code> wird auf dieselbe Weise umgebaut.</p>\n<h2 id=\"application-builder-verwenden\">Application Builder verwenden</h2>\n<p>Die aktuelle Version der Anwendung nutzt bereits den neuen Application Builder von Angular, der unter der Haube auf ESBuild und Vite zurückgreift.\nSollte bei Ihnen noch ein älterer Builder genutzt werden (<code>@angular-devkit/build-angular:browser</code> oder <code>@angular-devkit/build-angular:browser-esbuild</code>), empfehlen wir Ihnen, auf den neuen Builder umzusteigen.\nAuch hierfür hat das Angular-Team ein Schematic bereitgestellt:</p>\n<pre><code class=\"language-sh\">ng <span class=\"hljs-keyword\">update</span> <span class=\"hljs-variable\">@angular</span><span class=\"hljs-operator\">/</span>cli <span class=\"hljs-comment\">--name=use-application-builder</span>\n</code></pre>\n<p>Server-Side Rendering und Pre-Rendering sind in einer neuen Anwendung mit Angular 17 automatisch aktiviert.\nDer Application Builder kümmert sich um den kompletten Build-Prozess.\nWir haben die nötigen Einstellungen für statisches Pre-Rendering in unserem Beispielprojekt gesetzt, z. B. die Routenliste in der Datei <code>routes.txt</code>.</p>\n<p>Alle Änderungen am Code können Sie in der Differenzansicht nachvollziehen:\n<a href=\"https://book-monkey5.angular-buch.com/diffs/18-modern-angular.html\">Differenzansicht (17-standalone -&gt; 18-modern-angular)</a></p>\n<h2 id=\"signals\">Signals</h2>\n<p>Im nächsten Schritt wollen wir uns dem Thema Signals widmen.\nWir haben darüber im Blogpost zu Angular 16 bereits ausführlich berichtet, siehe: <a href=\"/blog/2023-05-angular16#reaktivit%C3%A4t-mit-signals\"><em>Angular 16 ist da! Abschnitt &quot;Reaktivität mit Signals&quot;</em></a>).</p>\n<p>Ein wichtiger Grund für die Einführung dieser neuen <em>Reactive Primitive</em> ist die Change Detection:\nUm festzustellen, ob sich Daten geändert haben, muss Angular derzeit vergleichsweise hohen Aufwand betreiben.\nAngular weiß niemals, <em>ob</em> und <em>welche</em> Daten sich tatsächlich ändern, sondern nur, dass es potenziell zu einer Datenänderung gekommen sein <em>könnte</em>.\nDafür verwendet Angular verschiedene Trigger, die die Change Detection auslösen. Zur Überwachung der Browser-Schnittstellen wird seit jeher die Bibliothek zone.js verwendet.</p>\n<p>Mit Signals soll diese unspezifische Herangehensweise geändert werden: Ein Signal hält einen Wert und informiert die Anwendung, sobald sich dieser Wert ändert.\nAuf diese Weise kann Angular gezielt die Views aktualisieren, in denen sich tatsächlich Daten geändert haben.</p>\n<p>Einige Stellen, an denen wir bisher Observables und die AsyncPipe von Angular eingesetzt haben, können auch ohne RxJS mit Signals umgesetzt werden.</p>\n<h3 id=\"signals-in-komponenten-einsetzen\">Signals in Komponenten einsetzen</h3>\n<p>Als Erstes werfen wir einen Blick in die <code>SearchComponent</code>:\nDas Property <code>isLoading</code> wird verwendet, um den Ladestatus der Suchanfrage zu erfassen.</p>\n<p>Angular konnte Änderungen an diesem Property nur ermitteln, weil das Event Binding im Template und die eintreffende HTTP-Response jeweils die Change Detection ausgelöst haben.\nWürden wir zone.js aus der Anwendung entfernen, würde der Ladeindikator nicht mehr korrekt angezeigt werden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Component({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SearchComponent</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  isLoading = <span class=\"hljs-literal\">false</span>;\n\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">this</span>.results$ = <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Dieses Dilemma lässt sich mit einem Signal elegant lösen:\nAnstatt den Wert direkt im Property zu speichern, verpacken wir das Loading-Flag in einem Signal.\nDas Objekt wird mit <code>false</code> initialisiert, und der Wert kann später mit der Methode <code>.set()</code> überschrieben werden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// search.component.ts</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> { Component, inject, signal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SearchComponent</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  isLoading = signal(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">this</span>.results$ = <span class=\"hljs-keyword\">this</span>.input$.pipe(\n      <span class=\"hljs-comment\">// ...</span>\n      tap(() =&gt; <span class=\"hljs-keyword\">this</span>.isLoading.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-literal\">true</span>)),\n      switchMap(term =&gt; <span class=\"hljs-keyword\">this</span>.service.getAllSearch(term)),\n      tap(() =&gt; <span class=\"hljs-keyword\">this</span>.isLoading.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-literal\">false</span>))\n    );\n  }\n}\n</code></pre>\n<p>Um Daten aus einem Signal zu lesen, rufen wir das Signal wie eine Funktion auf.\nWir müssen also das Template der <code>SearchComponent</code> anpassen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- search.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;search&quot;</span>\n  <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&quot;off&quot;</span>\n  <span class=\"hljs-attr\">aria-label</span>=<span class=\"hljs-string\">&quot;Search&quot;</span>\n  [<span class=\"hljs-attr\">class.loading</span>]=<span class=\"hljs-string\">&quot;isLoading()&quot;</span>\n  #<span class=\"hljs-attr\">searchInput</span>\n  (<span class=\"hljs-attr\">input</span>)=<span class=\"hljs-string\">&quot;input$.next(searchInput.value)&quot;</span>&gt;</span>\n</code></pre>\n<p>Sollten wir das einmal vergessen, informiert der Angular Language Service uns direkt im Editor mit einer Warnung.</p>\n<p>Nun kann der Ladezustand auch erfasst werden, ohne auf die Change Detection mittels zone.js angewiesen zu sein.\nDie Anwendung ist damit robuster für die Zukunft gewappnet.</p>\n<h3 id=\"observables-in-signals-konvertieren\">Observables in Signals konvertieren</h3>\n<p>Im nächsten Schritt werfen wir einen Blick auf die <code>BookListComponent</code>.\nHier nutzen wir bisher die AsyncPipe, um die Daten aus dem Observable mit Büchern anzuzeigen:</p>\n<pre><code class=\"language-ts\">// book-list.component.ts\n<span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  imports: [AsyncPipe, <span class=\"hljs-regexp\">/* ... */</span>],\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListComponent</span> </span>{\n  books$ = inject(BookStoreService).getAll();\n}\n</code></pre>\n<p>Mit der Funktion <code>toSignal()</code> können wir ein Observable in ein Signal umwandeln.\nDie Funktion kümmert sich automatisch darum, auf das Observable zu subscriben und die Daten im erzeugten Signal bereitzustellen.\nAuch das Beenden der Subscription wird automatisch erledigt.\nDamit müssen wir nicht die <code>AsyncPipe</code> importieren oder manuell auf das Observable subscriben.</p>\n<pre><code class=\"language-ts\">// book-list.component.ts\nimport { toSignal } from <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> ...\n\n<span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListComponent</span> </span>{\n  books = toSignal(inject(BookStoreService).getAll());\n}\n</code></pre>\n<p>Im Template rufen wir entsprechend das Signal auf, um die Buchliste zu lesen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- book-list.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Books<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n@if (books(); as books) {\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;book-list&quot;</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n}\n</code></pre>\n<p>Die Subscription auf dem Observable erfolgt einmalig und sofort, sobald wir die Funktion <code>toSignal()</code> benutzen.\nWir können den Wert aus dem Signal beliebig oft lesen, ohne dass erneut ein HTTP-Request ausgeführt wird.\nDieses Verhalten unterscheidet sich vom vorherigen Weg:\nBenutzen wir die <code>AsyncPipe</code> mehrfach, wird das Observable auch mehrfach subscribet.</p>\n<h3 id=\"signals-in-observables-konvertieren\">Signals in Observables konvertieren</h3>\n<p>Jetzt wollen wir noch den <code>AuthService</code> umbauen.\nAnstatt das Zustandsflag <code>isAuthenticated</code> als einfaches Property zu erfassen, wollen wir dafür ein Signal verwenden.\nDer Wert soll weiterhin auch über ein Observable <code>isAuthenticated$</code> bereitgestellt werden, damit wir reaktiv mit der Information arbeiten können.</p>\n<p>Als Basis zur Erfassung des Zustands wollen wir ein Signal verwenden, sodass wir kein <code>BehaviorSubject</code> mehr benötigen.\nDie Ausgabe als Observable können wir elegant mit der Funktion <code>toObservable()</code> erledigen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span>, signal } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { toObservable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n\n<span class=\"hljs-meta\">@Injectable</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AuthService</span> {\n  <span class=\"hljs-keyword\">readonly</span> isAuthenticated = <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-literal\">true</span>);\n  <span class=\"hljs-keyword\">readonly</span> isAuthenticated$ = <span class=\"hljs-title function_\">toObservable</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isAuthenticated</span>);\n\n  <span class=\"hljs-title function_\">login</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isAuthenticated</span>.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">true</span>);\n  }\n\n  <span class=\"hljs-title function_\">logout</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isAuthenticated</span>.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">false</span>);\n  }\n}\n</code></pre>\n<p>Die Aufrufe von <code>isAuthenticated</code> in den Dateien <code>app.component.html</code>, <code>auth.guard.ts</code> und <code>auth.interceptor.ts</code> müssen nun auch um die Klammern erweitert werden, um den Wert zu lesen: <code>isAuthenticated()</code>.</p>\n<p>Die Direktive <code>LoggedinOnlyDirective</code> können wir in diesem Zuge auch noch weiter vereinfachen.\nHier können wir auf das Konstrukt aus Observable und dem Operator <code>takeUntil</code> verzichten und stattdessen einen Effect verwenden:\nEin Effect reagiert auf Änderungen an den Signals, die wir in der Effect-Funktion verwenden.\nSobald sich einer der Eingabewerte ändert, wird die Berechnung erneut durchgeführt.\nAuf den Lifecycle-Hook <code>ngOnDestroy</code> können wir somit auch komplett verzichten, und der Code wird stark verkürzt:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, effect, inject } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-meta\">@Directive({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoggedinOnlyDirective</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">constructor</span>() {\n    effect(() =&gt; {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.authService.isAuthenticated()) {\n        <span class=\"hljs-keyword\">this</span>.viewContainer.createEmbeddedView(<span class=\"hljs-keyword\">this</span>.template);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>.viewContainer.clear();\n      }\n    });\n  }\n}\n</code></pre>\n<h2 id=\"signal-based-inputs\">Signal-based Inputs</h2>\n<p>Mit dem Minor-Release von Angular 17.1 wurde eine Alternative zum bisherigen <code>@Input()</code>-Dekorator auf Basis von Signals eingeführt, siehe die <a href=\"https://blog.angular.io/signal-inputs-available-in-developer-preview-6a7ff1941823\">offizielle Information im Angular-Blog</a>.\nNutzen wir die neue Funktion <code>input()</code>, wird der übergebene Wert eines Komponenten-Inputs direkt als Signal erfasst:</p>\n<pre><code class=\"language-ts\">isbn = <span class=\"hljs-built_in\">input</span>() // InputSignal<span class=\"hljs-symbol\">&lt;unknown&gt;</span>\nisbn = <span class=\"hljs-built_in\">input</span><span class=\"hljs-symbol\">&lt;string&gt;</span>() // InputSignal&lt;<span class=\"hljs-built_in\">string</span> | undefined&gt;\nisbn = <span class=\"hljs-built_in\">input</span>.required() // InputSignal<span class=\"hljs-symbol\">&lt;unknown&gt;</span>\nisbn = <span class=\"hljs-built_in\">input</span>.required<span class=\"hljs-symbol\">&lt;string&gt;</span>() // InputSignal<span class=\"hljs-symbol\">&lt;string&gt;</span>\nisbn = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&#x27;3864909465&#x27;</span>) // InputSignal<span class=\"hljs-symbol\">&lt;string&gt;</span>\n</code></pre>\n<p>Wir können einige Stellen unserer Anwendung auf diese neuen <em>Signal-based Inputs</em> umbauen.\nWir beginnen in der <code>FormErrorsComponent</code>: Statt <code>@Input()</code> setzen wir jeweils <code>input.required()</code> ein, da beide Informationen zwingend bei Verwendung der Komponente gesetzt werden müssen.\nUm das Signal zu lesen, dürfen wir im Getter <code>errors</code> die Funktionsklammern nicht vergessen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// form-errors.component.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, inject, input } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FormErrorsComponent</span> {\n  controlName = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n  messages = input.<span class=\"hljs-property\">required</span>&lt;{ [<span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span> }&gt;();\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">errors</span>(): <span class=\"hljs-built_in\">string</span>[] {\n    <span class=\"hljs-keyword\">const</span> control = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">form</span>.<span class=\"hljs-property\">control</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">controlName</span>());\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(control.<span class=\"hljs-property\">errors</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">errorCode</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">messages</span>()[errorCode];\n    });\n  }\n}\n</code></pre>\n<p>Nicht immer wollen wir, dass der Name des Propertys in der Komponente dem Namen entspricht, den wir beim Property Binding von außen verwenden.\nDiesen Fall haben wir bereits in der <code>ConfirmDirective</code> berücksichtigt.\nAuch mit Signal Inputs lässt sich ein <code>alias</code> konfigurieren.</p>\n<p>Wenn wir die Direktive verwenden, wollen wir den Text an das Property <code>bmConfirm</code> übergeben, das dem Attributnamen der Direktive entspricht.\nInnerhalb der Direktivenklasse soll dieses Property jedoch <code>confirmText</code> lauten.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// confirm.directive.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, input } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Directive</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;[bmConfirm]&#x27;</span>,\n  <span class=\"hljs-attr\">standalone</span>: <span class=\"hljs-literal\">true</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConfirmDirective</span> {\n  confirmText = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;({ <span class=\"hljs-attr\">alias</span>: <span class=\"hljs-string\">&#x27;bmConfirm&#x27;</span> });\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-meta\">@HostListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>) <span class=\"hljs-title function_\">onClick</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">confirm</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">confirmText</span>())) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">confirm</span>.<span class=\"hljs-title function_\">emit</span>();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>Das Projekt <em>ngxtension</em> stellt zur Migration auf Signal Inputs auch ein <a href=\"https://ngxtension.netlify.app/utilities/migrations/signal-inputs-migration/\">Schematic</a> bereit.</p>\n</blockquote>\n<h2 id=\"router-input-bindings-signals-und-rxjs\">Router Input Bindings, Signals und RxJS</h2>\n<p>Zum Abschluss dieses Abschnitts wollen wir ein neueres Feature des Routers verwenden: Component Input Bindings.\nDamit ist es möglich, Routenparameter per Input in einer Komponente zu empfangen.\nAnstatt also wie gewohnt den Service <code>ActivatedRoute</code> zu verwenden, erstellen in der Komponente ein Input, das den gleichen Namen trägt wie der Routenparameter:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{\n  <span class=\"hljs-variable\">@Input</span>() myParam?: string;\n  myParam2 = input&lt;string&gt;();\n}\n</code></pre>\n<p>Der Router befüllt diese Propertys automatisch mit Werten – sofern die Parameter in der Route existieren.\nDabei werden Path-Parameter, Query-Parameter und Routen-Daten gleichermaßen verarbeitet.\nTragen die verschiedenen Parameter-Typen den gleichen Namen, so ist nur einer der Werte verfügbar. Sie können die Implementierung im <a href=\"https://github.com/angular/angular/blob/17.3.6/packages/router/src/directives/router_outlet.ts#L459\">Quellcode von Angular</a> nachvollziehen.</p>\n<h3 id=\"component-input-binding-aktivieren\">Component Input Binding aktivieren</h3>\n<p>Damit diese Mechanik funktioniert, müssen wir das Feature zunächst im Router aktivieren.\nIn der Datei <code>app.config.ts</code> fügen wir unter <code>provideRouter()</code> den Aufruf der Funktion <code>withComponentInputBinding()</code> hinzu:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// app.config.ts</span>\n<span class=\"hljs-keyword\">import</span> { provideRouter, withComponentInputBinding } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/router&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideRouter</span>(routes, <span class=\"hljs-title function_\">withComponentInputBinding</span>()),\n    <span class=\"hljs-comment\">// ...</span>\n  ]\n};\n</code></pre>\n<h3 id=\"kombination-mit-signal-inputs\">Kombination mit Signal Inputs</h3>\n<p>Zusammen mit Signal Inputs und den Möglichkeiten von RxJS ergibt sich ein elegantes neues Pattern, das wir in unseren Komponenten einsetzen wollen.\nIn der <code>BookDetailsComponent</code> und <code>BookEditComponent</code> wird jeweils ein Buch anhand der ISBN geladen, die in der Route übergeben wird.</p>\n<p>Wir erzeugen zunächst ein passendes Input-Property mithilfe der Funktion <code>input()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookDetailsComponent</span> </span>{\n  isbn = input.required&lt;string&gt;();\n}\n</code></pre>\n<p>Da es sich um ein Signal handelt, kann Angular bei Wertänderungen direkt reagieren.\nWir wollen den Parameter aber weiterhin mit RxJS verarbeiten: Der HTTP-Call wird über ein Observable abgebildet, und auch die Charakteristik des Operators <code>switchMap</code> wollen wir weiterhin nutzen.</p>\n<p>Wir wandeln das Signal <code>isbn</code> also mit der Funktion <code>toObservable()</code> zunächst in ein Observable um.\nIn der Pipeline starten wir den HTTP-Request und rufen das Buch ab.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookDetailsComponent</span> </span>{\n  <span class=\"hljs-comment\">// ...</span>\n  isbn = input.<span class=\"hljs-keyword\">required</span>&lt;string&gt;();\n\n  book$ = toObservable(<span class=\"hljs-keyword\">this</span>.isbn).pipe(\n    switchMap(isbn =&gt; <span class=\"hljs-keyword\">this</span>.service.getSingle(isbn))\n  );\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>Auf dieselbe Weise gehen wir in der <code>BookEditComponent</code> vor.\nDer Code in der Komponentenklasse wird elegant verkürzt: Anstatt <code>ActivatedRoute</code> zu verwenden, stammt der Parameter aus dem Signal Input.\nDer Konstruktor entfällt vollständig, wenn wir das Property <code>book$</code> direkt zuweisen.\nAnschließend können wir die nicht benötigten Imports aufräumen.</p>\n<h2 id=\"functional-outputs\">Functional Outputs</h2>\n<p>Analog zur Funktion <code>input()</code> steht seit der Minor-Version Angular 17.3.0 eine Alternative zum <code>@Output()</code>-Dekorator bereit: die Funktion <code>output()</code>.\nDabei wurde auch die Typsicherheit verbessert: Wenn wir den Output typisieren, z. B. <code>output&lt;string&gt;()</code>, dann ist übergebene Payload bei <code>emit()</code> verpflichtend.\nBeim bisherigen Weg mit <code>EventEmitter</code> war der Payload hingegen immer optional.\nWollen wir keinen Payload übergeben, müssen wir den Output nicht typisieren, und es wird automatisch der Typ <code>void</code> für den Payload angenommen.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">select</span> = output() <span class=\"hljs-comment\">// OutputEmitterRef&lt;void&gt;</span>\nisbnChange = output&lt;<span class=\"hljs-built_in\">string</span>&gt;() <span class=\"hljs-comment\">// OutputEmitterRef&lt;string&gt;</span>\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">select</span>.emit(); <span class=\"hljs-comment\">// OK</span>\n<span class=\"hljs-keyword\">this</span>.isbnChange.emit(); <span class=\"hljs-comment\">// Error: Expected 1 arguments, but got 0.</span>\n<span class=\"hljs-keyword\">this</span>.isbnChange.emit(<span class=\"hljs-string\">&#x27;3864909465&#x27;</span>); <span class=\"hljs-comment\">// OK</span>\n</code></pre>\n<p>Wir wollen die neuen Functional Outputs in der <code>ConfirmDirective</code> nutzen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, output } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Directive</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConfirmDirective</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  confirm = <span class=\"hljs-title function_\">output</span>();\n\n  <span class=\"hljs-meta\">@HostListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>) <span class=\"hljs-title function_\">onClick</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">confirm</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">confirmText</span>())) {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">confirm</span>.<span class=\"hljs-title function_\">emit</span>();\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>Das Projekt <em>ngxtension</em> stellt zur Migration auf Functional Outputs auch ein <a href=\"https://ngxtension.netlify.app/utilities/migrations/new-outputs-migration/\">Schematic</a> bereit.</p>\n</blockquote>\n<h2 id=\"direktive-ngoptimizedimage-verwenden\">Direktive <code>NgOptimizedImage</code> verwenden</h2>\n<p>Bereits seit Angular 14.2 stellt das Framework eine Direktive zur optimierten Einbindung von Bildern bereit: <code>NgOptimizedImage</code>.\nWir haben hierzu im <a href=\"/blog/2022-11-angular15#image-directive-optimierte-verwendung-von-bildern\">Blogpost zum Release von Angular 15</a> berichtet.</p>\n<p>Wir starten mit der <code>BookListItemComponent</code>:\nDamit wir die Direktive im Template nutzen können, muss sie zuvor in der Komponente importiert werden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// book-list-item.component.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">NgOptimizedImage</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">RouterLink</span>, <span class=\"hljs-title class_\">IsbnPipe</span>, <span class=\"hljs-title class_\">NgOptimizedImage</span>]\n})\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>Im Anschluss ersetzen wir auf dem Element <code>&lt;img&gt;</code> das Attribut <code>src</code> durch <code>ngSrc</code>.\nDas Bild wird standardmäßig &quot;lazy&quot; geladen und blockiert somit nicht das Laden der gesamten Buchliste.\nDamit die Optimierung klappt und wir Layoutverschiebungen vermeiden, müssen wir noch die erwartete Größe des Bilds angeben, indem wir eine statische Breite und Höhe notieren.\nSomit kann bereits vorab der Platz zur Anzeige des Bilds reserviert werden.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- book-list-item.component.html --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;Cover&quot;</span> [<span class=\"hljs-attr\">ngSrc</span>]=<span class=\"hljs-string\">&quot;thumbnail&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;120&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;175&quot;</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n</code></pre>\n<p>Bei der Detailansicht der Bücher in der <code>BookDetailsComponent</code> gehen wir ähnlich vor:\nHier setzen wir jedoch zusätzlich das Attribut <code>priority</code>, da wir das Buchcover hier mit hoher Priorität laden wollen.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- book-details.component.html --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;Cover&quot;</span> [<span class=\"hljs-attr\">ngSrc</span>]=<span class=\"hljs-string\">&quot;book.thumbnailUrl&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;250&quot;</span> <span class=\"hljs-attr\">priority</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n</code></pre>\n<p>Damit das priorisierte Laden funktioniert, müssen wir in der Datei <code>index.html</code> ein Meta-Tag hinzufügen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- index.html --&gt;</span>\n<span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;preconnect&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://cdn.ng-buch.de&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n</code></pre>\n<h2 id=\"komponenten-stylesheets-styleurls--styleurl\">Komponenten-Stylesheets: <code>styleUrls</code> =&gt; <code>styleUrl</code></h2>\n<p>Zum Abschluss wollen wir noch eine eher kosmetische Änderung im Code durchführen:\nBisher wurden die Komponenten-Stylesheets standardmäßig als Array im Property <code>styleUrls</code> übergeben.\nDa es in den meisten Fällen aber nur genau eine Style-Datei gibt, können wir nun auch eine einzelne <code>styleUrl</code> als String angeben.\nNeue Komponenten werden bereits mit einer einzelnen <code>styleUrl</code> generiert.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-comment\">// VORHER:</span>\n  <span class=\"hljs-attribute\">styleUrls</span>: [<span class=\"hljs-string\">&#x27;./book-list.component.css&#x27;</span>],\n  <span class=\"hljs-comment\">// NACHHER:</span>\n  <span class=\"hljs-attribute\">styleUrl</span>: <span class=\"hljs-string\">&#x27;./book-list.component.css&#x27;</span>,\n  <span class=\"hljs-comment\">// ...</span>\n})\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>Nutzen wir zum Beispiel Visual Studio Code als Editor, können wir die Migration über die globale Suche mithilfe eines regulären Ausdrucks vollziehen:</p>\n<ul>\n<li>Suche: <code>styleUrls: \\[(.*)\\]</code> (Die Option &quot;Regulärer Ausdruck&quot; muss aktiviert sein)</li>\n<li>Ersetzen: <code>styleUrl: $1</code></li>\n</ul>\n<h2 id=\"migrations-schematics-von-ngxtension-verwenden\">Migrations-Schematics von ngxtension verwenden</h2>\n<p>Wir haben in den vorherigen Abschnitten erwähnt, dass das Paket <a href=\"https://ngxtension.netlify.app/\">ngxtension</a> Schematics für die Migration auf einige neuere Angular-Features anbietet. Es handelt sich nicht um ein offizielles Projekt von Angular, sondern stammt aus der Community.</p>\n<p>Um die Migrationen zu verwenden, müssen wir das Paket zunächst im Projekt installieren:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> i -D ngxtension\n</code></pre>\n<p>Anschließend können wir die Migration mithilfe von <code>ng generate</code> anstoßen:</p>\n<pre><code class=\"language-bash\"># von @Input zu Signal Inputs\nng g ngxtension:convert-signal-inputs\n\n# von @Output zu Functional Outputs\nng g ngxtension:convert-outputs\n\n# von <span class=\"hljs-function\"><span class=\"hljs-keyword\">Constructor</span> <span class=\"hljs-title\">Injection</span> <span class=\"hljs-title\">zu</span> <span class=\"hljs-title\">inject</span><span class=\"hljs-params\">()</span>\n<span class=\"hljs-title\">ng</span> <span class=\"hljs-title\">g</span> <span class=\"hljs-title\">ngxtension</span>:</span>convert-di-<span class=\"hljs-keyword\">to</span>-inject\n</code></pre>\n<h2 id=\"demo-und-code\">Demo und Code</h2>\n<p>Damit haben wir den BookMonkey auf die neusten Konzepte und Features von Angular migriert.\nWir freuen uns sehr über die vielen Neuigkeiten in Angular: Standalone Components sorgen für eine einfachere Struktur und weniger verzweigte Referenzen in der Anwendung.\nZusammen mit der Funktion <code>inject()</code> werden asynchrone Validatoren und funktionale Interceptors/Guards stark verkürzt.\nDer entwickelte Code wird schlanker und ist einfacher zu überblicken.\nNicht zuletzt ergeben sich durch Signals neue Patterns und Herangehensweisen.</p>\n<p><strong>Quellcode, Änderungen und Demo:</strong></p>\n<ul>\n<li><a href=\"https://18-modern-angular-bm5.angular-buch.com/\">BookMonkey Demo</a></li>\n<li><a href=\"https://github.com/book-monkey5/17-standalone\">Repo: 17-standalone (Ausgangsbasis)</a></li>\n<li><a href=\"https://github.com/book-monkey5/18-modern-angular\">Repo: 18-modern-angular (Migration)</a></li>\n<li><a href=\"https://book-monkey5.angular-buch.com/diffs/18-modern-angular.html\">Differenzansicht (17-standalone -&gt; 18-modern-angular)</a></li>\n</ul>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Black Diamond, Kopenhagen, Dänemark. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Modern Angular: den BookMonkey migrieren","author":"Danny Koppenhagen und Ferdinand Malcher","mail":"dannyferdigravatar@fmalcher.de","published":"2024-05-05T00:00:00.000Z","lastModified":"2024-05-05T00:00:00.000Z","keywords":["ESBuild","Application Builder","Standalone Components","inject","Functional Interceptor","Control Flow","Signals","Router Input Binding","Functional Outputs","NgOptimizedImage","BookMonkey"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2024-05-modern-angular-bm/header-modernangular.jpg"}}
