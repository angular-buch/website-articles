{"slug":"2022-06-bm4-update","html":"<p>Das Angular-Ökosystem wird kontinuierlich verbessert.\nDas Release einer neuen Major-Version von Angular bedeutet keineswegs, dass alle Ideen verworfen werden und Ihre Software nach einem Update nicht mehr funktioniert.\nDie Grundideen von Angular sind seit Version 2 konsistent und auf Beständigkeit über einen langen Zeitraum ausgelegt.\nDie in unserem Buch beschriebenen Konzepte behalten ihre Gültigkeit.</p>\n<p>Ein paar Änderungen haben sich jedoch seit der Veröffentlichung der 3. Ausgabe unseres Buchs ergeben.\nDiese wollen wir hier detailiert besprechen.\nEs geht vor allem daraum, dass seit <strong>Angular 12</strong> diverse strikte Einstellungen für neue Projekte standardmäßig aktiviert sind.\nAls wir das Buch im Oktober 2020 veröffentlicht haben, war das noch nicht so.\nSind die strikten Einstellungen aktiv, brechen nun leider einige gedruckte Beispiele, die sich aber mit moderatem Aufwand beheben lassen.</p>\n<h2 id=\"der-bookmonkey\">Der BookMonkey</h2>\n<p>Der &quot;BookMonkey&quot; ist das Demo-Projekt zum Buch.\nAnhand des Beispielprojekts führen wir Sie schrittweise an die Entwicklung mit Angular heran.</p>\n<p>Alle Entwicklungsschritte im Buch stellen wir in <a href=\"https://github.com/angular-buch/book-monkey4\">separaten Repositorys</a> zur Verfügung.\nWenn man den Anleitungen im Buch folgt, sieht die eigene Codebasis im Idealfall genauso aus, wie unser Stand auf GitHub.</p>\n<h2 id=\"einen-bestehenden-bookmonkey-updaten\">Einen bestehenden BookMonkey updaten</h2>\n<p>Wenn Sie unser Buch gleich nach der Veröffentlichung gekauft haben und alle Beispiele daraufhin nach Anleitung umgesetzt haben, dann haben Sie keinen großen Aufwand.\nZum Zeitpunkt der Veröffentlichung war Angular 10 die neueste Version, kurz danach folgte Angular 11.\nWurde Ihr BookMonkey in dieser Zeit erstellt, dann sind in ihrem Projekt noch keinen strikten Einstellungen aktiv.</p>\n<p>Sie können die verwendete Angular-Version in der Datei <code>package.json</code> ablesen.\nDer Befehl <code>ng version</code> liefert ebenfalls ausführliche Infos zur Angular-Version im jeweiligen Projekt.</p>\n<p>Um auf den neuesten Stand von Angular zu gelangen, benutzen Sie bitte den Befehl <code>ng update</code> in der Kommandozeile und folgen Sie den Anweisungen auf dem Bildschirm.</p>\n<p>Lesen Sie dazu auch gerne unsere Blogposts mit den neuesten Änderungen zu Angular:</p>\n<ul>\n<li><a href=\"/blog/2020-11-angular11\">Angular 11 ist da!</a></li>\n<li><a href=\"/blog/2021-06-angular12\">Angular 12 ist da!</a></li>\n<li><a href=\"/blog/2021-11-angular13\">Angular 13 ist da!</a></li>\n<li><a href=\"/blog/2022-06-angular14\">Angular 14 ist da!</a></li>\n<li><a href=\"/blog/2022-11-angular15\">Angular 15 ist da!</a></li>\n</ul>\n<h2 id=\"einen-neuen-bookmonkey-erstellen\">Einen neuen BookMonkey erstellen</h2>\n<p>Wenn Sie nach Juni 2021 wie im Buch beschrieben den BookMonkey mit <code>ng new</code> erzeugen, so wird das Projekt standardmäßig mit strikten Einstellungen erstellt.\nDieser <strong>&quot;Strict Mode&quot;</strong> bewirkt eine Reihe an neuen Einstellungen, welche auf der <a href=\"https://angular.io/guide/strict-mode\">offiziellen Website von Angular</a> näher beschrieben sind.\nZum einen sind die <a href=\"https://www.typescriptlang.org/tsconfig#strict\">Einstellungen von TypeScript</a> restriktiver gesetzt.\nZum anderen kommt eine Reihe von Prüfungen im Angular-Compiler hinzu.\nDiese sind in der Doku zu den <a href=\"https://angular.io/guide/angular-compiler-options\">Angular Compiler Options</a> näher beschrieben.</p>\n<h2 id=\"walkthrough-den-bookmonkey-refactoren\">Walkthrough: Den BookMonkey &quot;refactoren&quot;</h2>\n<p>Wir haben unseren &quot;alten&quot; BookMonkey (Stand Angular 10) mithilfe von <code>ng update</code> aktualisiert und anschließend die strikten Einstellungen manuell aktiviert:</p>\n<p><code>tsconfig.json</code></p>\n<pre><code class=\"language-ts\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;strict&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;noImplicitReturns&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;noFallthroughCasesInSwitch&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;angularCompilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;strictInjectionParameters&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;strictInputAccessModifiers&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;strictTemplates&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>Sobald diese Einstellungen gewählt wurden, kompiliert das Projekt nicht mehr!\nDie gleiche Situation ergibt sich, wenn Sie mit einem strikten Projekt beginnen und die Beispiele aus dem Angular-Buch direkt übernehmen.\nIn beiden Fällen müssen wir Alternativen für den gedruckten Code finden.\nIm Folgenden wollen wir nun die problematischen Codestellen kommentieren und mögliche Lösungen aufzeigen.\nDie Reihenfolge dieses Walkthroughs entspricht unseren Iterationen im Buch.\nWenn Sie also den BookMonkey zum ersten Mal implementieren,\ndann halten Sie am Besten diese Anleitung gleich bereit.</p>\n<p>Im Quellcode auf GitHub haben wir die betroffenen Stellen ebenfalls kurz kommentiert.</p>\n<h3 id=\"kapitel-61-strikte-initialisierung-von-propertys\">Kapitel 6.1: Strikte Initialisierung von Propertys</h3>\n<p>Gleich in der ersten Iteration zum Thema Komponenten (Kapitel 6.1) bei der <code>BookListComponent</code> (<code>src/app/book-list/book-list.component.ts</code>) erhalten wir einen der häufigsten Fehler:</p>\n<blockquote>\n<p>Property &#39;books&#39; has no initializer and is not definitely assigned in the constructor.</p>\n</blockquote>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// VORHER: book-list.component.ts</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">BookListComponent</span> <span class=\"hljs-symbol\">implements</span> <span class=\"hljs-symbol\">OnInit</span> {\n  books: Book[];\n\n  ngOnInit(): <span class=\"hljs-built_in\">void</span> {\n    <span class=\"hljs-keyword\">this</span>.books = [<span class=\"hljs-comment\">/* ... */</span>]\n  }\n}\n</code></pre>\n<p>Hier prüft der Type-Checker, dass jede in einer Klasse deklarierte Eigenschaft entweder...</p>\n<p><strong>1.</strong> einen Typ hat, der <code>undefined</code> enthält oder<br><strong>2.</strong> explizit initialisiert wird bzw. im Konstruktor zugewiesen wird.</p>\n<p>Die Lifecycle-Methode <code>ngOnInit()</code> wird hingegen erst nach Konstruktor ausgeführt.\nAus Sicht des TypeScript-Compilers ist <code>ngOnInit()</code> also eine normale Methode der Klasse.\nDie Zuweisung eines Propertys ist hier nur möglich, wenn es bereits definiert wurde.</p>\n<p>Eine mögliche Lösung besteht darin, der Eigenschaft einen Typ zu geben, der <code>undefined</code> enthält.\nDenselben Effekt erhalten wir, wenn wir das Property mit einem Fragezeichen (<code>?</code>) auf optional setzen.</p>\n<pre><code class=\"language-ts\">// <span class=\"hljs-number\">1</span>. mögliche Lösung\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListComponent</span> </span>{\n  books: Book[] | undefined;\n  <span class=\"hljs-regexp\">//</span> ODER\n  books?: Book[];\n}\n</code></pre>\n<p>Allerdings würde dies weitere Änderungen im Template und im Code zur Folge haben, da wir nun den Typ <code>undefined</code> berücksichtigen müssen, sobald wir das Property verwenden.</p>\n<p>Wir könnten ebenso das Array mit allen Werten sofort im Konstruktor initialisieren.\nDadurch müssen wir den bisherigen Typ (Array aus <code>Book</code>) nicht ändern.\nAuf die Methode <code>ngOnInit()</code> können wir dann ganz verzichten:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// 2. mögliche Lösung</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookListComponent</span> {\n  <span class=\"hljs-attr\">books</span>: <span class=\"hljs-title class_\">Book</span>[];\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">books</span> = [<span class=\"hljs-comment\">/* ... */</span>]\n  }\n}\n</code></pre>\n<p>Für unser Refactoring haben wir uns für die letzte Variante entschieden.\nWir haben das Property explizit mit einem leeren Array initialisiert.\nDadurch müssen wir den bestehenden Code kaum anpassen.\nDie konkreten Werte werden weiterhin in der Methode <code>ngOnInit()</code> zugewiesen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: book-list.component.ts</span>\n<span class=\"hljs-comment\">// 3. mögliche Lösung </span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">BookListComponent</span> <span class=\"hljs-symbol\">implements</span> <span class=\"hljs-symbol\">OnInit</span> {\n  books: Book[] = [];\n\n  ngOnInit(): <span class=\"hljs-built_in\">void</span> {\n    <span class=\"hljs-keyword\">this</span>.books = [<span class=\"hljs-comment\">/* ... */</span>]\n  }\n}\n</code></pre>\n<p>Beim Start der Komponente ist <code>books</code> also sofort mit einem leeren Array belegt.\nSobald <code>ngOnInit()</code> ausgeführt wird (das geschieht etwas später), wird dieses leere Array überschrieben.</p>\n<!--\nhttps://mariusschulz.com/blog/strict-property-initialization-in-typescript\nhttps://www.typescriptlang.org/tsconfig#strictPropertyInitialization\n-->\n\n<h3 id=\"kapitel-62-properties-mit-input-decorator\">Kapitel 6.2: Properties mit <code>@Input()</code>-Decorator</h3>\n<p>In der ersten Iteration erläutern wir im Kapitel 6.2 die Verwendung von Property Bindings, um Werte an eine Kindkomponente zu übergeben.\nDazu dekorieren wir das entsprechende Property in der Kindkomponente mit einem <code>@Input()</code>-Decorator:</p>\n<pre><code class=\"language-ts\">// VORHER: book-list-item.component.ts\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListItemComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>{\n  <span class=\"hljs-variable\">@Input</span>() book: Book;\n\n  ngOnInit(): void {\n  }\n}\n</code></pre>\n<p>Erneut erhalten wir hier den Fehler, dass das Property nicht korrekt initialisiert wurde.\nHier wäre es sehr aufwendig und unschön, das Property mit einem Dummy-Ersatzbuch zu initalisieren.</p>\n<p>Die <code>BookListItemComponent</code> wird zusammen mit <code>*ngFor</code> verwendet.\nHier wird immer ein Buch über das Property Binding zur Verfügung gestellt:</p>\n<pre><code class=\"language-html\">&lt;bm-book-list-item\n  *ngFor<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;let b of books&quot;</span>\n  [book]<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;b&quot;</span>&gt;&lt;/bm-book-list-item&gt;\n</code></pre>\n<p>Das Input-Property wird aber erst <strong>zur Laufzeit von Angular</strong> durch das Property Binding zugewiesen.\nDiesen Umstand berücksichtigt die strikte Prüfung <strong>von TypeScript</strong> nicht.\nLaut TypeScript muss bereits zum Zeitpunkt der Initialisierung der Klasse ein Wert bereitstehen. </p>\n<p>Da der Wert des Propertys aber erst zu einem späteren Zeitpunkt gesetzt wird, sollten wir dies auch folgerichtig im Code ausdrücken:</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListItemComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>{\n  <span class=\"hljs-variable\">@Input</span>() book: Book | undefined;\n\n  ngOnInit(): void {\n  }\n}\n</code></pre>\n<p>Statt dieser Schreibweise können wir auch einen äquivalenten Shortcut verwenden und das Property als optional markieren:</p>\n<pre><code class=\"language-ts\">// NACHER: book-list-item.component.ts\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListItemComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>{\n  <span class=\"hljs-variable\">@Input</span>() book?: Book;\n\n  ngOnInit(): void {\n  }\n}\n</code></pre>\n<p>Wenn Sie möchten, können Sie auch gerne die nicht verwendete Methode <code>ngOnInit()</code> entfernen:</p>\n<pre><code class=\"language-ts\">// NACHER: book-list-item.component.ts\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookListItemComponent</span> </span>{\n  <span class=\"hljs-variable\">@Input</span>() book?: Book;\n}\n</code></pre>\n<p>Man kann Property Bindings in Angular leider nicht verpflichtend machen.\nDaher empfehlen wir bei komplexen Input-Propertys grundsätzlich, den Wert <code>undefined</code> zu berücksichtigen.</p>\n<p>Da das Buch nun also <code>undefined</code> sein kann, greift eine weitere Typprüfung:</p>\n<blockquote>\n<p>optional (property) Book.thumbnails?: Thumbnail[] | undefined<br>Object is possibly &#39;undefined&#39;.\nbook-list-item.component.ts: Error occurs in the template of component BookListItemComponent.</p>\n</blockquote>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- VORHER: book-list-item.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;ui tiny image&quot;</span>\n     *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book.thumbnails &amp;&amp; book.thumbnails[0] &amp;&amp; book.thumbnails[0].url&quot;</span>\n     [<span class=\"hljs-attr\">src</span>]=<span class=\"hljs-string\">&quot;book.thumbnails[0].url&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;header&quot;</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book.subtitle&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;description&quot;</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.subtitle</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;metadata&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let author of book.authors; last as l&quot;</span>&gt;</span>\n      </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">author</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;!l&quot;</span>&gt;</span>, <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n    ISBN </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.isbn</span> }}</span><span class=\"language-xml\">\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>Die Prüfung bemängelt zu Recht, dass das Property <code>book</code> den Wert <code>undefined</code> haben kann und dann auch der Zugriff auf <code>book.thumbnails</code> oder <code>book.isbn</code> fehlschlagen könnte.\nWürden wir dies dennoch tun, dann käme es zur Laufzeit zu folgender Fehlermeldung: <code>TypeError: Cannot read property of undefined</code>.\nDies ist einer der häufigsten Typfehler in JavaScript.\nEr tritt immer dann auf, wenn auf einer undefinierten Variable eine Eigenschaft gelesen oder eine Funktion aufgerufen wird.\nEs ist gut, dass uns die strenge Typprüfung schon zur Kompilierzeit vor diesem Problem bewahrt.</p>\n<p>Wir haben das Markup wie folgt verbessert:\nDas gesamte Template wird mit mit einem <code>&lt;ng-container&gt;</code> und <code>*ngIf</code> nur dann eingeblendet, wenn ein Buch vorhanden ist:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- NACHER: book-list-item.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book&quot;</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Vorheriger Code --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;ui tiny image&quot;</span> <span class=\"hljs-attr\">...</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;content&quot;</span> <span class=\"hljs-attr\">...</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span>\n</code></pre>\n<p>Der <code>&lt;ng-container&gt;</code> ist ein Hilfselement, das nicht als DOM-Element gerendert wird.\nEr sorgt nur für eine logische Gruppierung.\nInnerhalb des Containers ist <code>book</code> durch die Verwendung von <code>*ngIf</code> immer definiert.</p>\n<h3 id=\"kapitel-63-weitere-property-prüfungen\">Kapitel 6.3: Weitere Property-Prüfungen</h3>\n<p>Im Kapitel zu den Event Bindings übergeben wir ein Buch von der Kindkomponente <code>BookListComponent</code> zur Elternkomponente <code>AppComponent</code> und zeigen damit eine Detailansicht an.\nDas Buch speichern wir im Property <code>book</code>.\nDieses Property sollten wir ebenso mit dem Fragezeichen als optional kennzeichnen, denn es ist nicht immer mit einem Wert belegt:</p>\n<pre><code class=\"language-ts\">// VORHER: app.component.ts \nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> </span>{\n  book: Book;\n}\n</code></pre>\n<pre><code class=\"language-ts\">// NACHHER: app.component.ts \nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> </span>{\n  book?: Book;\n}\n</code></pre>\n<p>Das Template der <code>AppComponent</code> muss in diesem Fall nicht angepasst werden.</p>\n<p>Die Anzeige des Buchs geschieht in der <code>BookDetailsComponent</code>.\nErneut müssen wir den Code aufgrund der strikten Prüfungen anpassen:</p>\n<pre><code class=\"language-ts\">// VORHER: book-details.component.ts \nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookDetailsComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>{\n  <span class=\"hljs-variable\">@Input</span>() book: Book;\n}\n</code></pre>\n<pre><code class=\"language-ts\">// NACHHER: book-details.component.ts \nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookDetailsComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>{\n  <span class=\"hljs-variable\">@Input</span>() book?: Book;\n}\n</code></pre>\n<p>Die <code>BookDetailsComponent</code> hat eine Methode <code>getRating()</code>, welche nur eine Zahl akzeptiert.\nDiese Methode wird im Template verwendet:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- VORHER: book-details.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;four wide column&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>Rating<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;yellow star icon&quot;</span>\n    *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let r of getRating(book.rating)&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Damit der Code wieder kompiliert, müssen wir sicherstellen, dass es keinen Fall geben kann, bei dem das Rating <code>undefined</code> ist. \nNun kann sowohl das Buch an sich <code>undefined</code> sein, als auch dessen Property <code>rating</code>.\nDies ergibt sich auch dem Interface <code>Book</code>, wo das Rating als optional markiert ist:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Book</span> {\n  <span class=\"hljs-comment\">// [...]</span>\n  rating?: <span class=\"hljs-built_in\">number</span>;\n}\n</code></pre>\n<p>Auch hier haben wir wieder das umschließende <code>&lt;div&gt;</code> für eine Prüfung verwendet.\nDas Div-Element und sein Inhalt werden nur angezeigt, wenn <code>book.rating</code> definiert ist:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!--  NACHHER: book-details.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;four wide column&quot;</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book.rating&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>Rating<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;yellow star icon&quot;</span>\n    *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let r of getRating(book.rating)&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<h3 id=\"kapitel-82-werte-vom-router\">Kapitel 8.2: Werte vom Router</h3>\n<p>Im Kapitel 8.2 stellen wir die Anwendung auf Routing um und ändern in diesem Zuge die <code>BookDetailsComponent</code>.\nStatt eines Input-Propertys verwenden wir nun die ISBN, die wir aus der aktuellen Route ermitteln.\nDiese ISBN verwenden wir, um das richtige Buch vom <code>BookStoreService</code> zu erhalten.</p>\n<p>Im gedruckten Buch finden Sie den folgenden Code:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// VORHER: book-details.component.ts </span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> {\n  book: Book;\n\n  <span class=\"hljs-keyword\">constructor</span>(\n    <span class=\"hljs-keyword\">private</span> bs: BookStoreService,\n    <span class=\"hljs-keyword\">private</span> route: ActivatedRoute\n  ) { }\n\n  ngOnInit(): void {\n    <span class=\"hljs-keyword\">const</span> params = <span class=\"hljs-keyword\">this</span>.route.snapshot.paramMap;\n    <span class=\"hljs-keyword\">this</span>.book = <span class=\"hljs-keyword\">this</span>.bs.getSingle(params.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">&#x27;isbn&#x27;</span>));\n  }\n}\n</code></pre>\n<p>Das Property <code>book</code> müssen wir mittels des Fragezeichens wieder als optional markieren.\nEine neue Herausforderung bietet dann allerdings folgende Fehlermeldung:</p>\n<blockquote>\n<p>const params: ParamMap<br>Argument of type &#39;string | null&#39; is not assignable to parameter of type &#39;string&#39;.<br>Type &#39;null&#39; is not assignable to type &#39;string&#39;.</p>\n</blockquote>\n<p>Die Methode <code>ParamMap.get()</code> liefert entweder einen String zurück (wenn der Parameter verfügbar ist) oder <code>null</code> (wenn der Parameter nicht in der Map vorhanden ist).\nErst zur Laufzeit der Anwendung kann sicher ermittelt werden, ob ein bestimmter Routen-Parameter verfügbar ist.\nUm diesem Umstand gerecht zu werden, liefert <code>get()</code> einen Union-Type von <code>string | null</code> zurück.  </p>\n<p>Die Methode <code>getSingle()</code> erwartet allerdings nur <code>string</code>.\nVor den strikten Prüfungen von TypeScript war der gedruckte Code mit der Diskrepanz zwischen den beiden Typen valide, jetzt ist dies nicht mehr der Fall.</p>\n<p>Wir können deshalb einen leeren String als Fallback-Wert definieren.\nAuf diese Weise wird immer ein String übergeben:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: book-details.component.ts </span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> {\n  book?: Book;\n\n  <span class=\"hljs-keyword\">constructor</span>(\n    <span class=\"hljs-keyword\">private</span> bs: BookStoreService,\n    <span class=\"hljs-keyword\">private</span> route: ActivatedRoute\n  ) { }\n\n  ngOnInit(): void {\n    <span class=\"hljs-keyword\">const</span> params = <span class=\"hljs-keyword\">this</span>.route.snapshot.paramMap;\n    <span class=\"hljs-comment\">// verwendet den String ODER den leeren String falls der Ausdruck falsy ist</span>\n    <span class=\"hljs-keyword\">this</span>.book = <span class=\"hljs-keyword\">this</span>.bs.getSingle(params.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">&#x27;isbn&#x27;</span>) || <span class=\"hljs-string\">&#x27;&#x27;</span>);\n  }\n}\n</code></pre>\n<p>Das Template der <code>BookDetailsComponent</code> müssen wir in diesem Fall nicht anpassen.\nBereits in der gedruckten Fassung haben wir den gesamten Block mit einem <code>&lt;div *ngIf=&quot;book&quot;&gt;</code> geschützt.</p>\n<p>Es wird natürlich nie geschehen, dass wir die Route ohne eine ISBN erreichen.\nHätten wir das Routing anders konfiguriert (sodass keine ISBN notwendig ist),\ndann würden wir in diesem Fall einen leeren String an die Methode übergeben.</p>\n<p>Eine weitere Möglichkeit besteht darin, die Typprüfung mit dem <strong>&quot;Non-Null Assertion Operator&quot;</strong> anzupassen.\nMit einem Ausrufezeichen (<code>!</code>) teilen wir dem Compiler mit, dass der Wert niemals <code>null</code> sein wird.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// alternative Möglichkeit</span>\n<span class=\"hljs-keyword\">this</span>.book = <span class=\"hljs-keyword\">this</span>.bs.getSingle(params.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">&#x27;isbn&#x27;</span>)!);\n</code></pre>\n<p>Wir müssen uns dann aber auch wirklich sicher sein, dass dieser Fall wirklich niemals auftreten wird.\nVerwenden Sie die Non-Null Assertion daher bitte mit Vorsicht!</p>\n<p>Auch der <code>BookStoreService</code> benötigt eine kleine Korrektur.\nZuvor hatten wir den Rückgabewert für die Methode <code>getSingle()</code> als <code>Book</code> angegeben:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: book-store.service.ts</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStoreService</span> {\n\n  getSingle(isbn: string): Book {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.books.find(book =&gt; book.isbn === isbn);\n  }\n}\n</code></pre>\n<p>Das war nicht ganz korrekt, denn wenn es bei der Suche mit <code>find()</code> keinen Treffer gibt, dann ist der Rückgabewert <code>undefined</code>.\nDiese Nachlässigkeit unsererseits führt jetzt zu einem Fehler, daher lautet die korrekte Signatur wie folgt:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: book-store.service.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStoreService</span> {\n\n  <span class=\"hljs-title function_\">getSingle</span>(<span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-built_in\">string</span>): <span class=\"hljs-title class_\">Book</span> | <span class=\"hljs-literal\">undefined</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">books</span>.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">book</span> =&gt;</span> book.<span class=\"hljs-property\">isbn</span> === isbn);\n  }\n}\n</code></pre>\n<h3 id=\"kapitel-101-eine-weitere-property-prüfung\">Kapitel 10.1: Eine weitere Property-Prüfung</h3>\n<p>Im Kapitel zum Thema HTTP tauschen wir vor allem die Datenquelle vom <code>BookStoreService</code> aus.\nErfreulicherweise behalten alle gezeigten Codebeispiele in diesem Kapitel ihre Gültigkeit – bis auf eine kleine Ausnahme.</p>\n<p>Die <code>BookDetailsComponent</code> hat nun eine Methode <code>removeBook()</code>, welche in der gedruckten Fassung wie folgt aussieht:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// VORHER: book-details.component.ts </span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> {\n  book: Book;\n\n  removeBook() {\n    <span class=\"hljs-keyword\">if</span> (confirm(<span class=\"hljs-string\">&#x27;Buch wirklich löschen?&#x27;</span>)) {\n      <span class=\"hljs-keyword\">this</span>.bs.remove(<span class=\"hljs-keyword\">this</span>.book.isbn)\n        .subscribe(res =&gt; <span class=\"hljs-keyword\">this</span>.router.navigate([<span class=\"hljs-string\">&#x27;../&#x27;</span>], { relativeTo: <span class=\"hljs-keyword\">this</span>.route }));\n    }\n  }\n}\n</code></pre>\n<p>Allerdings mussten wir bereits zuvor das Property <code>book</code> mit einem Fragezeichen als optional kennzeichnen.\nNun besteht die Gefahr, dass beim Zugriff auf die ISBN per <code>this.book.isbn</code> der Wert für das Buch <code>undefined</code> ist.\nDiesen Fall müssen wir ausschließen, damit TypeScript keine Beanstandungen mehr hat.\nWir haben uns dazu entschieden, gleich in der Fallunterscheidung zu prüfen, ob <code>this.book</code> einen <em>truthy</em> Wert hat:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: book-details.component.ts </span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetailsComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> {\n  book?: Book;\n\n  removeBook() {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.book &amp;&amp; confirm(<span class=\"hljs-string\">&#x27;Buch wirklich löschen?&#x27;</span>)) {\n      <span class=\"hljs-keyword\">this</span>.bs.remove(<span class=\"hljs-keyword\">this</span>.book.isbn)\n        .subscribe(res =&gt; <span class=\"hljs-keyword\">this</span>.router.navigate([<span class=\"hljs-string\">&#x27;../&#x27;</span>], { relativeTo: <span class=\"hljs-keyword\">this</span>.route }));\n    }\n  }\n}\n</code></pre>\n<h3 id=\"kapitel-102-typprüfung-bei-events\">Kapitel 10.2: Typprüfung bei Events</h3>\n<p>Im Kapitel 10.2 gehen wir auf die Bibliothek RxJS genauer ein und erstellen die <code>SearchComponent</code>.\nFür die Suche haben wir folgendes Markup verwendet:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- VORHER: search.component.html --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;prompt&quot;</span>\n  (<span class=\"hljs-attr\">keyup</span>)=<span class=\"hljs-string\">&quot;keyUp$.next($event.target.value)&quot;</span>&gt;</span>\n</code></pre>\n<p>Bei jedem Tastendruck wird zunächst der Wert des Events ausgewertet und an das Subject mit der Methode <code>next()</code> übergeben.\nLeider ist aber das Property <code>target</code> aber vom Typ <code>EventTarget | null</code>.\nDer Zugriff auf <code>value</code> könnte demnach fehlschlagen.\nTypeScript bemängelt dies entsprechend:</p>\n<blockquote>\n<p>Object is possibly &#39;null&#39;.<br>Property &#39;value&#39; does not exist on type &#39;EventTarget&#39;.</p>\n</blockquote>\n<p>Um das Problem zu umgehen, greifen wir daher nun mithilfe der Elementreferenz <code>#input</code> auf den Formularwert zu.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- NACHHER: search.component.html --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;prompt&quot;</span> #<span class=\"hljs-attr\">input</span>\n  (<span class=\"hljs-attr\">keyup</span>)=<span class=\"hljs-string\">&quot;keyUp$.next(input.value)&quot;</span>&gt;</span>\n</code></pre>\n<p>Die Referenzvariable <code>input</code> ist vom Typ <code>HTMLInputElement</code>, und da diese immer vorhanden ist, können wir nun ohne Einschränkungen auf <code>value</code> zugreifen.</p>\n<h3 id=\"kapitel-122-template-driven-forms\">Kapitel 12.2: Template-Driven Forms</h3>\n<p>Im Kapitel zu den Template-Driven Forms zeigen wir, wie man ein Formular zum Erstellen von Büchern realisiert.\nHierzu führen wir die Komponente <code>CreateBookComponent</code> und deren Kindkomponente <code>BookFormComponent</code> ein.\nZur Anzeige von Fehlermeldungen verwenden wir die <code>FormMessagesComponent</code>.</p>\n<p>Zunächst möchten wir uns für einen Fehler im gedruckten Buch entschuldigen:\nWir zeigen im Template der <code>BookFormComponent</code>, wie man über Referenzvariablen auf Formular-Controls zugreifen kann.\nDiese Stelle ist aber schon seit jeher fehlerhaft gewesen:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- VORHER (fehlerhaft!): book-form.component.html --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;title&quot;</span>\n  [(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;book.title&quot;</span>\n  <span class=\"hljs-attr\">required</span>\n  #<span class=\"hljs-attr\">titleInput</span>=<span class=\"hljs-string\">&quot;ngModel&quot;</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bm-form-messages</span>\n  [<span class=\"hljs-attr\">control</span>]=<span class=\"hljs-string\">&quot;titleInput&quot;</span>\n  <span class=\"hljs-attr\">controlName</span>=<span class=\"hljs-string\">&quot;title&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bm-form-messages</span>&gt;</span>\n</code></pre>\n<p>Die Referenz <code>titleInput</code> zeigt auf die Direktive <code>ngModel</code> – nicht auf ein Control!\nDen benötigten Zugriff auf das Control erhalten wir stattdessen über das Property <code>control</code> auf <code>ngModel</code>. </p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- NACHHER: book-form.component.html --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;title&quot;</span>\n  [(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;book.title&quot;</span>\n  <span class=\"hljs-attr\">required</span>\n  #<span class=\"hljs-attr\">titleInput</span>=<span class=\"hljs-string\">&quot;ngModel&quot;</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bm-form-messages</span>\n  [<span class=\"hljs-attr\">control</span>]=<span class=\"hljs-string\">&quot;titleInput.control&quot;</span>\n  <span class=\"hljs-attr\">controlName</span>=<span class=\"hljs-string\">&quot;title&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bm-form-messages</span>&gt;</span>\n</code></pre>\n<p>Diese Änderung gilt auch für alle anderen Stellen in diesem Template.\nDas bedeutet, diese Korrektur muss auch für <code>isbnInput</code>, <code>dateInput</code> sowie <code>authorInput</code> durchgeführt werden.</p>\n<p>Ein paar Zeilen später verwenden wir im Template der <code>FormMessagesComponent</code> einen recht komplexen Ausdruck für das Two-Way Binding:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- VORHER: book-form.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;url&quot;</span>\n  [(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;book.thumbnails[0].url&quot;</span>\n  <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;URL&quot;</span>&gt;</span>\n</code></pre>\n<p>Laut dem Interface <code>Book</code> ist das Property <code>thumbnails</code> optional.\nDas führt durch die strengeren Prüfungen natürlich nun zu einer Fehlermeldung:</p>\n<blockquote>\n<p>optional (property) Book.thumbnails?: Thumbnail[] | undefined<br>Object is possibly &#39;undefined&#39;.</p>\n</blockquote>\n<p>Unter den heutigen Umständen hätten wir wohl einfach das Property nicht als optional deklariert.\nDa wir aber diese zentrale Stelle im Zuge des Refactorings nicht abändern wollen,\nhaben wir uns an dieser Stelle für den &quot;letzten Ausweg&quot; entschieden.\nMit <code>$any()</code> haben wir hier die Typprüfung deaktiviert!\nDas ist ausdrücklich ein Workaround!</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- NACHHER: book-form.component.html --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;url&quot;</span>\n  [(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;$any(book).thumbnails[0].url&quot;</span>\n  <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;URL&quot;</span>&gt;</span>\n</code></pre>\n<p>Auch der TypeScript-Teil der <code>BookFormComponent</code> benötigt eine Anpassung.\nUm das Formular resetten zu können, benötigen wir eine Referenz auf die Instanz von <code>NgForm</code>.\nDiese erhalten wir über den den Decorator <code>@ViewChild()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// VORHER: book-form.component.ts</span>\n<span class=\"hljs-variable\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;bookForm&#x27;</span>, { <span class=\"hljs-attribute\">static</span>: true }) <span class=\"hljs-attribute\">bookForm</span>: NgForm;\n</code></pre>\n<p>Da das Property nicht sofort zugewiesen werden kann, müssen wir dieses ebenfalls mit dem Fragezeichen (<code>?</code>) auf optional setzen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: book-form.component.ts</span>\n<span class=\"hljs-meta\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;bookForm&#x27;</span>, { <span class=\"hljs-keyword\">static</span>: <span class=\"hljs-keyword\">true</span> }) bookForm?: NgForm;\n</code></pre>\n<p>Uns ist in diesem Zuge aufgefallen, dass der Name <code>bookForm</code> mit der Elementreferenz <code>#bookForm</code> im Template kollidiert.\nWir haben daher das Property daher auch gleich noch sauber zu <code>form</code> umbenannt:</p>\n<pre><code class=\"language-ts\">// NACHHER, mit Umbennenung: book-form.component.ts\n@<span class=\"hljs-built_in\">ViewChild</span>(<span class=\"hljs-string\">&#x27;bookForm&#x27;</span>, { static: true }) <span class=\"hljs-selector-tag\">form</span>?: NgForm;\n</code></pre>\n<p>Folgerichtig müssen wir nun beim Resetten zuvor eine Existenzprüfung durchführen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// VORHER: book-form.component.ts</span>\n<span class=\"hljs-title function_\">submitForm</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// [...]</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookForm</span>.<span class=\"hljs-title function_\">reset</span>();\n}\n</code></pre>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: book-form.component.ts</span>\n<span class=\"hljs-title function_\">submitForm</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// [...]</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">form</span>?.<span class=\"hljs-title function_\">reset</span>();\n}\n</code></pre>\n<p>Weitere Property-Prüfungen müssen wir dann noch in der <code>FormMessagesComponent</code> berücksichtigen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// VORHER: form-messages.component.ts</span>\n  <span class=\"hljs-variable\">@Input</span>() <span class=\"hljs-attribute\">control</span>: AbstractControl;\n  <span class=\"hljs-variable\">@Input</span>() <span class=\"hljs-attribute\">controlName</span>: string;\n</code></pre>\n<p>Auch hier markieren wir die Propertys als optional, sonst müssten sie direkt zugewiesen werden.\nDer Typ von <code>control</code> muss auf <code>AbstractControl | null</code> korrigiert werden, denn das ist der tatsächliche Rückgabetyp von <code>FormGroup.get()</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: form-messages.component.ts</span>\n  <span class=\"hljs-meta\">@Input()</span> control?: AbstractControl | <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-meta\">@Input()</span> controlName?: string;\n</code></pre>\n<p>Das Property mit den fest eingebauten Fehlermeldungen des Formulars war bislang nur implizit typisiert: </p>\n<pre><code class=\"language-ts\">// VORHER: form-messages.component.ts\nprivate allMessages = {\n  title: {\n    required: <span class=\"hljs-string\">&#x27;Ein Buchtitel muss angegeben werden.&#x27;</span>\n  },\n  // <span class=\"hljs-selector-attr\">[...]</span>\n}\n</code></pre>\n<p>Damit wir das Objekt weiterhin in der Methode <code>errorsForControl()</code> verwenden können, müssen wir den Typ konkretisieren:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: form-messages.component.ts</span>\nprivate allMessages: { [<span class=\"hljs-built_in\">key</span>: <span class=\"hljs-keyword\">string</span>]: { [<span class=\"hljs-built_in\">key</span>: <span class=\"hljs-keyword\">string</span>]: <span class=\"hljs-keyword\">string</span> } } = {\n  <span class=\"hljs-built_in\">title</span>: {\n    required: &#x27;Ein Buchtitel muss angegeben werden.&#x27;\n  },\n  <span class=\"hljs-comment\">// [...]</span>\n}\n</code></pre>\n<p>Die verbesserte und korrekte Typisierung dieser Methode sieht dann wie folgt aus:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// VORHER: form-messages.component.ts</span>\nerrorsForControl(): string[] {\n  <span class=\"hljs-keyword\">const</span> messages = <span class=\"hljs-keyword\">this</span>.allMessages[<span class=\"hljs-keyword\">this</span>.controlName];\n  <span class=\"hljs-comment\">// [...]</span>\n}\n</code></pre>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// NACHHER: form-messages.component.ts</span>\nerrorsForControl(): string[] {\n  type allMessagesKey = keyof FormMessagesComponent[<span class=\"hljs-string\">&#x27;allMessages&#x27;</span>];\n  <span class=\"hljs-keyword\">const</span> messages = <span class=\"hljs-keyword\">this</span>.allMessages[<span class=\"hljs-keyword\">this</span>.controlName <span class=\"hljs-keyword\">as</span> keyof allMessagesKey];\n  <span class=\"hljs-comment\">// [...]</span>\n}\n</code></pre>\n<!--\n### Kapitel 12.3: Reactive Forms\n\nWer das Buch gelesen hat, der weiß es bereits:\nNachdem wir das Formular mit dem Template-Driven-Ansatz implementiert haben,\nstellen wir im nächsten Kapitel schon alles wieder auf den alternativen Ansatz der Reactive Forms um.\n\n-->\n\n<h2 id=\"es-geht-weiter-\">Es geht weiter …</h2>\n<p>Wir ergänzen diesen Blogartikel von Zeit zu Zeit.\nAlle notwendigen Änderungen haben wir auf GitHub direkt im Code kommentiert.</p>\n<p>Wenn Sie Fehler finden oder diesen Blogpost ergänzen möchten, freuen wir uns über eine E-Mail oder einen <a href=\"https://github.com/angular-buch/website-articles/tree/gh-pages/blog/2022-06-bm4-update\">Pull Request auf GitHub</a>!</p>\n<h2 id=\"alle-änderungen\">Alle Änderungen</h2>\n<p>Hier sehen Sie noch einmal alle notwendigen Änderungen am Code als Differenzanzeige.</p>\n<!-- * **[Alle Änderungen vom großen BookMonkey 4<br>von Angular 10 auf Angular 12](https://github.com/angular-buch/book-monkey4/commit/1c9fca396de63605494b1859f4492ef7bdf5b222)** -->\n\n<ul>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-1-components/commit/4c32571ef9ce2d2f746ec0c3939a0fa48ac5540b\">Iteration 1: Komponenten (Kapitel 6.1)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-1-property-bindings/commit/02b1a286f03808f0094f0c85ea4825b4824a7c3b\">Iteration 1: Property-Bindings (Kapitel 6.2)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-1-event-bindings/commit/8cf96312ae178d628df782583a36dd34f7f4b666\">Iteration 1: Event-Bindings (Kapitel 6.3)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-2-di/commit/f2db935c2df1a1af3eabf88f4fa223d9ce5bec81\">Iteration 2: Dependency Injection (Kapitel 8.1)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-2-routing/commit/11fabf50b5b46501305a8d6c929d8f4f8a4e0228\">Iteration 2: Routing (Kapitel 8.2)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-3-http/commit/b4a106a1778d94626a5cadb295fd31b18ac79f23\">Iteration 3: HTTP (Kapitel 10.1)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-3-rxjs/commit/f304d932c095982a64de0e4649769e59c25f8569\">Iteration 3: RxJS (Kapitel 10.2)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-3-interceptors/commit/0d6c18002e4af0cc93ee493854b8caec5115d9a2\">Iteration 3: Interceptoren (Kapitel 10.3)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-4-template-driven-forms/compare/e096ade..33fe9db\">Iteration 4: Template-Driven Forms (Kapitel 12.2)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-4-reactive-forms/commit/550f61684483710bb110d86b95768dc1d38313e0\">Iteration 4: Reactive Forms (Kapitel 12.3)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-4-custom-validation/compare/228bd47..b41530e\">Iteration 4: Eigene Validatoren (Kapitel 12.4)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-5-pipes/compare/e00ade1..829abfe\">Iteration 5: Pipes (Kapitel 13.1)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-5-directives/compare/66801ed..fe97efd\">Iteration 5: Direktiven (Kapitel 13.2)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-6-modules/compare/2edd6e7..9d65223\">Iteration 6: Module (Kapitel 14.1)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-6-lazy-loading/compare/d0bc5ef..e699f26\">Iteration 6: Lazy Loading (Kapitel 14.2)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-6-guards/compare/1fba833..d7e2a70\">Iteration 6: Guards (Kapitel 14.3)</a></strong></li>\n<li><strong><a href=\"https://github.com/book-monkey4/iteration-7-i18n/commit/8c3ecd42e67cd0c38eab155f910ba83717bfeb96\">Iteration 7: Internationalisierung (Kapitel 15.1)</a></strong></li>\n</ul>\n<p>Wir wünschen Ihnen viel Spaß mit Angular!\nHaben Sie Fragen zur neuen Version, zum Update oder zu Angular? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß wünschen<br>Danny, Ferdinand und Johannes</strong></p>\n<p><small><strong>Titelbild:</strong> Photo by <a href=\"https://unsplash.com/@fotograw\">Dmitriy Demidov</a> on <a href=\"https://unsplash.com/s/photos/wrench\">Unsplash</a>\n  </small></p>\n","meta":{"title":"Den Book-Monkey v4 updaten (3. Ausgabe)","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2022-06-30T00:00:00.000Z","keywords":["Angular","Angular 12","Angular 13","Angular 14","Strict Mode"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2022-06-bm4-update/bm4update.jpg"}}
