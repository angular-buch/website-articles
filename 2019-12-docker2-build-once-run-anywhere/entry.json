{"slug":"2019-12-docker2-build-once-run-anywhere","html":"<p><strong>Build Once, Run Anywhere:\nWie Sie ein einziges Image zur Laufzeit an beliebige Umgebungen anpassen.\nBleiben Sie auch ohne Code-Änderung flexibel!\nDies ist der 3. Teil unserer vierteiligen Artikelserie zu Angular und Docker.</strong></p>\n<p>Inhaltsverzeichnis:</p>\n<ul>\n<li><a href=\"/blog/2019-12-docker2-build-once-run-anywhere#motivation\">Motivation</a></li>\n<li><a href=\"/blog/2019-12-docker2-build-once-run-anywhere#anforderungen-an-die-konfigurierbarkeit\">Anforderungen an die Konfigurierbarkeit</a></li>\n<li><a href=\"/blog/2019-12-docker2-build-once-run-anywhere#konfigurierbarkeit-umsetzen\">Konfigurierbarkeit umsetzen</a></li>\n<li><a href=\"/blog/2019-12-docker2-build-once-run-anywhere#umgebung-mit-docker-konfigurieren\">Umgebung mit Docker konfigurieren</a></li>\n<li><a href=\"/blog/2019-12-docker2-build-once-run-anywhere#ausblick\">Ausblick</a></li>\n</ul>\n<p>Sie finden den Code zum Artikel auf\n<a href=\"https://github.com/MichaelKaaden/dockerized-app/tree/master/Part-2-Build-Once-Run-Anywhere\">GitHub</a>.</p>\n<p>In Teil I dieser Artikelserie haben Sie gelernt, wie Sie Ihre Angular-App in ein Docker-Image packen und in einem Container zur Ausführung bringen können.</p>\n<h2 id=\"motivation\">Motivation</h2>\n<p>Die meisten Angular-Apps werden Daten abfragen und/oder persistieren.\nSie benötigen also ein Backend, meist in Gestalt eines RESTful Web Service.\nDie App spricht das Backend über einen URL an, der irgendwo in der App abgelegt sein muss.\nDas Angular-Team <a href=\"https://angular.io/guide/build\">stellt sich vor</a>, dass Sie diesen URL in <code>src/environments/environment.ts</code> bzw. <code>src/environments/environment.prod.ts</code> ablegen, beispielsweise unter dem Namen\n<code>baseUrl</code>.</p>\n<p>Das klappt gut, solange Sie mit diesen beiden Umgebungen auskommen.\nGerade wenn Sie in einem Team entwickeln, werden Sie jedoch mindestens vier Umgebungen verwenden:</p>\n<ul>\n<li><em>Development</em> zum Entwickeln,</li>\n<li><em>Testing</em> für Integrations- und Systemtests sowie manuelle Tests,</li>\n<li><em>Staging</em> für die Produktabnahme und schließlich</li>\n<li><em>Production</em> für den Produktivbetrieb.</li>\n</ul>\n<p>Jede dieser Umgebungen hat typischerweise ihr eigenes Backend und benötigt somit einen spezifischen <code>baseUrl</code>.\nIn der Realität werden Sie noch mehr zu konfigurieren haben, etwa einen Identity Provider für die Autorisierung.\nWeitere Konfigurationsoptionen fügen allerdings diesem Artikel keinen Mehrwert hinzu, weshalb ich mich auf den <code>baseUrl</code> beschränke.</p>\n<p>Sie sehen schon: Mit nur <code>environment.ts</code> und <code>environment.prod.ts</code> kommen wir da nicht ganz hin. Natürlich könnten wir noch ein <code>environment.testing.ts</code> und ein <code>environment.staging.ts</code> definieren, doch das hilft uns nicht weiter, wie wir gleich sehen werden.</p>\n<h2 id=\"anforderungen-an-die-konfigurierbarkeit\">Anforderungen an die Konfigurierbarkeit</h2>\n<p>In der <em>Development</em>-Umgebung soll die App ganz normal mit <code>ng serve</code> bzw. <code>ng serve --prod</code> laufen können.\nWir brauchen also eine Lösung, die den <code>baseUrl</code> auch ohne Docker zur Verfügung stellt.</p>\n<p>In den anderen Umgebungen möchten wir den jeweils passenden <code>baseUrl</code> nutzen.\nEine wesentliche Einschränkung dabei ist: Wir dürfen nicht damit anfangen, nur wegen eines jeweils anderen <code>baseUrl</code> ein Image je Umgebung zu erstellen.</p>\n<p>Wenn ein Image in <em>Testing</em> für gut befunden wurde, egal ob durch automatische oder manuelle Tests, dann ist genau dieses Image dasjenige, das nach <em>Staging</em> und nach erfolgreicher Abnahme nach <em>Production</em> wandern soll. Wir dürfen <em>kein</em> neues Image erstellen, denn das könnte geringfügig anders sein als das getestete, beispielsweise weil in der Zwischenzeit Ihre geschätzten Admin-Kollegen automatisiert eine neue Version von Node.js auf Ihrem Rechner eingespielt haben. Vielleicht haben Sie auch Ihre globalen NPM-Pakete aktualisiert.\nOder ein Kollege hat stillschweigend einen Fix in die Sourcen eingebaut.</p>\n<p>Wenn aber das Image aus <em>Testing</em> auch für <em>Staging</em> und <em>Production</em> verwendet werden soll, heißt das, dass der <code>baseUrl</code> nicht Teil des Images sein darf, sondern von außen über Docker konfigurierbar sein muss.</p>\n<p>Zusammengefasst benötigen wir also eine Lösung, die uns in der <em>Development</em>-Umgebung einen <code>baseUrl</code> auch ohne Docker zur Verfügung stellt, die uns aber einen Weg ebnet, den <code>baseUrl</code> für die anderen Umgebungen mit\nDocker zu konfigurieren.</p>\n<h2 id=\"konfigurierbarkeit-umsetzen\">Konfigurierbarkeit umsetzen</h2>\n<p>Um diese Anforderungen umsetzen zu können, benötigen wir einen Mechanismus, der die Konfiguration der App erst zur Laufzeit lädt. Würden wir das <code>environment.ts</code> für diesen Zweck nutzen, dann müsste die Konfiguration schon\nbeim <em>Build</em> feststehen, was aber nicht sein darf, wie wir im vorangehenden Abschnitt festgestellt haben.</p>\n<p>Eine gute Lösung ist, die Konfiguration in eine Datei zu packen, die wir im <code>assets</code>-Verzeichnis ablegen und von dort zusammen mit der App laden.\nAuf diese Weise können wir diese Konfigurationsdatei beim Start des Containers beliebig überschreiben.\nWir ändern die Konfiguration dadurch zur <em>Laufzeit</em> – wir sehen gleich, wie wir das bewerkstelligen.</p>\n<p>Nachfolgende sehen Sie die Datei <code>src/assets/settings.json</code>, die wir zu diesem Zweck verwenden\nwerden.</p>\n<pre><code class=\"language-json\"><span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;baseUrl&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;http://localhost:5002&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>Anschließend definieren Sie mittels <code>ng g class models/settings --skip-tests</code> in der Datei\n<code>settings.ts</code> ein Interface, das die Struktur dieser Konfigurationsdatei vorgibt:</p>\n<pre><code class=\"language-typescript\">export <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">Settings</span> {\n    baseUrl: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<p>Jetzt benötigen wir noch einen Service, den wir überall dort injizieren können, wo wir Zugriff auf die Konfiguration benötigen.\nWir erstellen diesen <code>SettingsService</code> mit der Angular CLI: <code>ng g service services/settings</code>.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Injectable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { Settings } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../models/settings&quot;</span>;\n\n@Injectable({\n    providedIn: <span class=\"hljs-string\">&quot;root&quot;</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SettingsService</span> {\n    settings: Settings;\n}\n</code></pre>\n<p>Außerdem wollen wir einen Service definieren, der für das Laden unserer <code>settings.json</code> verantwortlich ist.\nDer Service soll später direkt von Angular genutzt werden, daher legen wir diese Mechanik nicht im <code>SettingsService</code> ab.\nDer neue Service wird generiert mit dem Befehl <code>ng g service services/settings-initializer</code>.\nEr soll eine Methode <code>initializeSettings()</code> beinhalten, die eine Promise zurückgibt:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpClient</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/common/http&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Settings</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../models/settings&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">SettingsService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./settings.service&quot;</span>;\n\n<span class=\"hljs-meta\">@Injectable</span>({\n    <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&quot;root&quot;</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SettingsInitializerService</span> {\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">http</span>: <span class=\"hljs-title class_\">HttpClient</span>, <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">settings</span>: <span class=\"hljs-title class_\">SettingsService</span></span>) {}\n\n    <span class=\"hljs-title function_\">initializeSettings</span>(): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-built_in\">any</span>&gt; {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">http</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;assets/settings.json&quot;</span>).<span class=\"hljs-title function_\">subscribe</span>(\n                <span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> {\n                    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">settings</span>.<span class=\"hljs-property\">settings</span> = response <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Settings</span>;\n                    <span class=\"hljs-title function_\">resolve</span>();\n                },\n                <span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> <span class=\"hljs-title function_\">reject</span>(error),\n            );\n        });\n    }\n}\n</code></pre>\n<p>Von Angular sind Sie es gewohnt, mit Observables zu arbeiten.\nDaher wundern Sie sich eventuell über den Rückgabetyp von <code>initializeSettings()</code>.\nDes Rätsels Lösung ist ganz einfach:\nDer Mechanismus, über den wir in Kürze alles miteinander verdrahten, erwartet an der Stelle ausschließlich ein Promise.</p>\n<p>Der zugehörige Unit-Test sieht folgendermaßen aus:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> {\n    HttpClientTestingModule,\n    HttpTestingController,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/common/http/testing&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { TestBed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/core/testing&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { Settings } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../models/settings&quot;</span>;\n\n<span class=\"hljs-keyword\">import</span> { SettingsInitializerService } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./settings-initializer.service&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { SettingsService } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./settings.service&quot;</span>;\n\ndescribe(<span class=\"hljs-string\">&quot;SettingsInitializerService&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    let service: SettingsInitializerService;\n    let httpMock: HttpTestingController;\n    let settingsService: SettingsService;\n\n    const testSettings: Settings = {\n        baseUrl: <span class=\"hljs-string\">&quot;baseUrl&quot;</span>,\n    };\n\n    beforeEach(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        TestBed.configureTestingModule({\n            imports: [HttpClientTestingModule],\n        });\n\n        service = TestBed.get(SettingsInitializerService);\n        httpMock = TestBed.get(HttpTestingController);\n        settingsService = TestBed.get(SettingsService);\n    });\n\n    afterEach(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        httpMock.verify();\n    });\n\n    it(<span class=\"hljs-string\">&quot;should be created&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        expect(service).toBeTruthy();\n    });\n\n    it(<span class=\"hljs-string\">&quot;should initialize settings&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">(done)</span> =&gt;</span> {\n        service.initializeSettings().<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n            expect(settingsService.settings).toEqual(testSettings);\n            done();\n        });\n\n        const request = httpMock.expectOne(<span class=\"hljs-string\">&quot;assets/settings.json&quot;</span>);\n        expect(request.request.method).toBe(<span class=\"hljs-string\">&quot;GET&quot;</span>);\n        request.flush(testSettings);\n    });\n\n    it(<span class=\"hljs-string\">&quot;should not initialize settings if get settings.json failed&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">(done)</span> =&gt;</span> {\n        service\n            .initializeSettings()\n            .<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n                done.fail(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&quot;this was expected to fail&quot;</span>));\n            })\n            .<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n                expect(settingsService.settings).toBeUndefined();\n                done();\n            });\n\n        const request = httpMock.expectOne(<span class=\"hljs-string\">&quot;assets/settings.json&quot;</span>);\n        expect(request.request.method).toBe(<span class=\"hljs-string\">&quot;GET&quot;</span>);\n        request.flush(testSettings, {\n            status: <span class=\"hljs-number\">500</span>,\n            statusText: <span class=\"hljs-string\">&quot;Some Weird Server Error&quot;</span>,\n        });\n    });\n});\n</code></pre>\n<p>Das war noch nicht weiter kompliziert.\nSpannend wird die Frage, wann und wie wir den Service nun nutzen, um die Konfiguration aus der <code>settings.json</code> zu laden.\nDie App benötigt die Konfiguration, sobald der Browser sie startet.\nLeider lädt die App die Konfiguration aus dem <code>assets</code>-Verzeichnis per HTTP(S)-Aufruf, somit also asynchron.\nWir brauchen also ein Mittel, um das Laden abzuwarten, bevor die App startet.\nGlücklicherweise hat Angular dafür das Konzept des <code>APP_INITIALIZER</code> eingeführt, das genau das leistet.</p>\n<p>Wir passen also das <code>app.module.ts</code> mit dieser Erkenntnis folgendermaßen an, um die Konfiguration zu laden. Tipp: Neu darin sind die Funktion <code>initSettings()</code> vor dem <code>@NgModule()</code>-Decorator und der Provider für das Token <code>APP_INITIALIZER</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpClientModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/common/http&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BrowserModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/platform-browser&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">APP_INITIALIZER</span>, <span class=\"hljs-title class_\">NgModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/core&quot;</span>;\n\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppRoutingModule</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./app-routing.module&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./components/app/app.component&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">OneComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./components/one/one.component&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">TwoComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./components/two/two.component&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">SettingsInitializerService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./services/settings-initializer.service&quot;</span>;\n\n<span class=\"hljs-comment\">// NEW</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">initSettings</span>(<span class=\"hljs-params\">\n    settingsInitializerService: SettingsInitializerService,\n</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> settingsInitializerService.<span class=\"hljs-title function_\">initializeSettings</span>();\n}\n\n@<span class=\"hljs-title class_\">NgModule</span>({\n    <span class=\"hljs-attr\">declarations</span>: [<span class=\"hljs-title class_\">AppComponent</span>, <span class=\"hljs-title class_\">OneComponent</span>, <span class=\"hljs-title class_\">TwoComponent</span>],\n    <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">BrowserModule</span>, <span class=\"hljs-title class_\">AppRoutingModule</span>, <span class=\"hljs-title class_\">HttpClientModule</span>],\n    <span class=\"hljs-attr\">providers</span>: [\n        <span class=\"hljs-comment\">// NEW</span>\n        {\n            <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">APP_INITIALIZER</span>,\n            <span class=\"hljs-attr\">useFactory</span>: initSettings,\n            <span class=\"hljs-attr\">deps</span>: [<span class=\"hljs-title class_\">SettingsInitializerService</span>],\n            <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>,\n        },\n    ],\n    <span class=\"hljs-attr\">bootstrap</span>: [<span class=\"hljs-title class_\">AppComponent</span>],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppModule</span> {}\n</code></pre>\n<p>Anschließend können wir den <code>SettingsService</code> in der Anwendung verwenden, um die Einstellungen in unseren Komponenten und Services zu nutzen.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Settings</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../../models/settings&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">SettingsService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../../services/settings.service&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({\n    <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&quot;app-root&quot;</span>,\n    <span class=\"hljs-attr\">templateUrl</span>: <span class=\"hljs-string\">&quot;./app.component.html&quot;</span>,\n    <span class=\"hljs-attr\">styleUrls</span>: [<span class=\"hljs-string\">&quot;./app.component.scss&quot;</span>],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppComponent</span> {\n    title = <span class=\"hljs-string\">&quot;dockerized-app&quot;</span>;\n    <span class=\"hljs-attr\">settings</span>: <span class=\"hljs-title class_\">Settings</span>;\n\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">settingsService</span>: <span class=\"hljs-title class_\">SettingsService</span></span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">settings</span> = settingsService.<span class=\"hljs-property\">settings</span>;\n    }\n}\n</code></pre>\n<p>Damit haben wir bereits die <em>Development</em>-Umgebung zum Laufen gebracht.\nSie können das mittels <code>ng serve</code> oder <code>ng serve --prod</code> leicht nachprüfen.</p>\n<h2 id=\"umgebung-mit-docker-konfigurieren\">Umgebung mit Docker konfigurieren</h2>\n<p>Wie erzeugen wir jetzt also pro Umgebung eine passende Datei <code>settings.json</code> je Container?\nIch nutze dafür das Tool <code>envsubst</code>.\nDieses liest ein Template, ersetzt darin Umgebungsvariablen und schreibt das Ergebnis in eine neue Datei.</p>\n<p>Hier ist das Template in Form der Datei <code>src/assets/settings.json.template</code>:</p>\n<pre><code class=\"language-json\">{\n    <span class=\"hljs-string\">&quot;baseUrl&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">${BASE_URL}</span>&quot;</span>\n}\n</code></pre>\n<p>Jetzt brauchen wir nur noch die Datei <code>docker-compose.yml</code> dahingehend anzupassen, dass <code>envsubst</code> verwendet wird, um zur Laufzeit die passende Datei <code>settings.json</code> für die jeweilige Umgebung zu erstellen:</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-symbol\">version:</span> <span class=\"hljs-string\">&quot;3&quot;</span>\n<span class=\"hljs-symbol\">\nservices:</span>\n<span class=\"hljs-symbol\">    web:</span>\n<span class=\"hljs-symbol\">        image:</span> dockerized-app\n<span class=\"hljs-symbol\">        env_file:</span>\n            - ./docker.env\n<span class=\"hljs-symbol\">        ports:</span>\n            - <span class=\"hljs-string\">&quot;8093:80&quot;</span>\n<span class=\"hljs-symbol\">        command:</span> <span class=\"hljs-keyword\">/bin/</span>bash -c <span class=\"hljs-string\">&quot;envsubst &#x27;$$BASE_URL&#x27; &lt; \\\n            /usr/share/nginx/html/assets/settings.json.template &gt; \\\n            /usr/share/nginx/html/assets/settings.json &amp;&amp; exec nginx -g \\\n            &#x27;daemon off;&#x27;&quot;</span>\n</code></pre>\n<p><em>Sie müssen die <code>command</code>-Angabe in <em>eine</em> einzige Zeile packen.\nIm obigen Beispiel habe ich die Backslashes lediglich dazu benutzt, die Zeile der Lesbarkeit wegen umzubrechen.</em></p>\n<p>Mit dieser Änderung lädt <code>docker-compose</code> die Umgebung aus der Datei <code>docker.env</code>, in der Umgebungsvariablen definiert sind.\nDie Datei legen Sie bitte mit folgendem Inhalt an:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attr\">BASE_URL</span>=http://some.<span class=\"hljs-literal\">off</span>icial.server:<span class=\"hljs-number\">444</span>\n</code></pre>\n<p>Damit haben wir endlich alle Puzzleteile zusammen, um den Docker-Container mit der gewünschten Umgebung zu starten: Sie benötigen je Umgebung lediglich eine Datei <code>docker.env</code> und darin die jeweils passenden Umgebungsvariablen.\nDie Skripte <code>dockerize.sh</code> und <code>redeploy.sh</code> aus dem vorherigen Teil funktionieren übrigens ohne Änderung weiterhin.</p>\n<h2 id=\"ausblick\">Ausblick</h2>\n<p>Die Artikelserie besteht aus den folgenden Teilen:</p>\n<ol>\n<li><a href=\"https://angular-buch.com/blog/2019-12-docker0-intro\">Angular-Apps und Docker: Einleitung</a></li>\n<li><a href=\"https://angular-buch.com/blog/2019-12-docker1-simple-case\">Angular-App über Docker bereitstellen</a></li>\n<li><a href=\"https://angular-buch.com/blog/2019-12-docker2-build-once-run-anywhere\">Build Once, Run Anywhere oder: Konfiguration über Docker verwalten</a> <strong>(der aktuelle Artikel)</strong></li>\n<li><a href=\"https://angular-buch.com/blog/2019-12-docker3-multi-stage-build\">Multi-Stage Builds oder: Immer die Build-Umgebung dabei haben</a></li>\n</ol>\n<p>Im letzten Teil der Artikelserie zeige ich Ihnen, wie sie die Buildumgebung über die Projektlaufzeit im Griff behalten, auch wenn Sie Ihr System durch neue Versionen der benötigten Werkzeuge verändern.</p>\n<br>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Bild von <a href=\"https://unsplash.com/@chuttersnap\">chuttersnap</a> auf <a href=\"https://unsplash.com\">Unsplash</a>, bearbeitet</small></p>\n","meta":{"title":"[Docker Serie 3/4] Build Once, Run Anywhere oder: Konfiguration über Docker verwalten","author":"Michael Kaaden","mail":"blog@kaaden.net","bio":"Michael Kaaden ist als Software-Architekt und Manager für ein mittelständisches Unternehmen in Nürnberg tätig. Dort ist er für die technische Seite einer Cloud-Produktline verantwortlich. In dieser Eigenschaft kümmert er sich trotz seiner grundsätzlichen Affinität zu Angular nicht nur um Frontends, sondern neben der Gesamtarchitektur unter anderem auch um APIs, Backends, Datenbanken sowie Software-Entwicklungs- und Build-Prozesse. Wenn er in seiner Freizeit nicht gerade mit seiner Familie unterwegs ist, Full-Stack Developer spielt oder seine Nase in neue Technologien steckt, versucht er, seinen Laufstil zu verbessern und endlich den für ihn perfekten Fotoapparat zu finden.","published":"2019-12-16T00:00:00.000Z","keywords":["Docker","Settings","Angular","APP_INITIALIZER"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2019-12-docker2-build-once-run-anywhere/header2.jpg"}}
