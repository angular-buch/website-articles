{"slug":"2024-11-linked-signal","html":"<p>Mit Angular 19 wurde ein <a href=\"https://github.com/angular/angular/commit/8311f00faaf282d1a5b1ddca29247a2fba94a692\">neues Feature</a> vorgestellt: das <strong>Linked Signal</strong>. Es erleichtert die Verwaltung von lokalem Zustand in Verbindung mit anderen Signals. Bei dem Linked Signal handelt sich um ein beschreibbares Signal, das automatisch zur√ºckgesetzt wird, wenn sich andere Signals √§ndern. Dies ist besonders n√ºtzlich, wenn wir lokale Zust√§nde mit dynamischen Daten synchronisieren wollen.\nIn diesem Blogpost stellen wir vor, was ein Linked Signal ist, wie es funktioniert und in welchen Anwendungsf√§llen es sinnvoll eingesetzt werden kann.</p>\n<h2 id=\"inhalt\">Inhalt</h2>\n<ul>\n<li><a href=\"/blog/2024-11-linked-signal#was-ist-ein-linked-signal\">Was ist ein Linked Signal?</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#grundlegende-nutzung-von-linked-signal\">Grundlegende Nutzung von Linked Signal</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#fortgeschrittene-szenarien-fuer-linked-signals\">Fortgeschrittene Szenarien f√ºr Linked Signals</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#linked-signal-und-andere-signals\">Linked Signal und andere Signals</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#best-practices-f%C3%BCr-die-nutzung-von-linked-signals\">Best Practices f√ºr die Nutzung von Linked Signals</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#demo-anwendung\">Demo-Anwendung</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#fazit\">Fazit</a></li>\n</ul>\n<blockquote>\n<p><strong>üá¨üáß This article is available in English language here: <a href=\"https://angular.schule/blog/2024-11-linked-signal\">Angular 19: Introducing LinkedSignal for Responsive Local State Management</a></strong></p>\n</blockquote>\n<h2 id=\"was-ist-ein-linked-signal\">Was ist ein Linked Signal?</h2>\n<p>Das Linked Signal wurde als neues experimentelles Feature von Angular 19 vorgestellt.\nEs soll die Arbeit mit Zust√§nden erleichtern, die mit anderen Signals synchronisiert werden m√ºssen.\nKurz gesagt: Wir erhalten ein beschreibbares Signal, dessen Wert automatisch neu berechnet wird, sobald sich der Wert seines Quellsignals √§ndert.\nEin Linked Signal kann mit der Factory-Funktion <a href=\"https://next.angular.dev/api/core/linkedSignal\"><code>linkedSignal()</code></a> erzeugt werden.</p>\n<p>Ein Linked Signal hat die folgenden Eigenschaften:</p>\n<ul>\n<li><strong>Schreibbar und reaktiv</strong>: Der Wert kann manuell aktualisiert werden (wie mit der Funktion <a href=\"https://angular.dev/guide/signals#writable-signals\"><code>signal</code></a>). Das Linked Signal reagiert aber auch auf √Ñnderungen von der Quelle.</li>\n<li><strong>Eine Kombination aus Signal und Computed</strong>: Es funktioniert wie ein Signal, das mit <a href=\"https://angular.dev/guide/signals#computed-signals\"><code>computed</code></a> erstellt wurde, denn der Wert wird von anderen Signals abgeleitet. Dabei bleibt es aber beschreibbar, sodass wir den Wert bei Bedarf manuell neu setzen k√∂nnen.</li>\n</ul>\n<p>Dadurch bieten Linked Signals eine flexible M√∂glichkeit zur Verwaltung von Zust√§nden, die sich an √Ñnderungen in zugeh√∂rigen Signals anpassen ‚Äì aber bei Bedarf auch direkt gesteuert werden k√∂nnen.\nUm das Linked Signal besser kennenzulernen, betrachten wir das folgende Beispiel, in dem <code>linkedSignal</code> und <code>computed</code> miteinander verglichen werden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { computed, linkedSignal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> timestampMs = signal(Date.now());\n\n<span class=\"hljs-comment\">// computed(): Signal (nicht √ºberschreibbar)</span>\n<span class=\"hljs-keyword\">const</span> timestampSeconds = computed(() =&gt; timestampMs() / <span class=\"hljs-number\">1000</span>);\ntimestampSeconds.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ‚ùå Fehler</span>\n\n<span class=\"hljs-comment\">// linkedSignal(): WritableSignal</span>\n<span class=\"hljs-keyword\">const</span> timestampSecondsLinked = linkedSignal(() =&gt; timestampMs() / <span class=\"hljs-number\">1000</span>);\ntimestampSecondsLinked.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ‚úÖ funktioniert</span>\n</code></pre>\n<p>Die beiden Funktionen <code>computed()</code> und <code>linkedSignal()</code> sehen auf den ersten Blick sehr √§hnlich aus: \nBeide erhalten eine <em>Computation Function</em>, die das Ergebnis des Signals neu berechnet, wenn sich eines der gebundenen Signals (hier: <code>timestampMs</code>) √§ndert.\nDer wesentliche Unterschied ist der R√ºckgabewert:\nW√§hrend <code>computed()</code> ein reines <code>Signal</code> zur√ºckgibt, das nur lesbar ist, erzeugt die neue Funktion <code>linkedSignal()</code> ein <code>WritableSignal</code>.</p>\n<p>Das bedeutet, dass wir den Wert bei Bedarf mit <code>set()</code> und <code>update()</code> √ºberschreiben k√∂nnen.\nEin Signal, das mit <code>computed()</code> erstellt wurde, bietet diese Schnittstelle nicht an.</p>\n<p>Im ersten Beispiel haben wir die <strong>Kurzschreibweise</strong> f√ºr das Linked Signal verwendet. Es ist aber auch m√∂glich, die Berechnung in eine separate Funktion auszulagern. \nDer Wert des Signals aus <code>source</code> wird dann automatisch an die Berechnungsfunktion <code>computation</code> √ºbergeben.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> timestampMs = <span class=\"hljs-keyword\">signal</span><span class=\"hljs-string\"></span>(<span class=\"hljs-built_in\">Date</span>.now());\n\n<span class=\"hljs-keyword\">const</span> timestampSecondsLinked = linkedSignal({\n  <span class=\"hljs-attribute\">source</span>: timestampMs,\n  <span class=\"hljs-attribute\">computation</span>: ms =&gt; ms / <span class=\"hljs-number\">1000</span>\n});\n</code></pre>\n<p>Ob das ausf√ºhrlichere Options-Objekt mit <code>source</code> und <code>computation</code> oder die Kurzschreibweise verwendet werden sollte, h√§ngt vom Anwendungsfall und pers√∂nlichen Geschmack ab. \nBeide gezeigten Beispiele f√ºr <code>timestampSecondsLinked</code> haben genau das gleiche Verhalten. \nIn komplexeren F√§llen kann eine separate Berechnungsfunktion den Code jedoch leichter verst√§ndlich und lesbarer machen.</p>\n<h2 id=\"grundlegende-nutzung-von-linked-signal\">Grundlegende Nutzung von Linked Signal</h2>\n<p>Wir schauen uns ein umfangreicheres Beispiel an:\nUnsere Komponente <code>BookListComponent</code> h√§lt eine Liste von B√ºchern im Signal <code>books</code>.\nAnschlie√üend verwenden wir ein Linked Signal, um das <em>erste Buch</em> in der Liste zu ermitteln.\nWir haben uns entschieden, die ausf√ºhrliche Notation mit einem Optionsobjekt zu verwenden. \nDie separate <em>Computation Function</em> macht den Code lesbarer im Vergleich zu einer einzeiligen Funktion, die Quelle und Berechnung vereint.</p>\n<p>Immer wenn sich die Liste der B√ºcher √§ndert (dies geschieht in unserem Beispiel durch die Methode <code>changeBookList()</code>), berechnet das Signal <code>firstBook</code> seinen Wert automatisch neu, und das neu ermittelte erste Buch wird angezeigt.\nBis hierhin h√§tten wir daf√ºr auch ein Computed Signal verwenden k√∂nnen.\nDas Linked Signal macht es aber nun m√∂glich, den Wert in der Methode <code>overrideFirstBook()</code> manuell zu √ºberschreiben.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component, linkedSignal, signal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-book-list&#x27;</span>,\n  template: `\n    &lt;p&gt;First book in list: {{ firstBook() }}&lt;/p&gt;\n    &lt;button (click)=<span class=\"hljs-string\">&quot;changeBookList()&quot;</span>&gt;Change Book List&lt;/button&gt;`\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookListComponent</span> {\n  books = signal([<span class=\"hljs-string\">&#x27;Angular&#x27;</span>, <span class=\"hljs-string\">&#x27;React&#x27;</span>, <span class=\"hljs-string\">&#x27;Vue&#x27;</span>]);\n\n  firstBook = linkedSignal({\n    source: <span class=\"hljs-keyword\">this</span>.books,\n    computation: books =&gt; books[<span class=\"hljs-number\">0</span>]\n  });\n\n  <span class=\"hljs-comment\">// Alternativ: Kurzschreibweise</span>\n  <span class=\"hljs-comment\">// firstBook = linkedSignal(() =&gt; this.books()[0]);</span>\n\n  overrideFirstBook() {\n    <span class=\"hljs-comment\">// Manuelles Update von `firstBook`, gibt jetzt &#x27;jQuery&#x27; zur√ºck</span>\n    <span class=\"hljs-keyword\">this</span>.firstBook.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&#x27;jQuery&#x27;</span>);\n  }\n\n  changeBookList() {\n    <span class=\"hljs-comment\">// √Ñnderungen an `books` bewirken, dass `firstBook` zur√ºckgesetzt wird.</span>\n    <span class=\"hljs-comment\">// Der R√ºckgabewert ist dann wieder &#x27;Next.js&#x27;</span>\n    <span class=\"hljs-keyword\">this</span>.books.<span class=\"hljs-keyword\">set</span>([<span class=\"hljs-string\">&#x27;Next.js&#x27;</span>, <span class=\"hljs-string\">&#x27;Svelte&#x27;</span>, <span class=\"hljs-string\">&#x27;Nuxt&#x27;</span>]);\n  }\n}\n</code></pre>\n<p>In diesem Beispiel geschieht Folgendes:</p>\n<ul>\n<li>Das Linked Signal <code>firstBook</code> zeigt zun√§chst auf das erste Buch in der Liste der <code>books</code>.</li>\n<li>Wir k√∂nnen den Wert jederzeit manuell √ºberschreiben, wie bei dem Buch ‚ÄûjQuery‚Äú zu erkennen ist.</li>\n<li>Wenn sich <code>books</code> √§ndert, wird <code>firstBook</code> neu berechnet, um den ersten Eintrag in der aktualisierten Liste wiederzugeben.</li>\n</ul>\n<p>Das Signal enth√§lt immer den neuesten Wert: Entweder wird er manuell durch <code>set()</code>/<code>update()</code> gesetzt oder er wird von der Berechnungsfunktion ermittelt, wenn sich das gebundene Signal √§ndert.</p>\n<h3 id=\"anwendungsfall-mit-input-signals\">Anwendungsfall mit Input-Signals</h3>\n<p>Ein h√§ufiger Anwendungsfall f√ºr ein Linked Signal ist eine Komponente, die sich basierend auf einem Input-Signal zur√ºcksetzt.<br>Ein gutes Beispiel daf√ºr ist eine Warenkorb-Komponente (hier: <code>ShoppingCartComponent</code>).\nSie besitzt ein Eingabefeld f√ºr die Menge, das zur√ºckgesetzt werden soll, wenn sich das ausgew√§hlte Produkt √§ndert.\nWir k√∂nnten ein solches Ergebnis zwar auch mit <code>computed()</code> erzielen, allerdings wollen wir die Menge zus√§tzlich durch das Formular ver√§ndern k√∂nnen.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component, input, linkedSignal } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-shopping-cart&#x27;</span>,\n  template: `<span class=\"language-javascript\">\n    &lt;p&gt;<span class=\"hljs-title class_\">Book</span>: {{ <span class=\"hljs-title function_\">selectedBook</span>().<span class=\"hljs-property\">title</span> }}&lt;/p&gt;\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> [(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;amount&quot;</span>&gt;</span></span></span>`,\n  imports: [FormsModule]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShoppingCartComponent</span> {\n  selectedBook = input.required&lt;Book&gt;();\n  amount = linkedSignal({\n    source: this.selectedBook,\n     <span class=\"hljs-regexp\">//</span> Auf <span class=\"hljs-number\">1</span> zur√ºcksetzen, wenn sich selectedBook √§ndert\n    computation: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-number\">1</span>\n  });\n}\n</code></pre>\n<p>In diesem Fall wird der Wert von <code>amount</code> stets auf <code>1</code> zur√ºckgesetzt, wenn sich <code>selectedBook</code> √§ndert.<br>Das <code>&lt;input&gt;</code>-Feld im Template spiegelt diese √Ñnderung wider und setzt sich ebenfalls auf 1 zur√ºck.<br>Dieses Muster ist n√ºtzlich f√ºr Formulare, die in ihren Ausgangszustand zur√ºckgesetzt werden sollen, sobald bestimmte Signals ge√§ndert werden.</p>\n<p>F√ºr diesen Anwendungsfall ist die <strong>Langschreibweise</strong> mit <code>source</code> und <code>computation</code> der eleganteste Weg:\nWir sind nicht am tats√§chlichen Wert von <code>selectedBook</code> interessiert.\nStattdessen m√∂chten wir den Wert jedes Mal auf <code>1</code> zur√ºcksetzen, wenn sich <code>selectedBook</code> √§ndert.\nAus diesem Grund haben wir <code>source</code> und <code>computation</code> getrennt und nicht die Kurzschreibweise verwendet.</p>\n<h2 id=\"fortgeschrittene-szenarien-f√ºr-linked-signals\">Fortgeschrittene Szenarien f√ºr Linked Signals</h2>\n<h3 id=\"nested-state-management\">Nested State Management</h3>\n<p>Wir wollen ein weiteres Beispiel betrachten, in dem wieder die Buch-Entit√§t verwendet wird. In dieser Komponente arbeiten wir mit zwei Eigenschaften des Buchs: <code>title</code> und <code>rating</code>.\nDiese Felder sollen zur√ºckgesetzt und neu berechnet werden, wenn ein anderes Buch √ºber ein Input-Signal ausgew√§hlt wird.\nSo k√∂nnte man dies mit einem Linked Signal umsetzen:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component, computed, input, linkedSignal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-book&#x27;</span>,\n  template: `\n    &lt;p&gt;Title: {{ title() }}&lt;/p&gt;\n    &lt;p&gt;Rating: {{ rating() }}&lt;/p&gt;\n\n    &lt;button (click)=<span class=\"hljs-string\">&quot;doRateUp()&quot;</span>&gt;Rate up&lt;/button&gt;\n  `,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookComponent</span>  {\n  book = input.required&lt;Book&gt;();\n  ratingChange = output&lt;{ isbn: string, newRating: number }&gt;();\n\n  title = computed(() =&gt; <span class=\"hljs-keyword\">this</span>.book().title);\n  rating = linkedSignal(() =&gt; <span class=\"hljs-keyword\">this</span>.book().rating);\n\n  <span class=\"hljs-comment\">// Alternativ: Langschreibweise</span>\n  <span class=\"hljs-comment\">/*rating = linkedSignal({\n    source: this.book,\n    computation: book =&gt; book.rating,\n  });*/</span>\n\n  doRateUp() {\n    <span class=\"hljs-keyword\">const</span> newRating = <span class=\"hljs-keyword\">this</span>.rating() + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">this</span>.rating.<span class=\"hljs-keyword\">set</span>(newRating);\n\n    <span class=\"hljs-keyword\">this</span>.ratingChange.emit({ \n      isbn: <span class=\"hljs-keyword\">this</span>.book().isbn,\n      newRating\n    });\n  }\n}\n</code></pre>\n<p>Die Eigenschaften <code>title</code> und <code>rating</code> werden aus dem Quellsignal <code>book</code> abgeleitet. Ihre Werte werden automatisch neu berechnet, wenn sich <code>book</code> √§ndert.\nW√§hrend das Linked Signal sicherstellt, dass die Daten bei Bedarf zur√ºckgesetzt werden, k√∂nnen wir den lokalen Zustand weiterhin direkt aktualisieren.\nIn diesem Beispiel ver√§ndern wir die Bewertung lokal. Anschlie√üend √ºbermitteln wir die √Ñnderung an die √ºbergeordnete Komponente, indem das Event <code>ratingChange</code> ausgel√∂st wird.\nDa wir <code>title</code> in dieser Komponente nicht manuell √§ndern m√ºssen, reicht hier ein Computed Signal aus.</p>\n<p>Wir haben uns f√ºr die Kurzschreibweise f√ºr das Linked Signal entschieden, weil die Berechnung sehr einfach ist.\nAu√üerdem sehen die Zeilen mit <code>computed()</code> und <code>linkedSignal()</code> sehr √§hnlich aus, was die Lesbarkeit erh√∂ht.\nJe nach Geschmack ist aber auch die Langschreibweise m√∂glich.</p>\n<h3 id=\"daten-vom-server-auf-der-client-seite-bearbeiten\">Daten vom Server auf der Client-Seite bearbeiten</h3>\n<p>Ein Linked Signal ist auch bei der Arbeit mit Daten vom Server hilfreich, die lokal bearbeitet werden sollen.\nIn dem folgenden Beispiel wollen wir Daten von einer HTTP-API laden.\nDer <code>BookStoreService</code> nutzt daf√ºr den <code>HttpClient</code> von Angular.\nDie Quelle der Daten ist somit ein Observable, das nicht direkt editierbar ist. Als zus√§tzliche Anforderung haben wir aber genau diesen Wunsch: Wir wollen die Daten ohne Umwege direkt lokal editieren. Hierf√ºr bietet sich das Linked Signal an:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component, inject, linkedSignal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { BookStoreService } from <span class=\"hljs-string\">&#x27;./book-store.service&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-dashboard&#x27;</span>,\n  template: `\n    @for (b of books(); track b.isbn) {\n      &lt;app-book\n        (ratingChange)=<span class=\"hljs-string\">&quot;handleRatingChange(<span class=\"hljs-variable\">$event</span>.isbn, <span class=\"hljs-variable\">$event</span>.newRating)&quot;</span>\n        [book]=<span class=\"hljs-string\">&quot;b&quot;</span>\n      /&gt;\n    } \n\n    &lt;button (click)=<span class=\"hljs-string\">&quot;changeOrder()&quot;</span>&gt;Change order (locally)&lt;/button&gt;\n  `,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DashboardComponent</span> {\n  <span class=\"hljs-keyword\">private</span> bookStore = inject(BookStoreService);\n\n  books = linkedSignal(\n    toSignal(<span class=\"hljs-keyword\">this</span>.bookStore.getAllBooks(), { initialValue: [] })\n  );\n\n  changeOrder() {\n    <span class=\"hljs-keyword\">this</span>.books.update(books =&gt; books.toReversed());\n  }\n\n  handleRatingChange(isbn: string, newRating: number) {\n    <span class=\"hljs-keyword\">this</span>.books.update(books =&gt;\n      books.map(b =&gt; {\n        <span class=\"hljs-comment\">// falls es sich um das zu aktualisierende Buch handelt, </span>\n        <span class=\"hljs-comment\">// setzen wir das neue Rating</span>\n        <span class=\"hljs-keyword\">if</span> (b.isbn === isbn) {\n          <span class=\"hljs-keyword\">return</span> { ...b, rating: newRating };\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-comment\">// alle anderen B√ºcher in der Liste bleiben unver√§ndert</span>\n          <span class=\"hljs-keyword\">return</span> b;\n        }\n      })\n    );\n  }\n}\n</code></pre>\n<p>In diesem Beispiel enth√§lt <code>books</code> die Daten, die vom Server geladen wurden.<br>Normalerweise w√ºrden wir <code>toSignal()</code> verwenden, um das Observable in ein Signal umzuwandeln.\nMit <code>toSignal()</code> allein k√∂nnten wir die abgerufenen Daten jedoch nicht nachtr√§glich bearbeiten ‚Äì dazu m√ºssten wir das Observable dazu bringen, ein neues Element auszugeben.</p>\n<p>Da wir aber ein Linked Signals verwendet haben, k√∂nnen wir die Daten trotzdem lokal √ºberschreiben.\nWird die Quelle zur√ºckgesetzt (z. B. bei einem Neuladen der Daten vom Server) werden die neu geladenen Daten verwendet.</p>\n<p>Wir haben hier die Kurzschreibweise f√ºr <code>linkedSignal()</code> verwendet und das Signal von <code>toSignal()</code> direkt √ºbergeben, denn wir m√∂chten lediglich die Quelle in ein Linked Signal umwandeln. \nDie lange Schreibweise mit einer separaten Funktion zur Berechnung ist nicht erforderlich.</p>\n<p>Zus√§tzlich haben wir in diesem Beispiel zwei weitere Anforderungen aufgenommen, die die Komplexit√§t ein wenig erh√∂hen sollen:\nWenn die Methode <code>changeOrder()</code> aufgerufen wird, √§ndern wir die Reihenfolge der B√ºcherliste.\nZus√§tzlich behandeln wir das Event <code>ratingChange</code> aus dem vorherigen Beispiel.<br>Die zugeh√∂rige Methode <code>handleRatingChange()</code> nimmt den Identifikator <code>isbn</code> und das neue Rating entgegen und ersetzt das alte Buchobjekt durch eine aktualisierte Kopie.  </p>\n<p>Um das Ganze abzurunden, k√∂nnte man auch die Buchdaten √§ndern und den aktualisierten Zustand an den Server zur√ºcksenden ‚Äì aber diese Aufgabe √ºberlassen wir unseren Leserinnen und Lesern. üòâ</p>\n<blockquote>\n<p>‚ÑπÔ∏è <strong>Wussten Sie schon?</strong> In Version 19 von Angular wurde zus√§tzlich die neue experimentelle <strong>Resource API</strong> eingef√ºhrt. Sie erm√∂glicht das asynchrone Laden von Daten und das Auslesen des Ladestatus, wobei das Signal f√ºr die Daten lokal beschreibbar bleibt.<br>Wir haben die Resource API in einem separaten Blogbeitrag vorgestellt: <strong><a href=\"https://angular-buch.com/blog/2024-10-resource-api\">Neu in Angular 19: Daten laden mit der Resource API</a></strong></p>\n</blockquote>\n<h3 id=\"reactive-forms-mit-signals-kombinieren\">Reactive Forms mit Signals kombinieren</h3>\n<p>Mit Linked Signals k√∂nnen wir Hilfsfunktionen erstellen, um die traditionelle, nicht-signal-basierte Welt mit der Welt von Signals zu verbinden.\nDie folgende Wrapper-Funktion synchronisiert ein <code>FormControl</code> (oder ein anderes Control) mit einem Signal.<br>Die Daten werden bidirektional ausgetauscht: Wenn sich der Formularwert √§ndert (<code>valueChanges</code>), wird auch der Wert des Signals aktualisiert.<br>Die Funktion gibt ein schreibbares Signal zur√ºck. Wenn wir den Wert des Signals √§ndern, wird auch der Formularwert aktualisiert (<code>setValue()</code>).</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">signalFromControl</span>&lt;<span class=\"hljs-title function_\">T</span>&gt;(<span class=\"hljs-params\">control: AbstractControl&lt;T&gt;</span>) {\n  const controlSignal = linkedSignal(\n    toSignal(control.valueChanges, { <span class=\"hljs-attr\">initialValue</span>: control.value })\n  );\n  effect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> control.setValue(controlSignal()));\n  <span class=\"hljs-keyword\">return</span> controlSignal;\n}\n</code></pre>\n<p>Wir verwenden hier die Funktion <code>effect()</code>, um einen Effekt zu erzeugen, der automatisch auf √Ñnderungen von Signals reagiert. \nSo stellen wir sicher, dass bei jeder √Ñnderung im Signal <code>controlSignal</code> auch der Wert des Formular-Controls √ºber <code>setValue()</code> aktualisiert wird.\nDadurch entsteht eine <strong>bidirektionale Synchronisierung</strong> zwischen dem Signal und dem Formular-Control.<br>Wenn Sie mehr √ºber die M√∂glichkeiten von <code>effect()</code> erfahren m√∂chten, lesen Sie unseren Artikel: <strong><a href=\"https://angular.schule/blog/2024-11-effect-afterrendereffect\">Angular 19: Mastering effect and afterRenderEffect</a></strong>.</p>\n<p>Der Helfer kann wie folgt verwendet werden:</p>\n<pre><code class=\"language-ts\">bookForm = <span class=\"hljs-keyword\">new</span> FormGroup({\n  isbn: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> }),\n  title: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> }),\n});\n\ntitle = signalFromControl(<span class=\"hljs-keyword\">this</span>.bookForm.controls.title);\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-comment\">// Der Formularwert wird auf &#x27;Angular&#x27; aktualisiert</span>\n<span class=\"hljs-keyword\">this</span>.title.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&#x27;Angular&#x27;</span>);\n\n<span class=\"hljs-comment\">// Der Signalwert wird auf &#x27;Signals&#x27; aktualisiert</span>\n<span class=\"hljs-keyword\">this</span>.bookForm.setValue({ isbn: <span class=\"hljs-string\">&#x27;123&#x27;</span>, title: <span class=\"hljs-string\">&#x27;Signals&#x27;</span> });\n</code></pre>\n<h2 id=\"linked-signal-und-andere-signals\">Linked Signal und andere Signals</h2>\n<p>Abschlie√üend noch ein kurzer Vergleich mit anderen Arten von Signals:</p>\n<ul>\n<li><strong><code>signal()</code></strong>: Erzeugt ein Signal, das beschreibbar ist und seinen Wert unabh√§ngig von anderen Signals beibeh√§lt. Es hat einen Startwert, welcher mit <code>set()</code> und <code>update()</code> √ºberschrieben werden kann.</li>\n<li><strong><code>computed()</code></strong>: Erzeugt ein schreibgesch√ºtztes Signal, das seinen Wert von anderen Signals ableitet und automatisch neu berechnet. Es l√§sst aber keine manuellen √Ñnderungen zu.</li>\n<li><strong><code>linkedSignal()</code></strong>: Kombiniert die Reaktivit√§t von <code>computed()</code> mit der Ver√§nderbarkeit von <code>signal()</code>. Der Wert kann manuell aktualisiert werden, w√§hrend er weiterhin mit einem Quellsignal gekoppelt bleibt.</li>\n</ul>\n<p>Wir empfehlen, <code>linkedSignal()</code> nur f√ºr Zust√§nde zu verwenden, die aufgrund von konkreter Abh√§ngigkeiten zur√ºckgesetzt werden sollen.\nNutzen Sie weiterhin <code>computed()</code> f√ºr abgeleitete Daten, die nicht √ºberschrieben werden m√ºssen.</p>\n<h2 id=\"best-practices-f√ºr-die-nutzung-von-linked-signals\">Best Practices f√ºr die Nutzung von Linked Signals</h2>\n<p>Hier sind einige Tipps f√ºr die optimale Nutzung von Linked Signals:</p>\n<ul>\n<li><strong>Berechnungsfunktionen einfach halten</strong>: Vermeiden Sie komplexe Berechnungen in der Computation Function, um zyklische Abh√§ngigkeiten zu vermeiden und den Code besser verst√§ndlich zu halten.<br>F√ºhrt eine Berechnung zu einem zyklischen Zugriff auf sich selbst, stoppt Angular die Ausf√ºhrung mit dieser Fehlermeldung: <a href=\"https://github.com/angular/angular/blob/7d0ba0cac85220cbbe4044667a51e5b95512f5d6/packages/core/primitives/signals/src/computed.ts#L114\">&quot;Detected cycle in computations.&quot;</a></li>\n<li><strong>Nutzung zum Zur√ºcksetzen</strong>: <code>linkedSignal()</code> ist ideal f√ºr F√§lle, in denen ein Zustand basierend auf einem bestimmten Signal zur√ºckgesetzt werden soll, z. B. das Leeren eines Formularfelds, wenn ein neues Element ausgew√§hlt wird.<br>Wenn der Wert nicht durch ein Formular ver√§ndert werden soll, ist <code>computed()</code> die bessere Wahl.</li>\n<li><strong>Effects f√ºr komplexe Szenarien in Betracht ziehen</strong>: Wenn mehrere Signals auf eine einzige √Ñnderung reagieren sollen, kann die Nutzung von <code>effect()</code> √ºbersichtlicher und effizienter sein, als mehrere Signals mit <code>linkedSignal()</code> zu erstellen.</li>\n</ul>\n<h2 id=\"demo-anwendung\">Demo-Anwendung</h2>\n<p>Um Linked Signals direkt in Aktion zu sehen, haben wir eine Demo-Anwendung auf  erstellt, die alle in diesem Artikel besprochenen Beispiele zeigt.\nDer erste Link f√ºhrt zum Quellcode auf GitHub.\nDer zweite Link √∂ffnet eine Online-Demo der Anwendung, die Sie direkt ausprobieren k√∂nnen.\nSchlie√ülich bietet der dritte Link eine interaktive Demo auf StackBlitz, in der Sie den Quellcode bearbeiten und die Ergebnisse in Echtzeit sehen k√∂nnen.</p>\n<blockquote>\n<p><strong><a href=\"https://github.com/angular-schule/demo-linked-signal\">1Ô∏è‚É£ Quelltext auf GitHub: demo-linked-signal</a></strong><br><strong><a href=\"https://angular-schule.github.io/demo-linked-signal/\">2Ô∏è‚É£ Demo der Anwendung</a></strong><br><strong><a href=\"https://stackblitz.com/github/angular-schule/demo-linked-signal?file=src%2Fapp%2Fbooks%2Fdashboard%2Fdashboard.component.ts\">3Ô∏è‚É£ StackBlitz Demo</a></strong>  </p>\n</blockquote>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Das Linked Signal von Angular 19 bietet eine praktische L√∂sung zur Verwaltung von lokalem State, der mit anderen Signals synchronisiert werden soll. \nDieses neue Feature schlie√üt die L√ºcke zwischen <code>signal()</code> und <code>computed()</code> und bietet eine neue M√∂glichkeit, komplexe reaktive Frontends zu gestalten.\nProbieren Sie doch <code>linkedSignal()</code> einmal in Ihrem Angular-Projekt aus!\n<strong>‚ö†Ô∏è Bitte beachten Sie, dass die API sich noch im Status &quot;Developer Preview&quot; befindet und √Ñnderungen unterliegen kann.</strong></p>\n<hr>\n\n<p><small>Vielen Dank an Danny Koppenhagen f√ºr das Review und das wertvolle Feedback!</small></p>\n<p><small><strong>Titelbild:</strong> generiert mit Adobe Firefly</small></p>\n","meta":{"title":"Neu in Angular 19: LinkedSignal f√ºr reaktive Zustandsverwaltung","author":"Johannes Hoppe and Ferdinand Malcher","mail":"team@angular.schule","published":"2024-11-07T00:00:00.000Z","lastModified":"2024-11-16T00:00:00.000Z","keywords":["Angular","JavaScript","Signals","Reactive Programming","Linked Signal","Angular 19","Computed Signals"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2024-11-linked-signal/linkedsignal.jpg","sticky":false}}
