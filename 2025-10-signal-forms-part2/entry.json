{"slug":"2025-10-signal-forms-part2","html":"<p>Angular Signal Forms offer techniques for advanced validation scenarios and schema patterns, which makes them truly powerful for complex form requirements.\nIn this article, we will go beyond basic field validation as we covered it in <a href=\"/blog/2025-10-signal-forms-part1/\">Part 1</a>):\nWe will learn about custom schema validation, cross-field validation, conditional validation, asynchronous validation, and how to handle server-side errors gracefully.</p>\n<blockquote>\n<p>⚠️ <strong>Experimental Feature:</strong> Signal Forms are currently an experimental feature in Angular. The API and functionality may change in future releases.</p>\n</blockquote>\n<h2 id=\"related-blog-posts\">Related blog posts</h2>\n<p><strong>This blog post is part of our series about Signal Forms:</strong></p>\n<ul>\n<li><a href=\"/blog/2025-10-signal-forms-part1\">Part 1: Getting Started with Signal Forms</a></li>\n<li><em>Part 2: Advanced Validation and Schema Patterns</em> (this post)</li>\n<li><a href=\"/blog/2025-10-signal-forms-part3\">Part 3: Child Forms and Custom UI Controls</a></li>\n</ul>\n<h2 id=\"aria-support-for-error-display\">ARIA Support for Error Display</h2>\n<p>First things first: When displaying validation errors in the UI, it&#39;s important to consider accessibility.\nTo properly mark fields as invalid in the UI, we should set the <code>aria-invalid</code> attribute on input elements.\nThis attribute should be set to <code>true</code> if the field has been touched and contains errors.\nHowever, if the field hasn&#39;t been touched yet or if an asynchronous validation is still in progress, we should avoid setting this attribute to prevent unnecessary error announcements by screen readers.\nThis is why we return <code>undefined</code> in this case, which means the attribute won&#39;t be added to the element at all.</p>\n<p>A helper method in our component can determine the appropriate value for this invalid state:</p>\n<pre><code class=\"language-typescript\">export class RegistrationForm {\n  <span class=\"hljs-comment\">// ...</span>\n  protected <span class=\"hljs-built_in\">ariaInvalidState</span>(field: FieldTree&lt;unknown&gt;): boolean | undefined {\n    return <span class=\"hljs-built_in\">field</span>()<span class=\"hljs-selector-class\">.touched</span>() &amp;&amp; !<span class=\"hljs-built_in\">field</span>()<span class=\"hljs-selector-class\">.pending</span>()\n      ? <span class=\"hljs-built_in\">field</span>()<span class=\"hljs-selector-class\">.errors</span>()<span class=\"hljs-selector-class\">.length</span> &gt; <span class=\"hljs-number\">0</span>\n      : undefined;\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>In our template, we can now use a <code>[ariaInvalid]</code> binding on the input elements to reflect the invalid state:</p>\n<pre><code class=\"language-html\">&lt;<span class=\"hljs-keyword\">label</span>\n  &gt;Username\n  &lt;<span class=\"hljs-keyword\">input</span>\n    <span class=\"hljs-keyword\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span>\n    [field]=<span class=\"hljs-string\">&quot;registrationForm.username&quot;</span>\n    [ariaInvalid]=<span class=\"hljs-string\">&quot;ariaInvalidState(registrationForm.username)&quot;</span>\n  /&gt;\n  &lt;<span class=\"hljs-keyword\">app</span>-<span class=\"hljs-keyword\">form</span>-<span class=\"hljs-keyword\">error</span> [fieldRef]=<span class=\"hljs-string\">&quot;registrationForm.username&quot;</span> /&gt;\n&lt;/<span class=\"hljs-keyword\">label</span>&gt;\n</code></pre>\n<p>This code snippet only shows the username field, but you should apply the same logic to all input fields in your form.</p>\n<h2 id=\"array-validation\">Array validation</h2>\n<p>Our first use case is to validate each email address in the <code>email</code> array.\nWe want to use the built-in <code>email</code> validator, but it must be applied to each and every field in the array.\nThis is where <code>applyEach()</code> comes into play:\nIt sets the validation rules for each item of the <code>email</code> array.</p>\n<p>This function takes a field array as first argument.\nThe second argument is a validation schema which is then applied to all children.\nThe schema callback provides access to the current item path.\nWe can directly use this path and pass it into our <code>email()</code> validation function to validate all fields individually.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, applyEach, email } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-title function_\">applyEach</span>(fieldPath.<span class=\"hljs-property\">email</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">emailPath</span>) =&gt;</span> {\n  <span class=\"hljs-title function_\">email</span>(emailPath, { <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;E-Mail format is invalid&#x27;</span> });\n});\n</code></pre>\n<blockquote>\n<p><code>applyEach()</code> applies a validation schema to each item in an array field.</p>\n</blockquote>\n<p>The validation messages will be displayed in the UI since we included our generic <code>FormError</code> component below each email input field. We developed this component in Part 1 of this blog series.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">fieldset</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">legend</span>&gt;</span>\n    E-Mail Addresses\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">&quot;addEmail()&quot;</span>&gt;</span>+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">legend</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    @for (emailField of registrationForm.email; track $index) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;group&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n          <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;email&quot;</span>\n          [<span class=\"hljs-attr\">field</span>]=<span class=\"hljs-string\">&quot;emailField&quot;</span>\n          [<span class=\"hljs-attr\">ariaLabel</span>]=<span class=\"hljs-string\">&quot;&#x27;E-Mail &#x27; + $index&quot;</span>\n          [<span class=\"hljs-attr\">ariaInvalid</span>]=<span class=\"hljs-string\">&quot;ariaInvalidState(emailField)&quot;</span>\n        /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">&quot;removeEmail($index)&quot;</span>&gt;</span>-<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-form-error</span> [<span class=\"hljs-attr\">fieldRef</span>]=<span class=\"hljs-string\">&quot;emailField&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    }\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">fieldset</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n</code></pre>\n<h2 id=\"custom-validation-functions\">Custom Validation Functions</h2>\n<p>Our second use case is to ensure that at least one email address is provided in the <code>email</code> array.\nFor this, we don&#39;t have to look at each individual email field, but rather at the array as a whole.\nUsing the <code>validate()</code> function, we can provide custom validation for a branch in the field tree, similar to how we used built-in validators before.\nThe callback function provides access to the field state, represented as a <code>ChildFieldContext</code>.\nThis object can be used to access the <code>value</code> signal and read the current value of the email array.</p>\n<p>Since the value is a <code>string[]</code>, we can use <code>Array.some()</code> to check if at least one non-empty email address exists.\nTo produce an error, we return a validation error object with a <code>kind</code> and a <code>message</code>.\nIf no error occurs, we return <code>undefined</code>.\nThe <code>message</code> is optional, but it is recommended to provide a user-friendly message that can be displayed in the UI later.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, validate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> registrationSchema = schema&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">fieldPath</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// E-Mail validation</span>\n  <span class=\"hljs-title function_\">validate</span>(fieldPath.<span class=\"hljs-property\">email</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">ctx</span>) =&gt;</span>\n    !ctx.<span class=\"hljs-title function_\">value</span>().<span class=\"hljs-title function_\">some</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> e)\n      ? {\n          <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">&#x27;atLeastOneEmail&#x27;</span>,\n          <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;At least one E-Mail address must be added&#x27;</span>,\n        }\n      : <span class=\"hljs-literal\">undefined</span>\n  );\n});\n</code></pre>\n<blockquote>\n<p><code>validate()</code> defines custom validation logic for a specific field or branch in the form tree. It returns a validation error or <code>undefined</code> if the value is valid.</p>\n</blockquote>\n<p>To display the error message, we add our <code>FormError</code> component below the <code>@for</code> loop that renders the email fields.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">fieldset</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">legend</span>&gt;</span>\n    E-Mail Addresses\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">&quot;addEmail()&quot;</span>&gt;</span>+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">legend</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    @for (emailField of registrationForm.email; track $index) {\n    <span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n    }\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">app-form-error</span> [<span class=\"hljs-attr\">fieldRef</span>]=<span class=\"hljs-string\">&quot;registrationForm.email&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">fieldset</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n</code></pre>\n<h2 id=\"cross-field-validation\">Cross-Field Validation</h2>\n<p>Our registration form should also include password fields: One for the password and one for confirmation.\nFor these two fields, we want to ensure that both values match.\nFirst, we extend our data model and the initial state, so it includes a nested object holding password information.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">RegisterFormData</span> {\n  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">password</span>: { <span class=\"hljs-attr\">pw1</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">pw2</span>: <span class=\"hljs-built_in\">string</span> };\n  <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-title class_\">RegisterFormData</span> = {\n  <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n  <span class=\"hljs-attr\">password</span>: { <span class=\"hljs-attr\">pw1</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-attr\">pw2</span>: <span class=\"hljs-string\">&#x27;&#x27;</span> },\n  <span class=\"hljs-comment\">// ...</span>\n};\n</code></pre>\n<p>We should also update our template and add two input fields of type <code>password</code>.\nTo display errors, we include our <code>FormError</code> component for each field as well as for the whole password group:\nErrors can be assigned to individual fields (<code>pw1</code>) or to the grouping node (<code>password</code>), as we will see later.</p>\n<pre><code class=\"language-html\">&lt;<span class=\"hljs-keyword\">label</span>&gt;Password\n  &lt;<span class=\"hljs-keyword\">input</span>\n    <span class=\"hljs-keyword\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span>\n    autocomplete\n    [field]=<span class=\"hljs-string\">&quot;registrationForm.password.pw1&quot;</span>\n    [ariaInvalid]=<span class=\"hljs-string\">&quot;ariaInvalidState(registrationForm.password.pw1)&quot;</span>\n  /&gt;\n  &lt;<span class=\"hljs-keyword\">app</span>-<span class=\"hljs-keyword\">form</span>-<span class=\"hljs-keyword\">error</span> [fieldRef]=<span class=\"hljs-string\">&quot;registrationForm.password.pw1&quot;</span> /&gt;\n&lt;/<span class=\"hljs-keyword\">label</span>&gt;\n&lt;<span class=\"hljs-keyword\">label</span>\n  &gt;Password Confirmation\n  &lt;<span class=\"hljs-keyword\">input</span>\n    <span class=\"hljs-keyword\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span>\n    autocomplete\n    [field]=<span class=\"hljs-string\">&quot;registrationForm.password.pw2&quot;</span>\n    [ariaInvalid]=<span class=\"hljs-string\">&quot;ariaInvalidState(registrationForm.password.pw2)&quot;</span>\n  /&gt;\n  &lt;<span class=\"hljs-keyword\">app</span>-<span class=\"hljs-keyword\">form</span>-<span class=\"hljs-keyword\">error</span> [fieldRef]=<span class=\"hljs-string\">&quot;registrationForm.password.pw2&quot;</span> /&gt;\n&lt;/<span class=\"hljs-keyword\">label</span>&gt;\n&lt;<span class=\"hljs-keyword\">app</span>-<span class=\"hljs-keyword\">form</span>-<span class=\"hljs-keyword\">error</span> [fieldRef]=<span class=\"hljs-string\">&quot;registrationForm.password&quot;</span> /&gt;\n</code></pre>\n<p>For validations that depend on multiple fields, Signal Forms provide a <code>validateTree()</code> function.\nThe <code>ChildFieldContext</code> passed to the callback gives access to the entire subtree, allowing us to compare values of different fields.\nAn interesting aspect of this function is that we can assign errors to any field within the subtree.\nAccess to fields is possible through the <code>fieldOf()</code> method.\nWe can also use the <code>valueOf()</code> method to access values of other fields in the tree.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, validateTree } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> registrationSchema = schema&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">fieldPath</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// Password confirmation validation</span>\n  <span class=\"hljs-title function_\">validateTree</span>(fieldPath.<span class=\"hljs-property\">password</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">ctx</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> ctx.<span class=\"hljs-title function_\">value</span>().<span class=\"hljs-property\">pw2</span> === ctx.<span class=\"hljs-title function_\">value</span>().<span class=\"hljs-property\">pw1</span>\n      ? <span class=\"hljs-literal\">undefined</span>\n      : {\n          <span class=\"hljs-attr\">field</span>: ctx.<span class=\"hljs-title function_\">fieldOf</span>(fieldPath.<span class=\"hljs-property\">password</span>.<span class=\"hljs-property\">pw2</span>), <span class=\"hljs-comment\">// assign the error to the second password field</span>\n          <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">&#x27;confirmationPassword&#x27;</span>,\n          <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;The entered password must match with the one specified in &quot;Password&quot; field&#x27;</span>,\n        };\n  });\n});\n</code></pre>\n<blockquote>\n<p><code>validateTree()</code> defines custom validation logic for a group of related fields. It returns a validation error or <code>undefined</code> if the values are valid.</p>\n</blockquote>\n<h2 id=\"conditional-validation\">Conditional Validation</h2>\n<p>Validations can also be applied conditionally based on the value of other fields.\nIn our registration form, we want to allow users to choose from newsletter topics once they decided to receive a newsletter.\nTherefore, we extend our data model and the initial state first.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">RegisterFormData</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">newsletter</span>: <span class=\"hljs-built_in\">boolean</span>;\n  <span class=\"hljs-attr\">newsletterTopics</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">agreeToTermsAndConditions</span>: <span class=\"hljs-built_in\">boolean</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-title class_\">RegisterFormData</span> = {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">newsletter</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">newsletterTopics</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n  <span class=\"hljs-attr\">agreeToTermsAndConditions</span>: <span class=\"hljs-literal\">false</span>,\n};\n</code></pre>\n<p>Now, we want to ensure that a newsletter topic is selected from the list (we already named it in plural since we will add a multi-selection later, but for now just start with selecting one topic).\nHowever, this rule only applies if the user has opted in to receive the newsletter.</p>\n<p>This is where <code>applyWhen()</code> comes into play!\nThe function takes a field path as the first argument.\nSince we want to take the whole form into account, we pass the root path.\nThe callback function in the second argument takes the field context and returns a boolean indicating whether the condition is met.\nIn this example, we take a look at the value of the <code>newsletter</code> checkbox and only apply the validation if it is <code>true</code>.\nThe third argument provides the actual validation schema that should be applied when the condition is met:\nWe use the <code>validate()</code> function to check if a topic is selected.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, applyWhen } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> registrationSchema = schema&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">fieldPath</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// Only validate newsletter topics if user subscribed to newsletter</span>\n  <span class=\"hljs-title function_\">applyWhen</span>(\n    fieldPath,\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">ctx</span>) =&gt;</span> ctx.<span class=\"hljs-title function_\">value</span>().<span class=\"hljs-property\">newsletter</span>,\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">fieldPathWhenTrue</span>) =&gt;</span> {\n      <span class=\"hljs-title function_\">validate</span>(fieldPathWhenTrue.<span class=\"hljs-property\">newsletterTopics</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">ctx</span>) =&gt;</span>\n        !ctx.<span class=\"hljs-title function_\">value</span>().<span class=\"hljs-property\">length</span>\n          ? {\n              <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">&#x27;noTopicSelected&#x27;</span>,\n              <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Select at least one newsletter topic&#x27;</span>,\n            }\n          : <span class=\"hljs-literal\">undefined</span>\n      );\n    }\n  );\n});\n</code></pre>\n<blockquote>\n<p><code>applyWhen()</code> conditionally applies a validation schema based on the value of a specified field.</p>\n</blockquote>\n<h2 id=\"asynchronous-validation\">Asynchronous Validation</h2>\n<p>All previously shown validation functions were synchronous.\nHowever, we can also perform asynchronous validation, like checking username availability on the server.\nTo simulate an asynchronous server call, we extend our <code>RegistrationService</code> with a <code>checkUserExists()</code> method that returns a <code>Promise</code>.\nIf the username is <code>johndoe</code>, we consider it taken, and the operation resolves to <code>true</code>.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-meta\">@Injectable</span>({ <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationService</span> {\n  <span class=\"hljs-title function_\">checkUserExists</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">username</span>: <span class=\"hljs-built_in\">string</span></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n      <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-title function_\">resolve</span>(username === <span class=\"hljs-string\">&#x27;johndoe&#x27;</span>);\n      }, <span class=\"hljs-number\">2000</span>);\n    });\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>To perform async validation, we can use the <code>validateAsync()</code> function in our schema.\nThe <code>params</code> property allows us to pick the required data from the field state, again represented as a <code>ChildFieldContext</code> object.\nThe <code>factory</code> property is a function that creates a resource that actually performs the async operation.\nFinally, the <code>onSuccess</code> function maps the value of the resource to a validation error, just as we did before with custom synchronous validations.\nWe also have to handle errors in the asynchronous operation, which can be done using the <code>onError</code> property. If the validation fails due to a server error, we ignore it by returning <code>undefined</code>.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, resource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, validateAsync } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> registrationSchema = schema&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">fieldPath</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// Check username availability on the server</span>\n  <span class=\"hljs-title function_\">validateAsync</span>(fieldPath.<span class=\"hljs-property\">username</span>, {\n    <span class=\"hljs-comment\">// Reactive parameters for the async operation</span>\n    <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ value }</span>) =&gt;</span> <span class=\"hljs-title function_\">value</span>(),\n\n    <span class=\"hljs-comment\">// Factory creating a resource for the async call</span>\n    <span class=\"hljs-attr\">factory</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">params</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> registrationService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">RegistrationService</span>);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">resource</span>({\n        params,\n        <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-title function_\">async</span> ({ params }) =&gt; {\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> registrationService.<span class=\"hljs-title function_\">checkUserExists</span>(params);\n        },\n      });\n    },\n\n    <span class=\"hljs-comment\">// Map the result to validation errors</span>\n    <span class=\"hljs-attr\">onSuccess</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">result</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">return</span> result\n        ? {\n            <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">&#x27;userExists&#x27;</span>,\n            <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;The username you entered was already taken&#x27;</span>,\n          }\n        : <span class=\"hljs-literal\">undefined</span>;\n    },\n    <span class=\"hljs-attr\">onError</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-literal\">undefined</span>\n  });\n});\n</code></pre>\n<p>Whenever the value of the username field changes, the async validation is triggered.\nIf we enter <code>johndoe</code>, the validation will fail, and the corresponding error message will be displayed.</p>\n<blockquote>\n<p>ℹ️ <em>Resource</em> is a new building block in Angular for managing asynchronous data with signals. Learn about the Resource API in our blog post from <em>Angular.Schule</em>: <a href=\"https://angular.schule/blog/2025-05-resource-api\">Reactive Angular: Loading Data with the Resource API</a></p>\n</blockquote>\n<p>For HTTP endpoints, you can also use the simpler <code>validateHttp()</code> function:</p>\n<pre><code class=\"language-typescript\">validateHttp(fieldPath.username, {\n  <span class=\"hljs-attr\">request</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">ctx</span>) =&gt;</span> <span class=\"hljs-string\">`/api/check?username=<span class=\"hljs-subst\">${ctx.value()}</span>`</span>,\n  <span class=\"hljs-attr\">errors</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">taken: <span class=\"hljs-built_in\">boolean</span></span>) =&gt;</span>\n    taken ? ({ <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">&#x27;userExists&#x27;</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Username already taken&#x27;</span> }) : <span class=\"hljs-literal\">undefined</span>,\n});\n</code></pre>\n<p>When an asynchronous validation is in progress, the field&#39;s <code>pending</code> state is set to <code>true</code>.\nWe can use this state to provide user feedback in the UI:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span>\n  [<span class=\"hljs-attr\">field</span>]=<span class=\"hljs-string\">&quot;registrationForm.username&quot;</span>\n  [<span class=\"hljs-attr\">ariaInvalid</span>]=<span class=\"hljs-string\">&quot;ariaInvalidState(registrationForm.username)&quot;</span>\n/&gt;</span>\n@if (registrationForm.username().pending()) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">small</span>&gt;</span>Checking availability ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">small</span>&gt;</span>\n}\n<span class=\"hljs-comment\">&lt;!-- ... --&gt;</span>\n</code></pre>\n<h2 id=\"controlling-field-state\">Controlling Field State</h2>\n<p>Signal Forms also provide functions to control field behavior beyond validation.\nAll three schema functions <code>disabled</code>, <code>readonly</code> and <code>hidden</code> receive a callback that takes the field context and checks a condition.\nThe corresponding field will change its state when the condition is met.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, disabled, <span class=\"hljs-keyword\">readonly</span>, hidden } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> registrationSchema = schema&lt;<span class=\"hljs-title class_\">RegisterFormData</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">fieldPath</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// Disable newsletter topics when newsletter is unchecked</span>\n  <span class=\"hljs-title function_\">disabled</span>(fieldPath.<span class=\"hljs-property\">newsletterTopics</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">ctx</span>) =&gt;</span> !ctx.<span class=\"hljs-title function_\">valueOf</span>(fieldPath.<span class=\"hljs-property\">newsletter</span>));\n});\n</code></pre>\n<p>Here are some more examples of how to use <code>readonly</code> and <code>hidden</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-regexp\">//</span> make `<span class=\"language-javascript\">someField</span>` read-only <span class=\"hljs-keyword\">if</span> `<span class=\"language-javascript\">otherField</span>` has the value <span class=\"hljs-string\">&#x27;someValue&#x27;</span>\nreadonly(fieldPath.someField, <span class=\"hljs-function\"><span class=\"hljs-params\">(ctx)</span> =&gt;</span> ctx.valueOf(fieldPath.otherField) === <span class=\"hljs-string\">&#x27;someValue&#x27;</span>);\n\n<span class=\"hljs-regexp\">//</span> make `<span class=\"language-javascript\">someField</span>` read-only <span class=\"hljs-keyword\">if</span> `<span class=\"language-javascript\">otherField</span>` <span class=\"hljs-keyword\">is</span> invalid\nreadonly(fieldPath.someField, <span class=\"hljs-function\"><span class=\"hljs-params\">(ctx)</span> =&gt;</span> !ctx.fieldOf(fieldPath.otherField)().valid());\n\n<span class=\"hljs-regexp\">//</span> hide `<span class=\"language-javascript\">someField</span>` <span class=\"hljs-keyword\">if</span> the value <span class=\"hljs-keyword\">of</span> `<span class=\"language-javascript\">otherField</span>` <span class=\"hljs-keyword\">is</span> falsy\nhidden(fieldPath.someField, <span class=\"hljs-function\"><span class=\"hljs-params\">(ctx)</span> =&gt;</span> !ctx.valueOf(fieldPath.otherField));\n</code></pre>\n<p>Disabled and read-only states are automatically reflected in the template when using the <code>[field]</code> directive.\nHowever, Angular cannot automatically hide fields in the template.\nInstead, it marks the fields as <em>hidden</em>, which we can use in our template to conditionally render the fields using <code>@if</code>.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-title\">@if</span> (<span class=\"hljs-title\">!registrationForm.someField</span>().<span class=\"hljs-keyword\">hidden</span>()) {\n  &lt;<span class=\"hljs-type\">label</span>&gt;Some Field\n    &lt;input ... /&gt;\n  &lt;/<span class=\"hljs-type\">label</span>&gt;\n}\n</code></pre>\n<h2 id=\"handling-server-side-errors\">Handling Server-Side Errors</h2>\n<p>While client-side validation catches most errors before submission, server-side validation errors can still occur during form processing.\nSignal Forms provide an elegant way to handle these errors and display them to users with proper field-level feedback.\nWhen using the <code>submit()</code> function, we can return an array of validation errors from the submission callback to assign them to specific fields or to the form itself.</p>\n<p>The helper type <code>WithField</code> ensures that each error contains a reference to the field it belongs to.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-comment\">/* ... */</span>, <span class=\"hljs-title class_\">WithField</span>, <span class=\"hljs-title class_\">ValidationErrorWithField</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RegistrationForm</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">submitForm</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">e</span>: <span class=\"hljs-title class_\">Event</span></span>) {\n    e.<span class=\"hljs-title function_\">preventDefault</span>();\n\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">submit</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">registrationForm</span>, <span class=\"hljs-title function_\">async</span> (form) =&gt; {\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">errors</span>: <span class=\"hljs-title class_\">ValidationErrorWithField</span>[] = [];\n\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.#registrationService.<span class=\"hljs-title function_\">registerUser</span>(<span class=\"hljs-title function_\">form</span>().<span class=\"hljs-property\">value</span>);\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Registration successful!&#x27;</span>);\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">reset</span>();\n      } <span class=\"hljs-keyword\">catch</span> (e) {\n        <span class=\"hljs-comment\">// Add server-side errors</span>\n        errors.<span class=\"hljs-title function_\">push</span>(\n          {\n            <span class=\"hljs-attr\">field</span>: form, <span class=\"hljs-comment\">// form-level error</span>\n            <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">&#x27;serverError&#x27;</span>,\n            <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Registration failed. Please try again.&#x27;</span>,\n          }\n        );\n\n        <span class=\"hljs-comment\">// Or assign to specific field</span>\n        errors.<span class=\"hljs-title function_\">push</span>(\n          {\n            <span class=\"hljs-attr\">field</span>: form.<span class=\"hljs-property\">username</span>,\n            <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">&#x27;serverValidation&#x27;</span>,\n            <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Username is not available.&#x27;</span>,\n          }\n        );\n      }\n\n      <span class=\"hljs-keyword\">return</span> errors;\n    });\n  }\n}\n</code></pre>\n<h2 id=\"demo\">Demo</h2>\n<p>You can find a complete demo application for this blog series on GitHub and Stackblitz:</p>\n<ul>\n<li><strong>⚡️ Stackblitz:</strong> <a href=\"https://stackblitz.com/github/angular-buch/signal-forms-registration\">https://stackblitz.com/github/angular-buch/signal-forms-registration</a></li>\n<li><strong>⚙️ Code on GitHub:</strong> <a href=\"https://github.com/angular-buch/signal-forms-registration\">https://github.com/angular-buch/signal-forms-registration</a></li>\n<li><strong>💻 Live Demo:</strong> <a href=\"https://angular-buch.github.io/signal-forms-registration/\">https://angular-buch.github.io/signal-forms-registration/</a></li>\n</ul>\n<h2 id=\"whats-next\">What&#39;s Next?</h2>\n<p>In this second part, we&#39;ve explored advanced validation techniques and schema patterns in Signal Forms, including:</p>\n<ul>\n<li>Custom validation functions with <code>validate()</code></li>\n<li>Cross-field validation with <code>validateTree()</code></li>\n<li>Conditional validation with <code>applyWhen()</code></li>\n<li>Asynchronous validation with <code>validateAsync()</code> and <code>validateHttp()</code></li>\n<li>Field state control with <code>disabled()</code>, <code>readonly()</code>, and <code>hidden()</code></li>\n<li>Server-side error handling</li>\n</ul>\n<p>In <strong>Part 3</strong>, we&#39;ll cover specialized topics that help you build complex, modular forms:</p>\n<ul>\n<li>Creating reusable child form components</li>\n<li>Building custom UI controls that integrate seamlessly with Signal Forms</li>\n</ul>\n<p>Ready for the final part? Check out <a href=\"/blog/2025-10-signal-forms-part3\">Part 3: Child Forms and Custom UI Controls</a>!</p>\n<p><small><strong>Cover image:</strong> Picture from <a href=\"https://pixabay.com/photos/journal-write-blank-pages-notes-2850091/\">Pixabay</a>, edited</small></p>\n","meta":{"title":"Angular Signal Forms Part 2: Advanced Validation and Schema Patterns","author":"Danny Koppenhagen and Ferdinand Malcher","mail":"dannyferdigravatar@fmalcher.de","published":"2025-10-15T00:00:00.000Z","lastModified":"2025-10-30T00:00:00.000Z","keywords":["Angular","Signals","Forms","Angular 21","Signal Forms","Validation","Schema Validation"],"language":"en","header":{"url":"header-signalforms-part2.jpg","width":2000,"height":1133},"sticky":false}}
