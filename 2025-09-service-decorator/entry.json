{"slug":"2025-09-service-decorator","html":"<p>Mit Angular 20 entf√§llt der Service-Suffix im neuen Style Guide.\nDas sorgt zwar f√ºr k√ºrzere Dateinamen, macht aber die Rolle der Klassen weniger offensichtlich.\nDieser Artikel zeigt ein <strong>Gedankenexperiment</strong>, bei dem ein eigener <code>@Service</code>-Decorator dieses Problem elegant l√∂st.</p>\n<h2 id=\"angular-20-der-service-suffix-ist-weg\">Angular 20: Der Service-Suffix ist weg</h2>\n<p>Die neue Major-Version von Angular bringt einige tiefgreifende Ver√§nderungen mit sich.\nSo wurde der neue <a href=\"https://angular.dev/style-guide\">Angular coding style guide</a> f√ºr v20 stark √ºberarbeitet und verschlankt.\nEs wird <em>nicht</em> mehr empfohlen, Komponenten, Services und Direktiven mit einem Suffix zu versehen.</p>\n<p>Der Befehl <code>ng generate service book-store</code> generiert demnach nicht mehr eine Klasse mit dem Namen <code>BookStoreService</code>, sondern vergibt nur noch den Namen <code>BookStore</code>.\nFolgerichtig wird aus <code>book-store.service.ts</code> nun einfach nur <code>book-store.ts</code>.</p>\n<p>Das ist prinzipiell eine tolle Sache.\nWir erhalten k√ºrzere Dateinamen und mehr Fokus auf bewusste Benennung.\nAber einen kleinen Nachteil hat das Ganze:\nWir erkennen nicht mehr auf den ersten Blick, dass eine Klasse als Service genutzt werden soll.</p>\n<p><strong>bis Angular 19:</strong></p>\n<pre><code class=\"language-ts\">// book-store.service.ts\n\n<span class=\"hljs-variable\">@Injectable</span>({\n  providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span>\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStoreService</span> </span>{ }\n</code></pre>\n<p><strong>ab Angular 20:</strong></p>\n<pre><code class=\"language-ts\">// book-store.ts\n\n<span class=\"hljs-variable\">@Injectable</span>({\n  providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span>\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> </span>{ }\n</code></pre>\n<p>Wer Angular bereits l√§nger nutzt, wei√ü, dass der <code>@Injectable</code>-Decorator fast immer einen Service kennzeichnet.\nDennoch k√∂nnte der Einsatzzweck dieses Decorators meiner Meinung nach noch klarer kommuniziert werden.</p>\n<p>In dem bekannten Java-Framework Spring Boot ist <code>@Service</code> eine g√§ngige Annotation, welche verdeutlicht, dass eine Klasse Service-Logik enth√§lt:</p>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Service;\n\n<span class=\"hljs-variable\">@Service</span>\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStoreService</span> </span>{\n    // ...\n}\n</code></pre>\n<p>Zus√§tzlich gibt es noch weitere Annotationen wie <code>@Repository</code>. \nIn Spring besitzt <code>@Repository</code> exakt dieselbe Funktionalit√§t wie <code>@Service</code>. \nDer einzige Unterschied ist, dass <code>@Repository</code> zus√§tzlich signalisiert, dass diese Klasse das Repository-Pattern implementiert. \nIch pers√∂nlich finde es sehr charmant, wenn der Einsatzzweck einer Klasse m√∂glichst eindeutig erkennbar ist.</p>\n<h2 id=\"die-motivation--mein-service-decorator-f√ºr-angular\">Die Motivation ‚Äì Mein <code>@Service()</code>-Decorator f√ºr Angular</h2>\n<p>Was tun wir also, wenn wir auf das altbekannte <code>Service</code>-Suffix verzichten wollen\nund trotzdem noch deutlich machen m√∂chten, dass eine Klasse ein Service ist?</p>\n<p>Mein Gedanke dazu: Warum f√ºhren wir nicht einfach einen eigenen Decorator namens <code>@Service()</code> ein?\nDann w√§re direkt durch den Decorator ersichtlich, dass es sich bei der Klasse um einen Service handelt.\nUnd weil wir schon mal dabei sind, sparen wir uns auch gleich noch das immer gleiche <code>providedIn: &#39;root&#39;</code>.</p>\n<p>Wenn ich mir also eine √Ñnderung am Angular-Framework w√ºnschen k√∂nnte,\ndann w√§re es vielleicht folgende neue Syntax:</p>\n<pre><code class=\"language-ts\">// book-store.ts\n\n<span class=\"hljs-variable\">@Service</span>()\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> </span>{ }\n</code></pre>\n<p>Folgende Verbesserungen stelle ich mir konkret vor:</p>\n<ol>\n<li>Wir verzichten weiterhin auf das Suffix <code>Service</code>.</li>\n<li>Wir m√ºssen nicht mehr bei jedem Service erneut <code>providedIn: &#39;root&#39;</code> schreiben. Das hat mich schon immer gest√∂rt.</li>\n</ol>\n<h2 id=\"das-ziel-kompakter-klarer-und-weniger-boilerplate-code\">Das Ziel: Kompakter, klarer und weniger Boilerplate-Code</h2>\n<p>Mein Ziel ist demnach ein eleganterer Decorator, der:</p>\n<ul>\n<li>auf einen Blick klarstellt, dass es sich bei der Klasse um einen Service handelt,</li>\n<li>automatisch die Bereitstellung im Root-Injector √ºbernimmt (<code>providedIn: &#39;root&#39;</code>),</li>\n<li>vollst√§ndig kompatibel mit dem AOT-Compiler und Ivy ist.</li>\n</ul>\n<p>Um es kurz zu sagen: Ein Decorator, der eine m√∂glichst kompakte Syntax hat mir pers√∂nlich Freude bereitet. üòá</p>\n<h2 id=\"welche-ans√§tze-gibt-es-√ºberhaupt\">Welche Ans√§tze gibt es √ºberhaupt?</h2>\n<p>Die Entwicklung eines solchen eigenen Decorators ist leider nicht komplett trivial, vor allem, da Angular intern sehr genau festlegt, wie DI funktioniert.\nSchauen wir uns ein paar m√∂gliche Ans√§tze gemeinsam an:</p>\n<h2 id=\"idee-1-vererbung-von-injectable\">Idee 1: Vererbung von <code>@Injectable</code></h2>\n<p>Ein logischer Gedanke w√§re, eine Basisklasse mit <code>@Injectable()</code> zu annotieren und Services daraus abzuleiten:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable</span>({ \n  providedIn: &#x27;root&#x27; \n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseService</span> </span>{}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseService</span> </span>{}\n</code></pre>\n<p>Das funktioniert allerdings nicht, da Angular die Metadaten zur Compile-Zeit direkt an der Zielklasse speichert.\nDiese Metadaten werden leider nicht vererbt.\nDas Framework findet den Service einfach nicht, und wir erhalten die folgende Fehlermeldung zur Laufzeit:</p>\n<blockquote>\n<p><strong>‚ùå Fehlermeldung:</strong> NullInjectorError: No provider for BookStore!</p>\n</blockquote>\n<p>Abgesehen davon, dass diese L√∂sung technisch nicht funktioniert, erf√ºllt sie auch nicht unser Ziel, einen echten Decorator zu erstellen.\nZiel verfehlt!</p>\n<h2 id=\"idee-2-eigener-decorator-der-injectable-wrappt\">Idee 2: Eigener Decorator, der <code>@Injectable</code> wrappt</h2>\n<p>Eine zweite Idee w√§re es, einen einfachen Wrapper zu erstellen:</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Service</span>(): ClassDecorator {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Injectable({</span> providedIn: <span class=\"hljs-symbol\">&#x27;root</span>&#x27; });\n}\n</code></pre>\n<p>Auch dieser Code l√§sst sich kompilieren, doch sobald wir den entsprechend dekorierten Service per DI anfordern wollen, erhalten wir diese Fehlermeldung zur Laufzeit:</p>\n<blockquote>\n<p><strong>‚ùå Fehlermeldung:</strong> The injectable &#39;BookStore2&#39; needs to be compiled using the JIT compiler, but &#39;@angular/compiler&#39; is not available.\nJIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\nAlternatively, the JIT compiler should be loaded by bootstrapping using &#39;@angular/platform-browser-dynamic&#39; or &#39;@angular/platform-server&#39;,\n  or manually provide the compiler with &#39;import &quot;@angular/compiler&quot;;&#39; before bootstrapping.</p>\n</blockquote>\n<p>Um diese Fehlermeldung besser zu verstehen, ben√∂tigen wir etwas Hintergrundwissen zu den Begriffen &quot;AOT&quot; und &quot;JIT&quot;, die schnell erl√§utert sind:\nAngular kennt zwei Arten der Kompilierung: den <strong>JIT-Modus (Just-in-Time)</strong> und den <strong>AOT-Modus (Ahead-of-Time)</strong>. \nIm JIT-Modus kompiliert Angular Komponenten und Decorators erst w√§hrend der Laufzeit direkt im Browser.\nDies ist zwar flexibel, aber vergleichsweise langsam und wird daher in Produktionsumgebungen nicht empfohlen.\nIm Gegensatz dazu findet im AOT-Modus die Kompilierung schon w√§hrend des Build-Vorgangs statt.\nDies sorgt f√ºr deutlich bessere Performance und reduzierte Bundle-Gr√∂√üen.\nSeit Einf√ºhrung der Ivy-Engine (ab Angular 9) ist AOT der Standard-Modus, und wir m√ºssen uns als Entwickler normalerweise nicht mehr aktiv mit dem Thema auseinandersetzen.\nDeshalb ist es wichtig, dass unsere Decorators vollst√§ndig AOT-kompatibel sind ‚Äì was hier leider nicht gegeben ist.</p>\n<p>Fazit: Diese Variante funktioniert leider nur im JIT-Modus und wird vom AOT-Compiler leider nicht unterst√ºtzt.</p>\n<h2 id=\"idee-3-nutzung-interner-angular-ivy-apis\">Idee 3: Nutzung interner Angular-Ivy-APIs</h2>\n<p>Die bisherigen Ans√§tze haben nicht funktioniert. Jetzt schauen wir uns die internen Ivy-APIs an.\nDas sind Mechanismen, die Angular selbst zur Bereitstellung von Services nutzt. \n<strong>Wichtig: An dieser Stelle bewegen wir uns bewusst auf experimentelles Terrain!</strong> \nWir greifen auf eine intern genutzte, aber nicht offiziell bereitgestellte Angular-API zur√ºck.\nDieser Ansatz eignet sich daher eher als Experiment denn als Empfehlung f√ºr produktiven Code.</p>\n<p>Die zentrale interne API, die f√ºr uns interessant ist, hei√üt <a href=\"https://github.com/angular/angular/blob/a40abf09f1abcabda3752ed915bb90e4eafe078d/packages/core/src/di/interface/defs.ts#L167\"><code>…µ…µdefineInjectable</code></a>.\nDiese Funktion erstellt f√ºr eine Klasse die n√∂tigen Metadaten, sodass Angular sie automatisch injizieren kann.\nIm verlinkten Code finden sich auch Hinweise zur Verwendung: (<strong>This should be assigned to a static <code>…µprov</code> field on a type, which will then be an <code>InjectableType</code>.</strong>)</p>\n<h3 id=\"minimalversion-ohne-konstruktor-injection\">Minimalversion ohne Konstruktor-Injection</h3>\n<p>Beginnen wir mit einem minimalistischen Ansatz, der sehr einfach ist, aber auch eine klare Einschr√§nkung mit sich bringt:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { …µ…µdefineInjectable } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Service</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title function_\">ClassDecorator</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">target: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n    Object.defineProperty(target, <span class=\"hljs-string\">&#x27;…µprov&#x27;</span>, {\n      <span class=\"hljs-attr\">value</span>: …µ…µdefineInjectable({\n        <span class=\"hljs-attr\">token</span>: target,\n        <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,\n        <span class=\"hljs-attr\">factory</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> target()\n      })\n    });\n  };\n}\n</code></pre>\n<p>Was macht dieser Code?</p>\n<ul>\n<li>Wir erzeugen mit <code>…µ…µdefineInjectable</code> eine &quot;injectable definition&quot; und setzen diese direkt als neues Property an das <code>target</code>.</li>\n<li>Die Einstellung <code>providedIn: &#39;root&#39;</code> sorgt daf√ºr, dass der Service global verf√ºgbar ist, ohne dass wir das immer wiederholen m√ºssen.</li>\n<li>Die Factory-Funktion erzeugt einfach eine neue Instanz der Klasse ‚Äì <strong>aber ohne Konstruktor-Abh√§ngigkeiten</strong>.</li>\n</ul>\n<p>Der gro√üe Vorteil dieses Ansatzes ist seine Einfachheit. \nAllerdings wissen wir zur Laufzeit schlicht nicht, welche Abh√§ngigkeiten der Konstruktor erwartet. \nWir haben den Konstruktor daher notgedrungen ohne Argumente aufgerufen.\nDer gro√üe Nachteil besteht somit darin, dass generische Konstruktor-Injection nicht m√∂glich ist.</p>\n<p>Das folgende Beispiel macht dies deutlich.\nWir erwarten, das der Service <code>BookRating</code> per Konstruktor-Injection verf√ºgbar gemacht wird.\nStattdessen ist der Wert aber einfach nur <code>undefined</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Service</span>()\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> </span>{\n\n  constructor(br: BookRating) {\n    console.log(br) // undefined\n  }\n}\n</code></pre>\n<p>Diese Variante eignet sich also ausschlie√ülich f√ºr Services ohne Konstruktor-Abh√§ngigkeiten.\nDoch Angular stellt inzwischen eine neue Funktion bereit, die uns auch in solchen F√§llen weiterhilft.\nWie diese genau funktioniert, schauen wir uns gleich n√§her an!</p>\n<h3 id=\"gregors-variante-konstruktor-injection-mit-expliziten-abh√§ngigkeiten\">Gregors Variante: Konstruktor-Injection mit expliziten Abh√§ngigkeiten</h3>\n<p>An dieser Stelle habe ich bei meinen Recherchen festgestellt, dass mein gesch√§tzter GDE-Kollege Gregor Woiwode sich bereits vor 5 Jahren mit dem Thema besch√§ftigt hat.\n<a href=\"https://stackoverflow.com/a/59759381\">Seine L√∂sung</a> hat er auf StackOverflow vorgestellt.\nSein Decorator hei√üt <code>@InjectableEnhanced</code> und hat prinzipiell die gleiche Zielsetzung wie dieser Artikel.</p>\n<p>Gregor hat bereits damals demonstriert, wie man die fehlende Konstruktor-Injection nachbilden kann. \nDabei nutzt er ebenfalls dieselbe API wie zuvor, definiert aber explizit alle Abh√§ngigkeiten innerhalb der Factory-Funktion:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Gregor&#x27;s Code, minimal abgewandelt:</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">InjectableEnhanced</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> &lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title function_\">new</span> (...<span class=\"hljs-attr\">args</span>: <span class=\"hljs-built_in\">any</span>[]) =&gt; <span class=\"hljs-title class_\">InstanceType</span>&lt;T&gt;&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">target</span>: T</span>) =&gt;</span> {\n    (target <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).…µfac = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;cannot create directly&quot;</span>);\n    };\n\n    (target <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).…µprov = …µ…µ<span class=\"hljs-title function_\">defineInjectable</span>({\n      <span class=\"hljs-attr\">token</span>: target,\n      <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&quot;root&quot;</span>,\n      <span class=\"hljs-title function_\">factory</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-comment\">// …µ…µinject can be used to get dependency being already registered</span>\n        <span class=\"hljs-keyword\">const</span> dependency = …µ…µ<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookRating</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">target</span>(dependency);\n      }\n    });\n    <span class=\"hljs-keyword\">return</span> target;\n  };\n}\n\n<span class=\"hljs-meta\">@InjectableEnhanced</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">br</span>: <span class=\"hljs-title class_\">BookRating</span></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(br) <span class=\"hljs-comment\">// works! ü•≥</span>\n  }\n}\n</code></pre>\n<p>Was passiert hier genau?</p>\n<ul>\n<li>Der Code von Gregor definiert nicht nur <code>…µprov</code>, sondern explizit auch <code>…µfac</code> (die Factory), die normalerweise automatisch vom Angular-Compiler erzeugt wird. \nEr verhindert zudem, dass jemand die Klasse direkt instanziieren kann. Der Code verhindert dies mit einer fr√ºhen Exception.\nWer Bedenken hat, dass jemand die dekorierten Service manuell instanziiert, kann diese Pr√ºfung gerne beibehalten.</li>\n<li>Innerhalb der Factory-Funktion injiziert der Code explizit jede Abh√§ngigkeit einzeln mittels <code>…µ…µinject</code>. \nIn diesem Fall handelt es sich um unseren Service <code>BookRating</code>.\nDadurch unterst√ºtzt er direkte Konstruktor-Injection.</li>\n<li>Aber Achtung: Wir m√ºssen jede Abh√§ngigkeit einzeln und explizit in der Factory-Funktion angeben!\nDas ist aufw√§ndig und anf√§llig f√ºr Fehler, falls sich die Konstruktorparameter √§ndern.</li>\n</ul>\n<p>Der Code l√§sst sich auch so umschreiben, sodass er dem vorherigen Beispiel entspricht.\nStatt der direkten Zuweisung <code>((target as any).…µprov)</code>, w√ºrde ich eher <code>Object.defineProperty() </code> verwenden.\nDieser Stil ist zwar etwas ausf√ºhrlicher, daf√ºr umgehen wir aber nicht mehr das Typsystem per Type Assertion auf <code>any</code>.\nDie Fehlermeldung habe ich dabei auch weggelassen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Gregors Code, gek√ºrzt und angepasst:</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Service</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">ClassDecorator</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">target</span>: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, <span class=\"hljs-string\">&#x27;…µprov&#x27;</span>, {\n      <span class=\"hljs-attr\">value</span>: …µ…µ<span class=\"hljs-title function_\">defineInjectable</span>({\n        <span class=\"hljs-attr\">token</span>: target,\n        <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,\n        <span class=\"hljs-attr\">factory</span>: <span class=\"hljs-function\">() =&gt;</span> {\n          <span class=\"hljs-comment\">// …µ…µinject can be used to get dependency being already registered</span>\n          <span class=\"hljs-keyword\">const</span> dependency = …µ…µ<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookRating</span>);\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">target</span>(dependency);\n        }\n      })\n    });\n  };\n}\n\n<span class=\"hljs-meta\">@Service</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">br</span>: <span class=\"hljs-title class_\">BookRating</span></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(br) <span class=\"hljs-comment\">// still works ü•≥</span>\n  }\n}\n</code></pre>\n<p>Dieser Ansatz ist technisch geschickt gel√∂st, hat aber eine klare Einschr√§nkung: \nEr ist nicht generisch genug f√ºr alle F√§lle.\nF√ºr jeden einzelnen Service m√ºssen wir manuell die Abh√§ngigkeiten auflisten.\nGregors alte L√∂sung funktioniert somit immer noch perfekt f√ºr spezielle F√§lle mit wenigen oder immer denselben Abh√§ngigkeiten.</p>\n<h2 id=\"idee-4-automatische-dependency-aufl√∂sung-mit-reflect-metadata\">Idee 4: Automatische Dependency-Aufl√∂sung mit reflect-metadata</h2>\n<p>Um Konstruktor-Injectionen ohne manuelle Angabe von Abh√§ngigkeiten zu erm√∂glichen, \nk√∂nnten wir die Bibliothek <a href=\"https://www.npmjs.com/package/reflect-metadata\">reflect-metadata</a> nutzen. \nDies erfordert die Aktivierung von <code>emitDecoratorMetadata: true</code> in der <code>tsconfig.json</code> und die Einbindung von <code>reflect-metadata</code> als zus√§tzliche Abh√§ngigkeit.</p>\n<p>In fr√ºheren Angular-Versionen war <code>reflect-metadata</code> oft notwendig, da der JIT-Compiler Metadaten zur Laufzeit auswertete. \nMit Ivy (ab Angular 9) und AOT-Compilation generiert Angular statische Metadaten w√§hrend der Build-Zeit, \nwodurch <code>reflect-metadata</code> in Produktionsumgebungen meist √ºberfl√ºssig ist. </p>\n<p>Die Verwendung dieser Bibliothek erh√∂ht unn√∂tig die Bundle-Gr√∂√üe, was moderne Angular-Projekte vermeiden sollten.\nIch habe diesen Ansatz daher nicht weiter verfolgt, <code>reflect-metadata</code> m√∂chte ich nicht wieder als Abh√§ngigkeit in meinem Projekt sehen. </p>\n<h2 id=\"idee-5-die-finale-idee-dependency-injection-mit-inject\">Idee 5: Die finale Idee: Dependency Injection mit <code>inject()</code></h2>\n<p>K√∂nnen wir es nicht einfacher haben, und zwar ohne jegliche manuelle Angabe der Konstruktor-Abh√§ngigkeiten?\nGenau an dieser Stelle kommt die neue Angular-Funktion <code>inject()</code> ins Spiel (die es 2020 noch nicht gab).</p>\n<p>Mit <code>inject()</code> lassen sich Abh√§ngigkeiten direkt innerhalb der Klassendefinition beziehen, ohne sie √ºber den Konstruktor zu injizieren. \nDadurch entfallen all unsere bisherigen Probleme:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// derselbe Code erneut, aus dem vorherigen Beispiel von Idee 3</span>\n<span class=\"hljs-keyword\">import</span> { …µ…µdefineInjectable } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Service</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title function_\">ClassDecorator</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">target: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n    Object.defineProperty(target, <span class=\"hljs-string\">&#x27;…µprov&#x27;</span>, {\n      <span class=\"hljs-attr\">value</span>: …µ…µdefineInjectable({\n        <span class=\"hljs-attr\">token</span>: target,\n        <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,\n        <span class=\"hljs-attr\">factory</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> target(), <span class=\"hljs-comment\">// keine Parameter n√∂tig!</span>\n      }),\n    });\n  };\n}\n</code></pre>\n<p>So sieht die Verwendung dann aus:</p>\n<pre><code class=\"language-ts\">\n<span class=\"hljs-variable\">@Service</span>()\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> </span>{\n\n  <span class=\"hljs-comment\">#service = inject(BookRating); // Abh√§ngigkeit direkt injiziert</span>\n}\n</code></pre>\n<p>Hier ein weiteres Beispiel:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpClient</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Service</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./service&#x27;</span>;\n\n<span class=\"hljs-meta\">@Service</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n  #http = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">HttpClient</span>); <span class=\"hljs-comment\">// yay! ü•≥</span>\n\n  <span class=\"hljs-title function_\">getAll</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.#http.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;/api/books&#x27;</span>);\n  }\n}\n</code></pre>\n<p>Klingt doch elegant - zumindest f√ºr unser kleines Experiment!</p>\n<h3 id=\"fazit-und-abschlie√üende-gedanken\">Fazit und abschlie√üende Gedanken</h3>\n<p>Wir haben nun mehrere Varianten f√ºr einen eigenen <code>@Service()</code>-Decorator betrachtet und dabei folgende M√∂glichkeiten kennengelernt:</p>\n<ol>\n<li><p><strong>Minimalversion ohne Konstruktor-Injection:</strong>\nEin einfacher Ansatz, aber f√ºr viele reale Situationen zu stark eingeschr√§nkt.</p>\n</li>\n<li><p><strong>Gregors Variante aus dem Jahr 2020 mit expliziter Konstruktor-Injection:</strong>\nTechnisch interessant und zeigt deutlich, wie Dependency Injection unter Ivy funktioniert. \nIn der Praxis ist dieser Ansatz allerdings nur f√ºr spezielle F√§lle geeignet, da jede Abh√§ngigkeit einzeln aufgef√ºhrt werden muss. \nDas macht den Ansatz weniger wartbar.</p>\n</li>\n<li><p><strong>Automatische Dependency-Aufl√∂sung via <code>reflect-metadata</code>:</strong>\nBequem und generisch, aber die zus√§tzliche Abh√§ngigkeit von <code>reflect-metadata</code> erh√∂ht unn√∂tig die Bundle-Gr√∂√üe und passt nicht mehr in moderne Ivy-basierte Angular-Projekte.</p>\n</li>\n<li><p><strong>Moderner Ansatz: Dependency Injection mit <code>inject()</code>:</strong>\nDieser Ansatz nutzt die M√∂glichkeiten der neuen Angular-API <code>inject()</code>. \nKonstruktor-Injection ist dabei weiterhin nicht m√∂glich, wird aber auch nicht mehr zwingend ben√∂tigt. \nDiese finale Idee mit dem Einsatz von <code>inject()</code> gef√§llt mir pers√∂nlich gut.</p>\n</li>\n</ol>\n<p>Aber sollten wir diesen Decorator nun wirklich einsetzen?</p>\n<p>Letztlich ist dieser Decorator, wie eingangs erw√§hnt, ein <strong>Gedankenexperiment</strong>.\nEs ist spannend und lehrreich, interne Angular-APIs auf diese Weise zu erkunden, jedoch sollten wir im produktiven Kontext Vorsicht walten lassen:</p>\n<ul>\n<li><p><strong>Nutzung interner APIs:</strong>\nDie verwendeten Ivy-APIs (<code>…µ…µdefineInjectable</code>, <code>…µ…µinject</code>) sind nicht offiziell dokumentiert und k√∂nnten sich in zuk√ºnftigen Angular-Versionen √§ndern. \nDies birgt ein erhebliches Risiko, dass der Code irgendwann nicht mehr funktioniert oder aufw√§ndig angepasst werden muss.</p>\n</li>\n<li><p><strong>Wartbarkeit und Verst√§ndnis im Team:</strong>\nEin selbst geschriebener Decorator wirkt vielleicht zun√§chst elegant, doch jedes neue Teammitglied m√ºsste erst lernen, warum im Projekt ein &quot;magischer&quot; Decorator verwendet wird und wie genau dieser funktioniert.</p>\n</li>\n<li><p><strong>Geringer Mehrwert vs. Risiko:</strong>\nDer einzige Gewinn dieses Decorators ist eine leichte Verbesserung der Lesbarkeit und minimal weniger Boilerplate-Code.\nDemgegen√ºber steht jedoch das erw√§hnte Risiko und der Aufwand zur Pflege.</p>\n</li>\n</ul>\n<p>Aus diesen Gr√ºnden w√ºrde ich in produktivem Angular-Code wahrscheinlich weiterhin den bew√§hrten <code>@Injectable()</code>-Decorator einsetzen.\nDie offizielle Angular-API garantiert uns Stabilit√§t, Wartbarkeit und Zukunftssicherheit.</p>\n<p><strong>Was meinst du dazu?</strong></p>\n<p>Wie findest du diesen experimentellen <code>@Service()</code>-Decorator?\nW√ºrdest du ein solches Konstrukt dennoch einmal ausprobieren, oder bleibst du wie ich lieber beim bew√§hrten <code>@Injectable()</code>? ‚Ä¶oder sollte ich doch alles auf <code>@Service()</code> umstellen? üòÖ</p>\n<p>Ich freue mich auf dein Feedback auf X oder BlueSky! üòä</p>\n<hr>\n\n<p><small>Vielen Dank an Danny Koppenhagen f√ºr das Review und das wertvolle Feedback!</small></p>\n","meta":{"title":"Mein experimenteller @Service()-Decorator f√ºr Angular","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2025-09-30T00:00:00.000Z","lastModified":"2025-09-30T00:00:00.000Z","keywords":["Angular","Angular 20","Component Suffix","Decorator","inject","Ivy","…µ…µdefineInjectable","…µ…µinject"],"language":"de","header":{"url":"service.jpg","width":2473,"height":1411}}}
