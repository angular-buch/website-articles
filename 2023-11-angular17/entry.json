{"slug":"2023-11-angular17","html":"<p>Es ist wieder ein halbes Jahr vorbei: Anfang November 2023 erschien die neue Major-Version <strong>Angular 17</strong>!\nAngular-Teammitglied Minko Gechev hatte diese Version schon vor einigen Wochen als sein <a href=\"https://twitter.com/mgechev/status/1681375250335039488\">&quot;favorite Angular release … ever&quot;</a> beschrieben.</p>\n<p>Auch wir sind der Meinung: Die Community wurde nicht enttäuscht! Die wichtigsten Neuigkeiten zu Angular 17 fassen wir in diesem Blogpost zusammen.\nIm offiziellen <a href=\"https://blog.angular.io/introducing-angular-v17-4d7033312e4b\">Angular-Blog</a> finden Sie alle Informationen des Angular-Teams.\nAußerdem empfehlen wir Ihnen einen Blick in die Changelogs von <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/main/CHANGELOG.md\">Angular CLI</a>.</p>\n<h2 id=\"angulardev-das-neue-gesicht-von-angular\">angular.dev: Das neue Gesicht von Angular</h2>\n<p>Angular hat ein neues Logo! Seit 6. November erstrahlt das große A unseres Lieblingsframeworks mit einem modernen Farbverlauf.\nDie viel größere Neuigkeit verbirgt sich aber hinter der neuen Domain <strong><a href=\"https://angular.dev\">angular.dev</a></strong>: Hier finden Sie ab sofort die neue Landingpage und Dokumentation von Angular.\nDie Inhalte wurden vollständig überarbeitet, um vor allem den Einstieg in das Framework zu vereinfachen.\nDie Dokumentation setzt zum großen Teil auf die neuen Konzepte wie Signals und den neuen Control Flow mit der <code>@</code>-Syntax.</p>\n<p>Die offizielle Ankündigung des Angular-Teams finden Sie im <a href=\"https://blog.angular.io/announcing-angular-dev-1e1205fa3039\">Angular-Blog</a>.</p>\n<h3 id=\"angular-im-wandel-der-zeit\">Angular im Wandel der Zeit</h3>\n<p>Das bisherige Angular-Logo ist weithin bekannt: Das weiße A auf einem roten Schild ist <em>das</em> Identifikationsmerkmal von Angular.\nGleichzeitig schaut das Logo auf eine lange Geschichte zurück: Die erste Version wurde ab 2012 mit dem Vorgänger-Framework &quot;AngularJS&quot; bekannt.\nIm September 2016 wurde das neue Framework &quot;Angular&quot; veröffentlicht, das eine vollständige Neuentwicklung war – Name und Logo blieben jedoch grundlegend erhalten.</p>\n<p>In den letzten Jahren hat Angular eine starke Entwicklung vollzogen. Standalone Components, Signals, Control Flow, die Funktion <code>inject()</code>, funktionale Guards/Interceptoren und Typed Reactive Forms sind nur eine Auswahl der neuen Strömungen.\nGelegentlich hören wir das Feedback, Angular sei &quot;tot&quot; oder werde &quot;nicht mehr weiterentwickelt&quot;.\nDoch das Gegenteil ist der Fall: Angular wird allein innerhalb des Konzerns Google in über 1.200 Anwendungen produktiv eingesetzt. Es ist eins der führenden Frameworks, um Webanwendungen für den Enterprise-Bereich zu entwickeln und kann auf einer Stufe mit anderen großen Frameworks wie Vue.js oder React stehen.</p>\n<p>Um diesen frischen Wind nicht nur auf technischer Ebene sichtbar zu machen, präsentiert sich Angular seit Version 17 mit einem neuen Logo und einem neuen Portal für Entwicklerinnen und Entwickler.\nSeit Version 2.0 im September 2016 hat sich in Angular viel getan – und wir freuen uns, dass dieser &quot;Renaissance&quot; nun ein neues Gesicht verliehen wurde.</p>\n<div style=\"margin: auto\">\n  <img src=\"https://website-articles.angular-buch.com/2023-11-angular17/logo-history.png\" alt=\"Geschichte des Logos\">\n  <p><small>Das Angular-Logo im Wandel der Zeiten: AngularJS (2012), Angular (2016), Angular (2023)</small></p>\n</div>\n\n\n\n<h2 id=\"projekt-updaten\">Projekt updaten</h2>\n<p>Wenn Sie mit unserem Angular-Buch das Beispielprojekt <em>BookMonkey</em> entwickeln, sind keine Anpassungen am Code notwendig.\nDie Inhalte des Buchs sind auch mit Angular 17 noch aktuell.</p>\n<p>Um ein existierendes Projekt zu aktualisieren, nutzen Sie bitte den <a href=\"https://update.angular.io/?v=16.0-17.0\">Angular Update Guide</a>.\nDer Befehl <code>ng update</code> liefert außerdem Informationen zu möglichen Updates direkt im Projekt.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Projekt auf Angular 17 aktualisieren</span>\nng update <span class=\"hljs-variable\">@angular</span>/core<span class=\"hljs-variable\">@17</span> <span class=\"hljs-variable\">@angular</span>/cli<span class=\"hljs-variable\">@1</span>7\n</code></pre>\n<p>Dadurch werden nicht nur die Pakete aktualisiert, sondern auch notwendige Migrationen im Code durchgeführt.\nPrüfen Sie danach am Besten mithilfe der Differenzansicht von Git die Änderungen.</p>\n<p>Unabhängig von den Inhalten unseres Buchs besteht grundsätzlich immer die Möglichkeit, die neuen Features von Angular auch im <em>BookMonkey</em> zu nutzen.\nProbieren Sie doch zum Beispiel einmal den neuen Control Flow aus – dazu gleich mehr!</p>\n<h2 id=\"unterstützte-versionen-von-typescript-und-nodejs\">Unterstützte Versionen von TypeScript und Node.js</h2>\n<p>Um Angular 17 zu nutzen, sind die folgenden Versionen von TypeScript und Node.js notwendig:</p>\n<ul>\n<li><strong>TypeScript 5.2</strong>. Der Support für TypeScript-Versionen kleiner als 5.2 wurde eingestellt.</li>\n<li><strong>Node.js 18.13.0</strong>. Node.js in Version 16 wird nicht mehr unterstützt.</li>\n</ul>\n<h2 id=\"signals-gelten-als-stable\">Signals gelten als stable</h2>\n<p>Mit Angular 16 wurde das Konzept der Signals eingeführt. \nIm Blogpost <em><a href=\"/blog/2023-05-angular16\">Angular 16 ist da!</a></em> haben wir die Ideen dieser neuen <em>Reactive Primitive</em> genauer beschrieben.\nDie Signals-Bibliothek von Angular gilt nun als <em>stable</em>, sodass Signals auch in produktiven Anwendungen genutzt werden können.</p>\n<p>Die Reise mit Signals ist damit aber noch nicht vorbei: In den nächsten Monaten werden weitere Neuerungen kommen, vor allem im Blick auf vollständig signal-basierte Komponenten (<a href=\"https://github.com/angular/angular/discussions/49682\">siehe RFC auf GitHub</a>).\nDamit wird es möglich sein, Angular-Anwendungen &quot;zoneless&quot; zu betreiben, also ohne die Bibliothek zone.js.\nDieses Hilfsmittel ist seit jeher notwendig, um die Change Detection von Angular zu triggern – der Prozess, der Änderungen an den Daten ermittelt und die Views der Anwendung automatisch aktualisiert.\nUm diesen Ablauf gezielter und performanter durchzuführen, sind Signals ein wichtiger Grundbaustein.</p>\n<p>Übrigens: Die Signal-Methode <code>mutate()</code> ist in diesem Release nicht mehr enthalten.\nDie Hintergründe sind im zugehörigen <a href=\"https://github.com/angular/angular/commit/c7ff9dff2c14aba70e92b9e216a2d4d97d6ef71e\">Commit auf GitHub</a> ausgeführt.\nStatt <code>mutate()</code> muss also die Methode <code>update()</code> verwendet werden. Dabei müssen Arrays und Objekte als <em>immutable</em> behandelt werden.</p>\n<h2 id=\"neuer-control-flow-if-for-switch\">Neuer Control Flow: <code>@if</code>, <code>@for</code>, <code>@switch</code></h2>\n<p>Die bekannten Strukturdirektiven <code>NgIf</code>, <code>NgFor</code> und <code>NgSwitch</code> sind in ihrer Funktionsweise stark abhängig von zone.js.\nAuf dem Weg zu &quot;Zoneless Angular Apps&quot; musste das Angular-Team das Konzept dieser Direktiven überdenken.</p>\n<p>Mit Angular 17 ist nun der neue <em>Control Flow</em> für Templates verfügbar!\nDamit wird die Funktionalität der bekannten Direktiven direkt in die Template-Syntax integriert.\nDiese Neuerung hat auch bei der Entwicklung einen entscheidenen Vorteil: Die Syntax wird vom Compiler ausgewertet, und es ist nicht mehr notwendig, die Direktiven (oder das <code>CommonModule</code>) zu importieren, damit sie überhaupt in der Komponente genutzt werden können.</p>\n<p>Die Ausdrücke für den neuen Control Flow werden direkt im HTML-Code notiert und mit einem <code>@</code>-Symbol eingeleitet.\nUm Konflikte mit den neuen Steuerzeichen der Template-Syntax zu vermeiden (<code>@</code> und geschweifte Klammern), müssen diese Zeichen manuell escapet werden, wenn sie anderweitig im HTML-Code genutzt werden.\nBeim automatischen Update auf Angular 17 wird dieser Schritt automatisch vorgenommen.</p>\n<p>Wenn Sie die neue Syntax verwenden wollen, stellen Sie bitte sicher, dass Sie den <em>Angular Language Service</em> in Visual Studio Code installiert haben. Diese Extension sorgt für korrektes Syntax Highlighting in den Templates.\nDie IDEs der Firma Jetbrains können auch bereits mit der Syntax umgehen.</p>\n<blockquote>\n<p><strong>Hinweis:</strong> Der neue Control Flow ist im Status <strong>Developer Preview</strong>. Sie können dieses neue Feature bereits ausprobieren, aber es können sich noch Details ändern, bevor es als stabil gekennzeichnet wird!</p>\n</blockquote>\n<h3 id=\"bedingungen-mit-if\">Bedingungen mit <code>@if</code></h3>\n<p>Der <code>@if</code>-Block dient dazu, bestimmte Teile eines HTML-Templates nur dann anzuzeigen, wenn eine Bedingung erfüllt ist.\nEr ersetzt die Direktive <code>*ngIf</code>.\nIm <code>@if</code>-Block steht eine Bedingung. Nur wenn diese Bedingung wahr ist, wird der Teil des Templates gezeigt.</p>\n<p>Ein <code>@if</code>-Block kann auch <code>@else</code>-Blöcke enthalten: Das sind alternative Zweige, die angezeigt werden, wenn die Bedingung im <code>@if</code>-Teil nicht erfüllt ist.\nMan kann einen einfachen <code>@else</code>-Block definieren, der immer dann zum Einsatz kommt, wenn die <code>@if</code>-Bedingung nicht zutrifft – oder man kann zusätzliche <code>@else</code>-Blöcke mit weiteren Bedingungen definieren:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- VORHER --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;books?.length &gt; 1; else elseBlock&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">book-list</span> [<span class=\"hljs-attr\">books</span>]=<span class=\"hljs-string\">&quot;books&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-template</span> #<span class=\"hljs-attr\">elseBlock</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;books?.length === 1; else elseBlock2&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">book-details</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;books[0]&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-template</span> #<span class=\"hljs-attr\">elseBlock2</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Keine Bücher verfügbar!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>    \n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-template</span>&gt;</span>\n</code></pre>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- NACHHER --&gt;</span>\n@if (books?.length &gt; 1) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">book-list</span> [<span class=\"hljs-attr\">books</span>]=<span class=\"hljs-string\">&quot;books&quot;</span> /&gt;</span>\n} @else if (books?.length === 1) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">book-details</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;books[0]&quot;</span> /&gt;</span>\n} @else {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Keine Bücher verfügbar!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n}\n</code></pre>\n<p>Es fällt sofort auf, dass der <code>@else</code>-Zweig deutlich einfacher zu definieren ist als zuvor. Der Einsatz von <code>&lt;ng-template&gt;</code> ist nicht mehr notwendig!\nAußerdem war es bislang häufig erforderlich, das spezielle Tag <code>&lt;ng-container&gt;</code> einzusetzen, um mehrere Elemente zu gruppieren, ohne ein unnötiges DOM-Element zu erzeugen.\nAuch dies entfällt mit der neuen Syntax, da die Gruppierung nun über die Klammern geschieht.</p>\n<h3 id=\"wiederholungen-mit-for\">Wiederholungen mit <code>@for</code></h3>\n<p>Der Schleifenblock <code>@for</code> ersetzt <code>*ngFor</code> für Iterationen und unterscheidet sich in einigen Punkten von der bislang eingesetzten Direktive:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- VORHER --&gt;</span> \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;book of books&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">book-list-item</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;book&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;!books.length&quot;</span>&gt;</span>Keine Bücher verfügbar!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</code></pre>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- NACHHER --&gt;</span> \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  @for (book of books; track book.isbn) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">book-list-item</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;book&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  } @empty {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>Keine Bücher verfügbar!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  }\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n</code></pre>\n<p>Es ist nun möglich, einen <code>@empty</code>-Block anzugeben, der aktiv wird, wenn es keine Einträge gibt. Dies war zuvor nicht direkt möglich.\nDie gezeigte Option <code>track</code> ersetzt das Konzept der <code>trackBy</code>-Funktion: Sie bestimmt für jede Zeile den Schlüssel, der intern verwendet wird, um Array-Elemente eindeutig zu identifizieren. Bei der Direktive <code>*ngFor</code> war es optional, das explizite Tracking zu verwenden. Mit der neuen Syntax ist <code>track</code> jedoch eine Pflichtangabe.</p>\n<p>Eine weitere Vereinfachung besteht darin, dass die Hilfsvariablen nicht mehr extra deklariert werden müssen – sie sind nun direkt innerhalb des Blocks verfügbar.</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- VORHER --&gt;</span> \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;book of books; index as i&quot;</span>&gt;</span>\n  </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">i</span> + <span class=\"hljs-number\">1</span> }}</span><span class=\"language-xml\">. Buch: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">book-list-item</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;book&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n</code></pre>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- NACHHER --&gt;</span> \n@for (book of books; track book.isbn) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n    </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">$index</span> + <span class=\"hljs-number\">1</span> }}</span><span class=\"language-xml\">. Buch: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">book-list-item</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;book&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n}</span>\n</code></pre>\n<p>Falls das iterierte Array nur primitive Werte (z. B. Strings) beinhaltet, wird für das Tracking übrigens der Wert selbst als Identifikator verwendet:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\">@for (name of nameList; track name) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">name</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n}</span>\n</code></pre>\n<p>Folgende Hilfsvariablen stehen in einem <code>@for</code>-Block zur Verfügung:</p>\n<table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Bedeutung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>$index</code></td>\n<td>Index der aktuellen Zeile</td>\n</tr>\n<tr>\n<td><code>$first</code></td>\n<td>gibt an, ob die aktuelle Zeile die erste ist</td>\n</tr>\n<tr>\n<td><code>$last</code></td>\n<td>gibt an, ob die aktuelle Zeile die letzte ist</td>\n</tr>\n<tr>\n<td><code>$even</code></td>\n<td>gibt an, ob der Index der aktuellen Zeile gerade ist</td>\n</tr>\n<tr>\n<td><code>$odd</code></td>\n<td>gibt an, ob der Index der aktuellen Zeile ungerade ist</td>\n</tr>\n</tbody></table>\n<h3 id=\"fallunterscheidungen-mit-switch\">Fallunterscheidungen mit <code>@switch</code></h3>\n<p>Auch die Direktive <code>NgSwitch</code> erhält einen Nachfolger. Die neue Syntax mit <code>@switch</code> ist nun deutlich ähnlicher zum <code>switch</code>-Statement in JavaScript als zuvor:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- VORHER --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> [<span class=\"hljs-attr\">ngSwitch</span>]=<span class=\"hljs-string\">&quot;bedingung&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngSwitchCase</span>=<span class=\"hljs-string\">&quot;1&quot;</span>&gt;</span>Ansicht für Fall 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngSwitchCase</span>=<span class=\"hljs-string\">&quot;2&quot;</span>&gt;</span>Ansicht für Fall 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngSwitchCase</span>=<span class=\"hljs-string\">&quot;3&quot;</span>&gt;</span>Ansicht für Fall 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngSwitchDefault</span>&gt;</span>Standardansicht, wenn kein anderer Fall zutrifft<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span>\n</code></pre>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- NACHHER --&gt;</span>\n@switch (bedingung) {\n  @case (1) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Ansicht für Fall 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  }\n  @case (2) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Ansicht für Fall 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  }\n  @case (3) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Ansicht für Fall 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  }\n  @default {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Standardansicht, wenn kein anderer Fall zutrifft<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  }\n}\n</code></pre>\n<h3 id=\"was-passiert-mit-den-direktiven\">Was passiert mit den Direktiven?</h3>\n<p>Die bisherigen Direktiven bleiben zunächst erhalten und können parallel zum Control Flow verwendet werden.\nSie müssen Ihre Anwendungen also nicht sofort migrieren, sondern können auch weiterhin den gewohnten Ablauf mit den Direktiven nutzen.\nEbenso ist ein Mischbetrieb möglich, sodass z. B. neue Features sofort mit dem neuen Control Flow ausgestattet werden können.</p>\n<p>Grundsätzlich empfehlen wir Ihnen jedoch, in den nächsten Monaten schrittweise zur neuen Control-Flow-Syntax zu migrieren.\nEs ist abzusehen, dass die Direktiven <code>NgIf</code>, <code>NgFor</code> und <code>NgSwitch</code> in einer zukünftigen Major-Version als <em>deprecated</em> markiert werden.</p>\n<p>Angular stellt übrigens ein Skript bereit, um die Templates auf den neuen Control Flow zu migrieren:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:control-flow\n</code></pre>\n<p>Bitte beachten Sie, dass die Migration nicht vollständig automatisch funktioniert.\nDie Ergebnisse müssen stets manuell geprüft und nachgebessert werden.\nIn unseren ersten Experimenten war die Automigration hilfreich, hat aber nicht alle Fälle korrekt erfasst.</p>\n<h2 id=\"deferrable-views-mit-defer\">Deferrable Views mit <code>@defer</code></h2>\n<!-- siehe https://github.com/angular/angular/discussions/50716 -->\n\n<p>Mit dem neuen Control Flow wird ein sehr nützliches neues Feature eingeführt: der <code>@defer</code>-Block.\nWir können damit Teile von HTML-Templates verzögert nachladen.</p>\n<p>Dabei ist es egal, ob es sich um reines HTML, eine Komponente, eine Direktive, eine Pipe oder ein komplexeres Template handelt – wenn HTML-Inhalte in einem solchen Block platziert werden, lädt Angular diese Inhalte nur unter bestimmten Bedingungen oder bei bestimmten Ereignissen zur Laufzeit nach.\nDas ist besonders nützlich, um die Leistung zu optimieren, insbesondere wenn bestimmte Komponenten nicht sofort benötigt werden oder für die anwendende Person noch gar nicht sichtbar sind.</p>\n<p>Grundsätzlich ermöglicht der Router mithilfe von Lazy Loading bereits, ganze Seiten zur Laufzeit nachzuladen. Mit Deferrable Views wird dieses Konzept jetzt noch differenzierter einsetzbar: Wir behandeln nicht nur ganze Seiten, sondern nach Bedarf auch kleinere Teile ihrer Templates.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-variable\">&lt;p&gt;</span>Dieser folgende Teil des Templates wird später geladen!<span class=\"hljs-variable\">&lt;/p&gt;</span>\n\n<span class=\"hljs-meta\">@defer</span> {\n  <span class=\"hljs-variable\">&lt;book-details [book]=&quot;myBook&quot; /&gt;</span>\n}\n<span class=\"hljs-meta\">@loading</span> {\n  <span class=\"hljs-variable\">&lt;span&gt;</span>Inhalte werden geladen …<span class=\"hljs-variable\">&lt;/span&gt;</span>\n} <span class=\"hljs-meta\">@placeholder</span> {\n  <span class=\"hljs-variable\">&lt;span&gt;</span>Inhalt wurde noch nicht geladen.<span class=\"hljs-variable\">&lt;/span&gt;</span>\n} <span class=\"hljs-meta\">@error</span> {\n  <span class=\"hljs-variable\">&lt;span&gt;</span>Es kam zu einem Fehler!<span class=\"hljs-variable\">&lt;/span&gt;</span>\n}\n</code></pre>\n<p>Folgende Hilfsblöcke stehen gemeinsam mit <code>@defer</code> zur Verfügung:</p>\n<ul>\n<li><code>@placeholder</code>: Zeigt den angegebenen Inhalt als Platzhalter, bevor der eigentliche Inhalt geladen wurde. Der Platzhalter muss in den meisten Fällen angegeben werden! </li>\n<li><code>@loading</code>: Zeigt den angegebenen Inhalt an, <em>während</em> die Abhängigkeiten geladen werden, also nachdem der Ladevorgang gestartet wurde. Die Inhalte von <code>@loading</code> ersetzen den Placeholder!</li>\n<li><code>@error</code>: Zeigt den angegebenen Inhalt an, falls ein Problem beim Laden des Inhalts auftritt.</li>\n</ul>\n<p>Statten wir also einen <code>@defer</code>-Block mit <code>@placeholder</code> und <code>@loading</code> aus, so ist zunächst der Placeholder zu sehen.\nSobald das Laden der Inhalte durchgeführt wird, wird der <code>@loading</code>-Block angezeigt.\nIst das Laden abgeschlossen, sind die Inhalte sichtbar.</p>\n<p>Standardmäßig wird der Inhalt eines <code>@defer</code>-Blocks sofort geladen, nachdem die Anwendung fertig gerendert wurde.\nUm das Verhalten genauer zu steuern, steht eine Sammlung von Triggern zu Verfügung.\nSie steuern, wann Angular den Inhalt laden und rendern soll.</p>\n<blockquote>\n<p><strong>Hinweis:</strong> Die neuen Deferrable Views sind im Status <strong>Developer Preview</strong>. Sie können dieses neue Feature bereits ausprobieren, aber es können sich noch Details ändern, bevor es als stabil gekennzeichnet wird!</p>\n</blockquote>\n<h3 id=\"loading-trigger-on-viewport\">Loading Trigger: <code>on viewport</code></h3>\n<p>Der Inhalt wird nachgeladen, wenn der Placeholder sichtbar wird, also in den Viewport des Browsers rückt:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-keyword\">@defer</span> (on viewport) {\n  &lt;<span class=\"hljs-selector-tag\">p</span>&gt;Dieser Inhalt wird später geladen!&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;\n}\n<span class=\"hljs-keyword\">@placeholder</span> {\n  &lt;<span class=\"hljs-selector-tag\">p</span>&gt;Inhalt wurde noch nicht geladen …&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;\n}\n</code></pre>\n<h3 id=\"loading-trigger-on-timer\">Loading Trigger: <code>on timer</code></h3>\n<p>Der Inhalt wird nachgeladen, wenn der angegebene Timer abgelaufen ist:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-keyword\">@defer</span> (on timer(<span class=\"hljs-number\">3s</span>)) {\n  &lt;<span class=\"hljs-selector-tag\">p</span>&gt;Dieser Inhalt wird erst nach <span class=\"hljs-number\">3</span> Sekunden geladen!&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;\n}\n<span class=\"hljs-keyword\">@placeholder</span> {\n  &lt;<span class=\"hljs-selector-tag\">p</span>&gt;Inhalt wurde noch nicht geladen …&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;\n}\n</code></pre>\n<h3 id=\"loading-trigger-when\">Loading Trigger: <code>when</code></h3>\n<p>Der Inhalt wird nachgeladen, wenn die angegebene Bedingung erfüllt ist:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-keyword\">@defer</span> (when myDeferFlag) {\n  &lt;<span class=\"hljs-selector-tag\">p</span>&gt;Dieser Inhalt wird einmalig geladen, wenn `myDeferFlag` wahr ist!&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;\n}\n<span class=\"hljs-keyword\">@placeholder</span> {\n  &lt;<span class=\"hljs-selector-tag\">p</span>&gt;Inhalt wurde noch nicht geladen …&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;\n}\n</code></pre>\n<h2 id=\"routing-mit-view-transition-api\">Routing mit View Transition API</h2>\n<p>Der Router von Angular unterstützt nun die native <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\">View Transition API</a>.\nDamit ist es möglich, animierte Übergänge im DOM beim Wechsel zwischen Routen zu implementieren.\nBitte beachten Sie, dass die Schnittstelle noch nicht in allen Browsern unterstützt wird.</p>\n<p>Um das neue Feature zu nutzen, verwenden wir die Funktion <code>withViewTransitions()</code> in der Konfiguration des Routers:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// app.config.ts</span>\n<span class=\"hljs-keyword\">import</span> { provideRouter, withViewTransitions } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/router&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">appConfig</span>: <span class=\"hljs-title class_\">ApplicationConfig</span> = {\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title function_\">provideRouter</span>(\n      [<span class=\"hljs-comment\">/* ... */</span>], <span class=\"hljs-comment\">// Routen</span>\n      <span class=\"hljs-title function_\">withViewTransitions</span>() <span class=\"hljs-comment\">// View Transitions aktivieren</span>\n    ),\n  ],\n});\n</code></pre>\n<p>Damit der Effekt sichtbar wird, müssen wir außerdem eine passende Animation implementieren.\nDafür werden die CSS-Pseudo-Selektoren <code>::view-transition-old</code> und <code>::view-transition-new</code> verwendet:</p>\n<pre><code class=\"language-css\"><span class=\"hljs-keyword\">@keyframes</span> slide-right {\n  <span class=\"hljs-selector-tag\">from</span> {\n    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translateX</span>(<span class=\"hljs-number\">100px</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">@keyframes</span> slide-left {\n  <span class=\"hljs-selector-tag\">to</span> {\n    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translateX</span>(-<span class=\"hljs-number\">100px</span>);\n  }\n}\n\n::<span class=\"hljs-built_in\">view-transition-old</span>(root) {\n  <span class=\"hljs-attribute\">animation</span>: <span class=\"hljs-number\">500ms</span> linear both slide-left;\n}\n\n::<span class=\"hljs-built_in\">view-transition-new</span>(root) {\n  <span class=\"hljs-attribute\">animation</span>: <span class=\"hljs-number\">500ms</span> linear both slide-right;\n}\n</code></pre>\n<p>Anstatt der Angabe <code>root</code> können wir hier auch einen anderen CSS-Selektor angeben, auf den die View Transition angewandt werden soll.\nMit dem Wert <code>root</code> erfolgt die Transition auf dem gesamten Dokument.</p>\n<h2 id=\"neuerungen-bei-server-side-rendering\">Neuerungen bei Server-Side Rendering</h2>\n<p>Das Angular-Team hat im neuesten Release stark an dem Support für Server-Side-Rendering (SSR) gearbeitet.\nDas bisherige Projekt <em>Angular Universal</em> wurde dafür direkt in den Core von Angular aufgenommen. Es wird ab sofort unter dem neuen Namen <code>@angular/ssr</code> veröffentlicht.</p>\n<p>Mithilfe von Server-Side Rendering kann die Angular-Anwendung bereits auf dem Server ausgeführt werden, sodass der Aufbau des DOM-Baums nicht mehr vollständig im Browser passieren muss.\nDas kann für eine bessere wahrgenommene Start-Performance sorgen, weil beim ersten Laden der Seite bereits grundlegender Inhalt sichtbar ist, auch bevor Angular die Seite gerendert hat.\nRichtig eingesetzt kann SSR bessere Ergebnisse bei den Core Web Vitals ermöglichen.\nAußerdem ist SSR ein elementarer Baustein für Suchmaschinenoptimierung.</p>\n<p>Angular hat hier bei der sogenannten <em>Partial Hydration</em> nachgebessert:\nNach der ersten Auslieferung der server-gerenderten Anwendung wird im Browser nicht mehr die gesamte Anwendung neu gerendert und ersetzt.\nStattdessen werden nur die relevanten (interaktiven) Teile der Anwendung ermittelt, und nur diese werden mithilfe von JavaScript <em>hydriert</em>, also zum dynamischen Leben erweckt.\nDieses Konzept wurde grundlegend bereits mit Angular 16 eingeführt.</p>\n<p>Die wichtigste Neuigkeit ist, dass wir beim Anlegen unseres Projekts mit <code>ng new</code> sofort den Support für SSR aktivieren können:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> book-monkey <span class=\"hljs-comment\">--ssr</span>\n</code></pre>\n<p>Wollen wir in einem bestehenden Projekt nachträglich SSR aktivieren, können wir den folgenden Befehl nutzen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> @angular/ssr</span>\n</code></pre>\n<p>Dabei wird der neue Application Builder eingesetzt, den wir im nächsten Abschnitt vorstellen.</p>\n<h2 id=\"application-builder-auf-basis-von-esbuild\">Application Builder auf Basis von ESBuild</h2>\n<!-- Quelle: https://github.com/angular/angular/pull/52407/files -->\n\n<p>Mit Angular 16 wurde ein neues Build-System auf Basis von <a href=\"https://esbuild.github.io/\">ESBuild</a> als <em>Developer Preview</em> vorgestellt. ESBuild kann vor allem mit einer deutlich besseren Performance aufwarten als das alte System. Dank vieler Verbesserungen und positiver Rückmeldungen aus der Community fühlt sich das Angular-Team nun sicher genug, den Builder in Angular 17 als stabil zu erklären.</p>\n<blockquote>\n<p>ℹ️ <strong>Was ist ein Builder?</strong> Jedes Mal, wenn wir einen Befehl wie <code>ng build</code>, <code>ng serve</code> oder <code>ng test</code> starten, wird im Hintergrund ein <em>Builder</em> ausgeführt. Es handelt sich also um das Skript, das den Build-Prozess durchführt. Der verwendete Builder wird in der Datei <code>angular.json</code> konfiguriert.</p>\n</blockquote>\n<h3 id=\"für-neue-projekte\">Für neue Projekte</h3>\n<p>Der ESBuild-basierte Build wird nun für alle Applikationen, die mit <code>ng new</code> bzw. <code>npm create</code> erstellt werden, automatisch aktiv sein. \nDafür ist in der Datei <code>angular.json</code> der Builder mit dem Namen <code>@angular-devkit/build-angular:application</code> voreingestellt.</p>\n<h3 id=\"für-bestehende-projekte\">Für bestehende Projekte</h3>\n<p>Das bestehende Build-System auf Basis von Webpack gilt weiterhin als stabil und wird vollständig unterstützt. Bestehende Projekte können den bisherigen Builder weiterhin nutzen und werden bei einem Update nicht automatisch umgestellt.\nUm die Vorteile des neuen Build-Systems zu nutzen, können Sie die Datei <code>angular.json</code> wie folgt anpassen:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-regexp\">//</span> VORHER\n  <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n    <span class=\"hljs-string\">&quot;build&quot;</span>: {\n      <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>-devkit/build-angular:browser&quot;</span>,\n    }\n  }\n}\n</code></pre>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-regexp\">//</span> NACHHER\n  <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n    <span class=\"hljs-string\">&quot;build&quot;</span>: {\n      <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>-devkit/build-angular:browser-esbuild&quot;</span>,\n    }\n  }\n}\n</code></pre>\n<p>Weitergehende Änderungen sind nicht notwendig, um das neue Build-System zu nutzen.\nDer neue Builder <code>browser-esbuild</code> dient als direkte Alternative (&quot;drop-in replacement&quot;) zum bestehenden <code>browser</code>-Builder.\nWollen Sie Server-Side Rendering nutzen, ist in dieser Konfiguration weiterhin der bestehende Builder für Angular Universal erforderlich.</p>\n<h3 id=\"der-neue-application-builder\">Der neue <code>application</code>-Builder</h3>\n<p>Um die Landschaft der verschiedenen Builder-Skripte zu vereinheitlichen, wurde mit Angular 17 ein neuer Builder <code>application</code> eingeführt.\nFür neue Projekte ist dieser Builder automatisch voreingestellt, sodass Sie nichts weiter tun müssen.\nAuch für bestehende Projekte empfehlen wir, auf den <code>application</code>-Builder zu wechseln.</p>\n<p>Der neue Builder vereint alle Aufgaben, die zuvor in verschiedenen Buildern untergebracht waren: Server-Side Rendering und Pre-Rendering stehen nun direkt zur Verfügung, ohne dass wir dafür separate Builder installieren müssen.</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-comment\">// VORHER</span>\n  <span class=\"hljs-string\">&quot;architect&quot;</span><span class=\"hljs-punctuation\">:</span> {\n    <span class=\"hljs-string\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> {\n      <span class=\"hljs-string\">&quot;builder&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;@angular-devkit/build-angular:browser&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-string\">&quot;options: {</span>\n        <span class=\"hljs-comment\">// ...</span>\n      }\n    }\n  }\n}\n</code></pre>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-comment\">// NACHHER</span>\n  <span class=\"hljs-string\">&quot;architect&quot;</span><span class=\"hljs-punctuation\">:</span> {\n    <span class=\"hljs-string\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> {\n      <span class=\"hljs-string\">&quot;builder&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;@angular-devkit/build-angular:application&quot;</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-string\">&quot;options: {</span>\n        <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Optionen müssen aktualisiert werden</span>\n      }\n    }\n  }\n}\n</code></pre>\n<p>Da es sich um einen vollständig neuen Builder handelt, müssen Sie einige Optionen in der Datei <code>angular.json</code> anpassen.\nNachdem Sie den Namen des Builders auf <code>application</code> geändert haben, aktualisieren Sie bitte die folgenden Einträge unter <code>options</code>:</p>\n<ol>\n<li>Die Option <code>main</code> sollten Sie in <code>browser</code> umbenennen.</li>\n<li>Bei <code>polyfills</code> sollten Sie den Wert in ein Array umwandeln, falls dies nicht bereits geschehen ist.</li>\n<li>Die Optionen <code>buildOptimizer</code>, <code>resourcesOutputPath</code>, <code>vendorChunk</code>, <code>commonChunk</code>, <code>deployUrl</code> und <code>ngswConfigPath</code> können Sie entfernen. </li>\n<li>Den Wert von <code>ngswConfigPath</code> sollten Sie allerdings zu <code>serviceWorker</code> verschieben und dann die Option entfernen. <code>serviceWorker</code> ist jetzt entweder <code>false</code> oder ein Konfigurationspfad.</li>\n</ol>\n<p>Wenn Ihre Anwendung kein Server-Side-Rendering (SSR) verwendet, sind dies alle Änderungen, die Sie vornehmen müssen, damit <code>ng build</code> wie gewohnt funktioniert.\nEs ist möglich, dass dennoch Fehler oder Warnungen auftreten, wenn Ihre Anwendung spezifische Webpack-Features nutzt.\nSollte es unerwartete Verhaltensunterschiede zwischen den Buildern geben, bittet das Angular-Team darum, ein <a href=\"https://github.com/angular/angular-cli/issues\">Issue auf GitHub</a> zu eröffnen.</p>\n<p>Für Anwendungen, die bereits SSR (mit und ohne Pre-Rendering) verwenden, sind zusätzliche manuelle Anpassungen erforderlich.\nDer neue <code>application</code>-Builder übernimmt nun die Funktionalitäten aller bisherigen Builder <code>prerender</code>, <code>server</code>, <code>ssr-dev-server</code> und <code>app-shell</code>.\nDie jeweiligen Optionen müssen deshalb gemeinsam an den <code>application</code>-Builder übergeben werden.</p>\n<p>Wir begrüßen sehr, dass diese große Auwahl an Buildern für unterschiedliche Zwecke endlich vereinheitlicht wird.\nBitte konsultieren Sie den <a href=\"https://angular.dev/guide/ssr\">SSR Guide</a> bzw. <a href=\"https://angular.dev/guide/prerendering\">Prerendering Guide</a> in der offiziellen Dokumentation für eine ausführliche Beschreibung der notwendigen Schritte.</p>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Neben den großen Features hat Angular eine Menge von kleineren Neuerungen und Bugfixes an Bord.\nEinige interessante Punkte haben wir hier aufgeführt:</p>\n<ul>\n<li>Die <code>styleUrls</code> in den Metadaten einer Komponente mussten seit jeher als Array notiert werden. Da häufig nur eine einzige Style-URL verwendet wird, können wir dort nun auch einen einfachen String angeben: <code>styleUrl: &#39;./my.component.scss&#39;</code>.</li>\n<li>Inline Styles einer Komponente (<code>styles</code>) mussten bisher als Array angegeben werden. Hier kann jetzt auch ein einzelner String notiert werden.</li>\n<li>Die Option <code>--routing</code> ist beim Erzeugen eines neuen Workspace mit <code>ng new</code> bzw. <code>npm create</code> nun standardmäßig aktiviert.</li>\n<li>Die Option <code>--standalone</code> ist beim Erzeugen eines neuen Workspace mit <code>ng new</code> bzw. <code>npm create</code> nun standardmäßig aktiviert – es werden also keine Angular-Module (<code>@NgModule()</code>) mehr erzeugt. </li>\n<li>Animationen mit <code>@angular/animations</code> können lazy geladen werden, sodass die Implementierung nicht mehr sofort zusammen mit der Hauptanwendung geladen werden muss, siehe <a href=\"https://github.com/angular/angular/commit/e753278faae79a53e235e0d8e03f89555a712d80\">Commit</a>. Mehr Infos gibt es im <a href=\"https://riegler.fr/blog/2023-10-04-animations-async\">Blogpost von Matthieu Riegler</a> aus dem Angular-Team.</li>\n</ul>\n<hr>\n\n\n<p>Wir wünschen Ihnen viel Spaß mit Angular 17!\nHaben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß wünschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Raukenlandschaft, Fårö/Gotland, Schweden. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 17 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2023-11-06T00:00:00.000Z","lastModified":"2023-11-08T00:00:00.000Z","keywords":["Angular","Angular 17","Signals","Control Flow","Deferrable Views","View Transition API","ESBuild","Logo","angular.dev"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2023-11-angular17/angular17.jpg","sticky":false}}
