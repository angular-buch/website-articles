{"slug":"errata-4a","html":"<p>Für die 4. Auflage haben wir das Buch vollständig überarbeitet und viele Fehler beseitigt.\nDas war durch wertvolle Hinweise unserer Leserinnen und Leser möglich. Dennoch: Ein gedrucktes Buch ist niemals fehlerfrei, und natürlich hat sich auch in der 4. Auflage der Fehlerteufel eingeschlichen.</p>\n<p><strong>Haben Sie Fragen oder Hinweise, oder haben Sie einen Fehler im Buch gefunden?\nBitte zögern Sie nicht, und schreiben Sie uns eine E-Mail: <a href=\"mailto:&#116;&#101;&#97;&#109;&#x40;&#x61;&#110;&#x67;&#x75;&#x6c;&#97;&#x72;&#x2d;&#x62;&#x75;&#x63;&#x68;&#x2e;&#99;&#x6f;&#x6d;\">&#116;&#101;&#97;&#109;&#x40;&#x61;&#110;&#x67;&#x75;&#x6c;&#97;&#x72;&#x2d;&#x62;&#x75;&#x63;&#x68;&#x2e;&#99;&#x6f;&#x6d;</a></strong></p>\n<blockquote>\n<p><strong>Dies ist das Errata-Verzeichnis für die 4. Auflage (2023). Wenn Sie die ältere 3. Auflage besitzen, lesen Sie bitte die <a href=\"/blog/errata-3a\">Errata zur 3. Auflage</a>.</strong></p>\n</blockquote>\n<hr>\n<h3 id=\"52-projekt-anlegen\">5.2 Projekt anlegen</h3>\n<p>Zum Beginn des Buchs legen wir gemeinsam das Beispielprojekt mithilfe des Befehls <code>ng new</code> an.\nSeit Angular 17 werden neue Anwendungen standardmäßig mit Standalone Components generiert.\nDas Beispielprojekt setzt jedoch zunächst auf NgModules und wird erst später auf Standalone Components migriert.</p>\n<p>Damit die Beispiele im Buch weiterhin mit dem generierten Code übereinstimmen, müssen Sie die Option <code>standalone</code> beim Erzeugen des Projekts explizit deaktivieren:</p>\n<pre><code class=\"language-sh\">ng new book-monkey --routing <span class=\"hljs-attribute\">--style</span>=css <span class=\"hljs-attribute\">--prefix</span>=bm <span class=\"hljs-attribute\">--standalone</span>=<span class=\"hljs-literal\">false</span>\n</code></pre>\n<p>Die interaktive Abfrage für Server-Side Rendering können Sie mit dem Default <code>N</code> (No) beantworten – wir benötigen SSR zunächst nicht.\nÜbrigens: Die Option <code>routing</code> ist seit Angular 17 per Default aktiviert, sie muss also nicht mehr manuell mit angegeben werden.</p>\n<h3 id=\"53-statische-assets-einbinden\">5.3 Statische Assets einbinden</h3>\n<p>Im Abschnitt 5.3 auf Seite 64 erläutern wir, dass statische Assets aus dem Ordner <code>src/assets</code> automatisch eingebunden werden.\nIn neu angelegten Projekten existiert dieser Ordner nicht mehr. Stattdessen werden statische Dateien, die beim Build mit ausgeliefert werden sollen, im neuen Ordner <code>public</code> abgelegt.\nWenn wir diese Dateien einbinden, muss der Ordnerpfad <strong>nicht</strong> mehr angegeben werden. Legen wir die Datei <code>icon.png</code> in den Ordner <code>public</code>, wird sie aus der Anwendung heraus wie folgt eingebunden:</p>\n<pre><code class=\"language-html\">&lt;img <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-string\">&quot;icon.png&quot;</span> <span class=\"hljs-attribute\">alt</span>=<span class=\"hljs-string\">&quot;Icon&quot;</span>&gt;\n</code></pre>\n<h3 id=\"55-import-in-scss-ist-deprecated\">5.5 <code>@import</code> in SCSS ist deprecated</h3>\n<p>In Abschnitt 5.5 binden wir das Paket <code>book-monkey5-styles</code> ein, um die globalen Stylesheets zu nutzen.\nDafür verwenden wir das Statement <code>@import</code> in der Datei <code>styles.css</code>.</p>\n<p>Wir haben im BookMonkey zwar reines CSS eingesetzt, für die Praxis empfehlen wir aber eher, auf den Präprozessor SCSS zu setzen.\nDort funktioniert <code>@import</code> grundlegend auch – das Statement wurde allerdings als <em>deprecated</em> markiert. <code>@import</code> verweist in SCSS nur noch auf reine CSS-Imports.\nArbeiten wir mit SCSS, wird <code>@use</code> empfohlen, um andere Dateien einzubinden.</p>\n<pre><code class=\"language-scss\"><span class=\"hljs-comment\">// styles.scss (!)</span>\n<span class=\"hljs-variable\">@use</span> <span class=\"hljs-string\">&#x27;book-monkey5-styles/index.css&#x27;</span>;\n</code></pre>\n<p>Nutzen wir nur reines CSS für das Styling der Anwendung, ist <code>@import</code> weiterhin möglich – Sie müssen für die Arbeit mit dem Buch hier also zunächst nichts ändern.</p>\n<h3 id=\"56-warnungen-von-eslint\">5.6 Warnungen von ESLint</h3>\n<p>Bei der Ausführung von ESLint mit dem Befehl <code>ng lint</code> erhalten wir die folgende Warnung:</p>\n<pre><code><span class=\"hljs-keyword\">error  </span>Components, Directives and Pipes should not opt out of standalone  @angular-eslint/prefer-standalone\n</code></pre>\n<p>Eine ausführliche Erklärung dafür finden Sie im nächsten Abschnitt (<strong>6 Komponenten mit Flag <code>standalone: false</code></strong>).\nWir arbeiten in diesem Buch mit modulbasierten Komponenten. Deshalb empfehlen wir, die ESLint-Regel zu deaktivieren:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// eslint.config.js</span>\n<span class=\"hljs-symbol\">rules:</span> <span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-string\">&quot;@angular-eslint/prefer-standalone&quot;</span>: <span class=\"hljs-string\">&quot;off&quot;</span>,\n  <span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h3 id=\"6-komponenten-mit-flag-standalone-false\">6 Komponenten mit Flag <code>standalone: false</code></h3>\n<p>Wir arbeiten im Buch mit modulbasierten Komponenten. Seit Angular 17 generiert Angular automatisch Standalone Components, die ohne Module funktionieren.\nWir haben dieses Thema in Kapitel 25 ausführlich behandelt.\nDamit das Buch auch mit neueren Versionen von Angular kompatibel ist, haben wir beim Anlegen des Projekts die Option <code>--standalone</code> auf <code>false</code> gesetzt – so erhalten wir eine modulbasierte Anwendung.</p>\n<p>Seit Angular 19 sind Komponenten per Default standalone, und es ist nicht mehr notwendig, Standalone Components explizit als solche zu markieren.\nStattdessen muss für modulbasierte Komponenten die Einstellung <code>standalone</code> im Kopf der Komponenten explizit auf <code>false</code> gesetzt werden.</p>\n<p><strong>Alle Komponenten im BookMonkey tragen seit Angular 19 automatisch das Flag <code>standalone: false</code>, das nicht im Buch abgedruckt ist.</strong></p>\n<h3 id=\"141-httpclientmodule-ist-deprecated\">14.1 <code>HttpClientModule</code> ist deprecated</h3>\n<p>Wir verwenden das <code>HttpClientModule</code>, um den <code>HttpClient</code> von Angular anschließend injecten zu können.\nDieses Modul ist deprecated und sollte nicht mehr verwendet werden.\nStattdessen nutzen wir die neue Funktion <code>provideHttpClient()</code> unter <code>providers</code>:</p>\n<pre><code class=\"language-ts\">import { provideHttpClient, withInterceptorsFromDi, HTTP_INTERCEPTORS } from <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> ...\n\n<span class=\"hljs-variable\">@NgModule</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  imports: [\n    <span class=\"hljs-regexp\">//</span> ...\n    // HttpClientModule // WEG!\n  ],\n  providers: [\n    <span class=\"hljs-regexp\">//</span> NEU\n    provideHttpClient(withInterceptorsFromDi())\n  ]\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{ }\n</code></pre>\n<h3 id=\"204-asynchroner-validator-und-methode-checkavailable\">20.4 Asynchroner Validator und Methode <code>checkAvailable()</code></h3>\n<p>Im Abschnitt 20.4 entwickeln wir auf den Seiten 395 und 396 einen asynchronen Validator.\nDie Validatormethode haben wir im Listing 20-12 <code>usernameAvailable()</code> genannt.\nBei der Verwendung im darauf folgenden Listing 20-13 auf Seite 396 haben wir aber fälschlicherweise den Namen <code>checkAvailable()</code> genutzt.</p>\n<p>Korrekt muss das Listing 20-13 also lauten:</p>\n<pre><code class=\"language-ts\">form = <span class=\"hljs-keyword\">new</span> FormGroup({\n  username: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, {\n    validators: [Validators.<span class=\"hljs-keyword\">required</span>],\n    asyncValidators: [\n      inject(UsernameValidatorService).usernameAvailable()\n    ]\n  })\n});\n</code></pre>\n<h3 id=\"267-fehlerhafte-cypress-tests\">26.7 Fehlerhafte Cypress-Tests</h3>\n<h4 id=\"test-1-should-not-show-the-administration-form-when-not-logged-in\">Test 1: <code>should not show the administration form when not logged in</code></h4>\n<p>In diesem Test selektieren wir den Login-/Logout-Button in der Navigation.\nWir haben diesen Button allerdings in ein <code>div</code>-Element geschachtelt, deshalb funktioniert der abgedruckte Selektor <code>div &gt; nav</code> nicht.</p>\n<p>Stattdessen sollten wir den Test so formulieren:</p>\n<pre><code class=\"language-ts\">cy.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">&#x27;nav button&#x27;</span>)\n  .<span class=\"hljs-keyword\">as</span>(<span class=\"hljs-string\">&#x27;loginLogoutBtn&#x27;</span>)\n  <span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<h4 id=\"test-2-should-not-open-the-results-box-on-server-errors\">Test 2: <code>should not open the results box on server errors</code></h4>\n<p>Dieser Test soll nachweisen, dass die Suchergebnisbox nicht geöffnet wird, wenn der Server einen Fehler liefert – der Test schlägt allerdings fehl.\nGrund dafür ist die Implementierung im <code>BookStoreService</code>: In Abschnitt 15.15 haben wir hier den RxJS-Operator <code>catchError</code> verwendet, um Fehler abzufangen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-title function_\">getAllSearch</span>(<span class=\"hljs-attr\">term</span>: <span class=\"hljs-built_in\">string</span>): <span class=\"hljs-title class_\">Observable</span>&lt;<span class=\"hljs-title class_\">Book</span>[]&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">get</span>&lt;<span class=\"hljs-title class_\">Book</span>[]&gt;(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.apiUrl}</span>/books/search/<span class=\"hljs-subst\">${term}</span>`</span>).<span class=\"hljs-title function_\">pipe</span>(\n    <span class=\"hljs-title function_\">catchError</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">of</span>([]);\n    })\n  );\n}\n</code></pre>\n<p>Die Komponente erhält also bei einem Serverfehler ein leeres Array mit Suchergebnissen.\nDie Ergebnisbox ist dann trotzdem sichtbar, und der Cypress-Test schlägt fehl.</p>\n<p>Wir empfehlen Ihnen, das <code>catchError</code> in der Methode <code>getAllSearch()</code> wieder zu entfernen.\nDann verhält sich die Komponente so, wie wir es im Test beschrieben haben.</p>\n<h3 id=\"3235-ngrx-feature-anlegen\">32.3.5 NgRx: Feature anlegen</h3>\n<p>Der im Buch abgedruckte Befehl, um ein Feature mithilfe der Schematics von NgRx anzulegen, erzeugt den folgenden Fehler:</p>\n<pre><code>Specified module path <span class=\"hljs-regexp\">/src/</span>app<span class=\"hljs-regexp\">/books/</span>store<span class=\"hljs-regexp\">/books/</span>books does not exist\n</code></pre>\n<p>Der Hintergrund: In den neueren Versionen der Feature-Schematics ist die Option <code>entity</code> per Default aktiviert.\nDas führt dazu, dass ein <code>EntityAdapter</code> für das Feature generiert wird, wie wir es weiter hinten im Buch in Abschnitt 32.5.3 beschrieben haben.\nIn dieser Konstellation kann das Skript den verschachtelten Feature-Namen nicht korrekt auswerten.</p>\n<p>Um das Problem zu lösen, muss die Option <code>entity</code> expliziert deaktiviert werden.\nDas erzeugte Ergebnis entspricht dann dem Code, der im Buch abgedruckt ist.</p>\n<p><strong>Neuer Befehl:</strong></p>\n<pre><code class=\"language-sh\">ng <span class=\"hljs-selector-tag\">g</span> feature books/store/book <span class=\"hljs-attr\">--module</span> books/books <span class=\"hljs-attr\">--api</span> <span class=\"hljs-attr\">--entity</span>=false <span class=\"hljs-attr\">--defaults</span>\n</code></pre>\n<h3 id=\"32311-ngrx-effects-mit-inject\">32.3.11 NgRx Effects mit <code>inject()</code></h3>\n<p>In der Effects-Klasse in NgRx nutzen wir die Constructor Injection, um die Services <code>Actions</code> und <code>BookStoreService</code> anzufordern.\nBeide Objekte werden dann im Effect verwendet, der direkt im Property initialisiert wird.</p>\n<p>Wir müssen deshalb die Funktion <code>inject()</code> verwenden, um die Services anzufordern:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Injectable</span>()\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookEffects</span> {\n\n  <span class=\"hljs-keyword\">private</span> actions<span class=\"hljs-variable\">$ </span>= inject(<span class=\"hljs-title class_\">Actions</span>);\n  <span class=\"hljs-keyword\">private</span> service = inject(<span class=\"hljs-title class_\">BookStoreService</span>);\n\n  loadBooks<span class=\"hljs-variable\">$ </span>= <span class=\"hljs-regexp\">/* ... */</span>\n}\n</code></pre>\n<h3 id=\"33-server-side-rendering-und-pre-rendering-mit-angular-17\">33 Server-Side Rendering und Pre-Rendering mit Angular 17</h3>\n<p>Mit Angular 17 wurde der Build-Prozess für Server-Side Rendering und Pre-Rendering angepasst.\nAb sofort wird das neue Paket <code>@angular/ssr</code> verwendet, um SSR in der Anwendung einzurichten.\nDer Build für alle drei Aspekte (Browser, Server, Pre-Rendering) wird nun in einem Schritt vom neuen Application Builder ausgeführt.</p>\n<p>Die Unterschiede zum gedruckten Buch haben wir in einem separaten Blogartikel zusammengefasst:</p>\n<p><strong><a href=\"/blog/2023-11-ssr-bm\">Book Monkey v5: Server-Side Rendering mit Angular 17</a></strong></p>\n","meta":{"title":"Errata zur 4. Auflage","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2023-04-27T00:00:00.000Z","lastModified":"2024-03-22T00:00:00.000Z","keywords":["Angular","Errata","Fehlerverzeichnis","4. Auflage"],"language":"de"}}
