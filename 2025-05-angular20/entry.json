{"slug":"2025-05-angular20","html":"<p>Alles neu macht der Mai – oder zumindest eine neue Major-Version von Angular:\nAm <strong>29. Mai 2025</strong> wurde <strong>Angular 20</strong> veröffentlicht! Im offiziellen <a href=\"https://blog.angular.dev/announcing-angular-v20-b5c9c06cf301\">Angular-Blog</a> finden Sie die Release-Informationen direkt vom Angular-Team.</p>\n<p>Für die Migration auf Angular 20 empfehlen wir, den Befehl <code>ng update</code> zu nutzen.\nDetaillierte Infos zu den Schritten liefert der <a href=\"https://angular.dev/update-guide\">Angular Update Guide</a>.</p>\n<h1 id=\"versionen-von-typescript-und-nodejs\">Versionen von TypeScript und Node.js</h1>\n<p>Für Angular 20 sind <em>mindestens</em> die folgenden Versionen von TypeScript und Node.js erforderlich:</p>\n<ul>\n<li>TypeScript: 5.8</li>\n<li>Node.js: 20.19.x oder höher, 22.12.x oder höher, oder 24.0.x oder höher</li>\n</ul>\n<p>Der Support für Node.js Version 18 wurde entfernt. In der <a href=\"https://angular.dev/reference/versions\">Angular-Dokumentation</a> finden Sie ausführliche Infos zu den unterstützten Versionen.</p>\n<h1 id=\"der-neue-coding-style-guide\">Der neue Coding Style Guide</h1>\n<p>Angular hat sich in den letzten Jahren stark weiterentwickelt und viele neue Konzepte wurden in das Framework integriert.\nDie Angular-Dokumentation war teilweise nicht auf dem aktuellsten Stand: Insbesondere der Coding Style Guide hatte noch keine Empfehlungen für den aktuellen Status Quo parat.\nMit Angular 20 hat sich das geändert:\nDer neue <a href=\"https://angular.dev/style-guide\">Style Guide</a> wurde stark überarbeitet und verschlankt.\nEr beinhaltet aktuelle Empfehlungen und Best Practices und gilt als Leitlinie für die Entwicklung mit den aktuellen Versionen von Angular.</p>\n<h2 id=\"keine-suffixes-mehr-bewusstere-benennung-und-neue-patterns\">Keine Suffixes mehr: bewusstere Benennung und neue Patterns</h2>\n<p>Eine wichtige Änderung, die nicht unerwähnt bleiben sollte, betrifft die Suffixe in Datei- und Klassennamen:\nDer neue Style Guide empfiehlt <em>nicht</em> mehr, Komponenten, Services und Direktiven mit einem Suffix zu versehen.\nAb Angular 20 generiert die CLI standardmäßig keine Suffixes wie <code>.component.ts</code> oder <code>.service.ts</code> mehr. Diese neue Einstellung greift natürlich nur bei neu angelegten Projekten.</p>\n<p>Der Befehl <code>ng generate component book-card</code> erzeugt also die folgende Ausgabe:</p>\n<p><strong>bis Angular 19:</strong></p>\n<pre><code><span class=\"hljs-attribute\">src</span>/app\n  book-card\n    book-card<span class=\"hljs-selector-class\">.component</span><span class=\"hljs-selector-class\">.ts</span>\n    book-card<span class=\"hljs-selector-class\">.component</span><span class=\"hljs-selector-class\">.html</span>\n    book-card<span class=\"hljs-selector-class\">.component</span><span class=\"hljs-selector-class\">.scss</span>\n    book-card<span class=\"hljs-selector-class\">.component</span><span class=\"hljs-selector-class\">.spec</span>.ts\n</code></pre>\n<pre><code class=\"language-ts\">// book-card.component.ts\n// ...\n<span class=\"hljs-variable\">@Component</span>(<span class=\"hljs-regexp\">/* ... */</span>)\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookCardComponent</span> </span>{}\n</code></pre>\n<p><strong>ab Angular 20:</strong></p>\n<pre><code>src/app\n  book-card\n    book-cardts\n    book-cardhtml\n    book-cardscss\n    book-cardspec.ts\n</code></pre>\n<pre><code class=\"language-ts\">// book-card.ts\n// ...\n<span class=\"hljs-variable\">@Component</span>(<span class=\"hljs-regexp\">/* ... */</span>)\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookCard</span> </span>{}\n</code></pre>\n<p>Das Ziel dahinter: Angular-Anwendungen sollen weniger Boilerplate enthalten, und wir sollen uns bewusster mit der Benennung der Abstraktionen auseinandersetzen. Statt automatisch generierter Konstrukte wie <code>product-detail.component.ts</code>, ist nun mehr eigenes Nachdenken gefragt: Wie heißt diese Klasse? Was macht sie? Und wie viel sagt der Name allein aus? Wir begrüßen diese Entwicklung, denn sie führt zu kürzeren Datei- und Klassennamen, die gezielter gewählt werden.</p>\n<p>Ein Beispiel aus der Praxis: Bei gerouteten Komponenten bevorzugen wir den Zusatz <code>page</code>, etwa <code>checkout-page.ts</code> (Klassenname <code>CheckoutPage</code>), weil er den Einsatzzweck klar macht – ohne sich auf technische Details wie <code>Component</code> zu beziehen. Eine Komponente, die nur Inhalte anzeigt und keine Logik enthält, könnten wir dann zum Beispiel <code>CheckoutView</code> nennen.</p>\n<p>Wer das bisherige Verhalten beibehalten möchte, kann beim Generieren weiterhin einen <code>type</code> angeben, aus dem ein Suffix erzeugt wird.\nDiese Einstellung kann in der Datei <code>angular.json</code> auch permanent gesetzt werden.</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> component book-card --<span class=\"hljs-keyword\">type</span>=component\n</code></pre>\n<h1 id=\"zoneless-developer-preview\">Zoneless Developer Preview</h1>\n<p>Das Angular-Team arbeitet seit mehreren Jahren daran, die <em>Synchronization</em> (auch <em>Change Detection</em>) im Framework zu optimieren.\nEin Meilenstein auf diesem Weg war die Einführung von Signals, die eine gezielte Erkennung von Änderungen ermöglichen.\nIn Zukunft muss Angular also nicht mehr auf die Bibliothek <em>zone.js</em> setzen, um Browserschnittstellen zu patchen und so die Change Detection auszulösen.</p>\n<p>Wir haben in unserem <a href=\"/blog/2024-06-angular18\">Blogpost zum Release von Angular 18</a> bereits ausführlich über die Change Detection und die Einstellung für eine &quot;Zoneless Application&quot; berichtet.</p>\n<p>Mit Angular 20 wird <em>zoneless</em> im Status <em>Developer Preview</em> veröffentlicht.\nDie Schnittstelle ist also weitgehend stabil. Trotzdem können kurzfristig Änderungen vorgenommen werden, sodass ein Einsatz in produktiven Anwendungen sorgfältig abgewägt werden sollte.</p>\n<p>Um die Zoneless Change Detection zu aktivieren, müssen wir die Funktion <code>provideZonelessChangeDetection()</code> verwenden.\nDas Wort <code>experimental</code> wurde aus dem Funktionsnamen entfernt.\nZusätzlich wird empfohlen, einen globalen Error Handler zu aktivieren, der Exceptions abfängt, die nicht im Anwendungscode behandelt werden.</p>\n<pre><code class=\"language-ts\">// app<span class=\"hljs-selector-class\">.config</span><span class=\"hljs-selector-class\">.ts</span>\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    <span class=\"hljs-built_in\">provideZonelessChangeDetection</span>(),\n    <span class=\"hljs-built_in\">provideBrowserGlobalErrorListeners</span>()\n};\n</code></pre>\n<p>Die Angular CLI bietet beim Anlegen eines neuen Projekts an, die Anwendung <em>zoneless</em> zu generieren:</p>\n<pre><code class=\"language-bash\">➜  ~ ng <span class=\"hljs-built_in\">new</span> my-app\n✔ <span class=\"hljs-keyword\">Do</span> you want <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">create</span> a <span class=\"hljs-string\">&#x27;zoneless&#x27;</span> application <span class=\"hljs-keyword\">without</span> <span class=\"hljs-type\">zone</span>.js (Developer Preview)? Yes\n</code></pre>\n<p>Die Einstellung kann auch über den neuen Parameter <code>zoneless</code> gesteuert werden, der bei Bedarf mit <code>no</code> negiert werden kann:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> my-app <span class=\"hljs-comment\">--zoneless</span>\nng <span class=\"hljs-keyword\">new</span> my-app <span class=\"hljs-comment\">--nozoneless</span>\n</code></pre>\n<h1 id=\"strukturdirektiven-ngif-ngfor-ngswitch\">Strukturdirektiven <code>ngIf</code>, <code>ngFor</code>, <code>ngSwitch</code></h1>\n<p>Mit Angular 20 werden die alten Direktiven <code>ngIf</code>, <code>ngFor</code> und <code>ngSwitch</code> als <em>deprecated</em> markiert.\nVoraussichtlich mit Angular 22 (in einem Jahr) werden diese Direktiven dann vollständig aus dem Framework entfernt.</p>\n<p>Hintergrund ist der neue Built-in Control Flow, der mit Angular 17 eingeführt wurde.\nDie Direktiven können also direkt durch die eingebauten Ausdrücke von Angular ersetzt werden: <code>@if</code>, <code>@for</code>, <code>@switch</code> und <code>@let</code>.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- mit Direktive (deprecated) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;condition&quot;</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- mit Control Flow --&gt;</span>\n@if (condition) {<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>}\n</code></pre>\n<p>In unserem <a href=\"/blog/2023-11-angular17#neuer-control-flow-if-for-switch\">Blogpost zum Release von Angular 17</a> haben wir die Syntax zum Control Flow ausführlich behandelt.\nDie Angular CLI bietet außerdem ein Migrationsskript an, sodass der Umstieg auf die neue Syntax nicht aufwendig sein sollte:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:control-flow\n</code></pre>\n<h1 id=\"experimenteller-test-builder-für-vitest\">Experimenteller Test-Builder für Vitest</h1>\n<p>Der Test-Runner Karma, der immer noch Standard für Unit- und Integrastionstests in Angular ist, wird nicht mehr weiterentwickelt.\nSeit dieser Entscheidung arbeitet das Angular-Team daran, einen alternativen Test-Runner in die Angular CLI zu integrieren.\nSchon vor zwei Jahren wurden experimentelle Builder für <a href=\"https://blog.angular.dev/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca\">Jest und Web Test Runner veröffentlicht</a>.\nMit Angular 20 kommt eine weitere experimentelle Integration für <a href=\"https://vitest.dev\">Vitest</a> dazu:\nVitest hat sich bereits in anderen Web-Frameworks basierend auf dem Bundler <a href=\"https://vite.dev\">Vite</a> als fester Bestandteil etabliert.\nDer Build-Prozess von Angular basiert bereits <a href=\"/blog/2023-05-angular16#esbuild\">seit Version 16 auf ESBuild mit Vite</a>.\nMit dieser schrittweisen Umstellung des Unterbaus können wir nun auch auf Vitest zurückgreifen, um Unit- und Integrationstests auszuführen.</p>\n<p>Welcher der experimentellen Test-Runner der neue Standard für Angular wird, ist damit noch nicht entschieden!\nAlle Ansätze sind experimentell und werden in den nächsten Monaten weiter evaluiert.</p>\n<p>Um Vitest mit der Angular CLI zu nutzen, müssen wir zunächst die benötigten Abhängigkeiten hinzufügen:</p>\n<pre><code class=\"language-sh\">npm <span class=\"hljs-selector-tag\">i</span> vitest jsdom <span class=\"hljs-attr\">--save-dev</span>\n</code></pre>\n<p>Anschließend müssen wir die Testing-Konfiguration in der Datei <code>angular.json</code> anpassen:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-string\">&quot;test&quot;</span>: {\n  <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>,\n  <span class=\"hljs-string\">&quot;options&quot;</span>: {\n      <span class=\"hljs-string\">&quot;tsConfig&quot;</span>: <span class=\"hljs-string\">&quot;tsconfig.spec.json&quot;</span>,\n      <span class=\"hljs-string\">&quot;buildTarget&quot;</span>: <span class=\"hljs-string\">&quot;::development&quot;</span>,\n      <span class=\"hljs-string\">&quot;runner&quot;</span>: <span class=\"hljs-string\">&quot;vitest&quot;</span>\n  }\n}\n</code></pre>\n<p>Jetzt müssen wir in unseren Tests die Funktionen von Vitest verwenden. Dazu sind die folgenden Imports notwendig:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, beforeEach, it, expect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>Die Ausführung erfolgt im Anschluss wie gewohnt mit <code>ng test</code>.</p>\n<p>Vitest ist zu einem großen Teil mit den Schnittstellen von <a href=\"https://jestjs.io/\">Jest</a> und auch mit Karma kompatibel – es lohnt sich auf jeden Fall, einmal den Umstieg auszuprobieren.\nIm Idealfall müssen Sie in den Tests nur wenige Anpassungen vornehmen.</p>\n<p>In Zukunft wird sich vermutlich einer der drei experimentellen Build (Jest, Web Test Runner, Vitest) als der neue Standard etablieren.\nWir begrüßen den Schritt, künftig auf etablierte Standards außerhalb der Angular-Welt zu setzen und den eigens entwickelten Test-Runner Karma abzuschaffen. Wir halten Sie hierzu weiterhin auf dem Laufenden.</p>\n<h1 id=\"stabile-signal-apis-effect-linkedsignal-und-tosignal\">Stabile Signal-APIs: <code>effect</code>, <code>linkedSignal</code> und <code>toSignal</code></h1>\n<p>Seit Angular 16 stehen mit Signals die Weichen auf ein neues, reaktives Angular. In Angular 20 wurden nun weitere APIs aus dem Signals-Ökosystem als stabil freigegeben: <code>effect</code>, <code>linkedSignal</code> und <code>toSignal</code>.</p>\n<p>Diese Funktionen waren bisher experimentell und sind nun offiziell als Teil des stabilen API-Sets nutzbar:</p>\n<ul>\n<li><code>effect()</code> reagiert automatisch auf Signal-Änderungen und führt dabei definierte Seiteneffekte aus – ganz ohne Lifecycle-Hooks.</li>\n<li><code>linkedSignal()</code> erlaubt die bidirektionale Kopplung zwischen einem Signal und einer externen Quelle – etwa einer Komponente oder einem FormControl.</li>\n<li><code>toSignal()</code> konvertiert Observable-Daten in ein lesbares Signal – ideal zur Integration bestehender Streams.</li>\n</ul>\n<p>Weitere Details und Beispiele finden Sie in unserer Signals-Reihe:</p>\n<ul>\n<li><a href=\"https://angular-buch.com/blog/2024-11-linked-signal\">Neu in Angular 19: LinkedSignal für reaktive Zustandsverwaltung</a></li>\n<li><a href=\"https://angular.schule/blog/2024-11-effect-afterrendereffect\">Angular 19: Mastering effect and afterRenderEffect</a></li>\n</ul>\n<h1 id=\"httpresource-daten-laden-mit-signals\">httpResource: Daten laden mit Signals</h1>\n<p>Im Oktober 2024 wurde bereits die neue experimentelle Resource API vorgestellt. Wir haben darüber ausführlich <a href=\"https://angular-buch.com/blog/2024-10-resource-api\">in einem Blogpost</a> berichtet.\nSie verbindet die synchrone Welt von Signals mit asynchron abrufbaren Daten, z. B. mittels HTTP.\nDie Daten werden mithilfe eines Loaders asynchron geladen und übr Signals bereitgestellt.</p>\n<p>Vor einigen Wochen wurde eine weitere Variante der Resource vorgestellt: <code>httpResource</code>.\nSie nutzt unter der Haube den <code>HttpClient</code> von Angular, um direkt einen HTTP-Request zu stellen.\nEs ist damit nicht mehr notwendig, den Request selbständig zu formulieren – darum kümmert sich die Resource.</p>\n<pre><code class=\"language-ts\">booksResource = httpResource&lt;Book[]&gt;(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">&#x27;https://api.example.org/books&#x27;</span>,\n  { <span class=\"hljs-attr\">defaultValue</span>: [] }\n);\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(booksResource.value())\n</code></pre>\n<p>Der Request muss mithilfe einer Funktion generiert werden.\nHintergrund ist, dass es sich dabei um eien <em>Reactive Context</em> handelt: Verwenden wir darin Signals, wird der Request automatisch neu ausgeführt, sobald eins der Signals seinen Wert ändert.\nWeitere Details für den Request können in einem Optionsobjekt übergeben werden.</p>\n<pre><code class=\"language-ts\">booksResource = httpResource&lt;Book[]&gt;(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n    url: <span class=\"hljs-string\">&#x27;https://api.example.org/books&#x27;</span>,\n    params: {\n      search: <span class=\"hljs-string\">&#x27;Angular&#x27;</span>\n    }\n  })\n);\n</code></pre>\n<p>Bitte beachten Sie, dass eine Resource ausschließlich dafür gedacht ist, Daten von einer Schnittstelle <em>abzurufen</em> und mit Signals bereitzustellen.\nSchreibende Operationen wie Erstellen, Aktualisieren oder Löschen können mit einer Resource nicht abgebildet werden.\nDafür müssen wir weiterhin direkt den <code>HttpClient</code> verwenden.</p>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Alle Details zu den Neuerungen finden Sie immer im Changelog von <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/main/CHANGELOG.md\">Angular CLI</a>.\nEinige interessante Aspekte haben wir hier zusammengetragen:</p>\n<ul>\n<li><strong><code>provideServerRouting()</code> deprecated:</strong> Die Funktion <code>provideServerRouting()</code> ist deprecated. Stattdessen wird die bestehende Funktion <code>provideServerRendering()</code> mit dem Feature <code>withRoutes()</code> verwendet. (siehe <a href=\"https://github.com/angular/angular-cli/commit/33b9de3eb1fa596a4d5a975d05275739f2f7b8ae\">Commit</a>)</li>\n<li><strong>Chrome Dev Tools:</strong> Die Integration von Angular in die Chrome Developer Tools wurde deutlich verbessert. Im <em>Performance</em>-Tab können die Change Detection und andere Prformance-Parameter von Angular untersucht werden.</li>\n<li><strong>Offizielles Maskottchen:</strong> Das Angular-Team möchte ein offizielles Maskottchen für das Framework einführen – und hier ist die Community gefragt! Nutzen Sie die Chance, im <a href=\"https://github.com/angular/angular/discussions/61733\">RFC auf GitHub</a> für Ihren Favoriten abzustimmen oder Ihre ehrliche Meinung zu äußern.</li>\n</ul>\n<hr>\n\n\n<p>Wir wünschen Ihnen viel Spaß beim Entwickeln mit Angular 20!\nHaben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß wünschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> TODO. Foto von XXX</small></p>\n","meta":{"title":"Angular 20 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2025-05-30T00:00:00.000Z","lastModified":"2025-05-30T00:00:00.000Z","keywords":["Angular","Angular 20","Strukturdirektiven","vitest","Component Suffix"],"language":"de","header":{"url":"angular20.jpg","width":2473,"height":1411},"sticky":true}}
