{"slug":"2025-05-angular20","html":"<p>Alles neu macht der Mai ‚Äì oder zumindest eine neue Major-Version von Angular:\nAm <strong>28. Mai 2025</strong> wurde <strong>Angular 20</strong> ver√∂ffentlicht! Im offiziellen <a href=\"https://blog.angular.dev/announcing-angular-v20-b5c9c06cf301\">Angular-Blog</a> finden Sie die Release-Informationen direkt vom Angular-Team.</p>\n<p>F√ºr die Migration auf Angular 20 empfehlen wir, den Befehl <code>ng update</code> zu nutzen.\nDetaillierte Infos zu den Schritten liefert der <a href=\"https://angular.dev/update-guide\">Angular Update Guide</a>.</p>\n<blockquote>\n<p><strong>üá¨üáß This article is available in English language here: <a href=\"https://angular.schule/blog/2025-05-angular20\">Angular 20 is here!</a></strong></p>\n</blockquote>\n<h2 id=\"versionen-von-typescript-und-nodejs\">Versionen von TypeScript und Node.js</h2>\n<p>F√ºr Angular 20 sind <em>mindestens</em> die folgenden Versionen von TypeScript und Node.js erforderlich:</p>\n<ul>\n<li>TypeScript: 5.8</li>\n<li>Node.js: 20.19.x oder h√∂her, 22.12.x oder h√∂her, oder 24.0.x oder h√∂her</li>\n</ul>\n<p>Der Support f√ºr Node.js Version 18 wurde entfernt. In der <a href=\"https://angular.dev/reference/versions\">Angular-Dokumentation</a> finden Sie ausf√ºhrliche Infos zu den unterst√ºtzten Versionen.</p>\n<h2 id=\"der-neue-coding-style-guide\">Der neue Coding Style Guide</h2>\n<p>Angular hat sich in den letzten Jahren stark weiterentwickelt und viele neue Konzepte wurden in das Framework integriert.\nDie Angular-Dokumentation war teilweise nicht auf dem aktuellsten Stand: Insbesondere der Coding Style Guide hatte noch keine Empfehlungen f√ºr den aktuellen Status Quo parat.\nMit Angular 20 hat sich das ge√§ndert:\nDer neue <a href=\"https://angular.dev/style-guide\">Style Guide</a> wurde stark √ºberarbeitet und verschlankt.\nEr beinhaltet aktuelle Empfehlungen und Best Practices und gilt als Leitlinie f√ºr die Entwicklung mit den aktuellen Versionen von Angular.</p>\n<h3 id=\"keine-suffixes-mehr-bewusstere-benennung-und-neue-patterns\">Keine Suffixes mehr: bewusstere Benennung und neue Patterns</h3>\n<p>Eine wichtige √Ñnderung, die nicht unerw√§hnt bleiben sollte, betrifft die Suffixe in Datei- und Klassennamen:\nDer neue Style Guide empfiehlt <em>nicht</em> mehr, Komponenten, Services und Direktiven mit einem Suffix zu versehen.\nAb Angular 20 generiert die CLI standardm√§√üig keine Suffixes wie <code>.component.ts</code> oder <code>.service.ts</code> mehr. Diese neue Einstellung greift nat√ºrlich nur bei neu angelegten Projekten.</p>\n<p>Der Befehl <code>ng generate component book-card</code> erzeugt also die folgende Ausgabe:</p>\n<p><strong>bis Angular 19:</strong></p>\n<pre><code><span class=\"hljs-attribute\">src</span>/app\n  book-card\n    book-card<span class=\"hljs-selector-class\">.component</span><span class=\"hljs-selector-class\">.ts</span>\n    book-card<span class=\"hljs-selector-class\">.component</span><span class=\"hljs-selector-class\">.html</span>\n    book-card<span class=\"hljs-selector-class\">.component</span><span class=\"hljs-selector-class\">.scss</span>\n    book-card<span class=\"hljs-selector-class\">.component</span><span class=\"hljs-selector-class\">.spec</span>.ts\n</code></pre>\n<pre><code class=\"language-ts\">// book-card.component.ts\n// ...\n<span class=\"hljs-variable\">@Component</span>(<span class=\"hljs-regexp\">/* ... */</span>)\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookCardComponent</span> </span>{}\n</code></pre>\n<p><strong>ab Angular 20:</strong></p>\n<pre><code>src/app\n  book-<span class=\"hljs-keyword\">card</span>\n    book-<span class=\"hljs-keyword\">card</span>.ts\n    book-<span class=\"hljs-keyword\">card</span>.html\n    book-<span class=\"hljs-keyword\">card</span>.scss\n    book-<span class=\"hljs-keyword\">card</span>.spec.ts\n</code></pre>\n<pre><code class=\"language-ts\">// book-card.ts\n// ...\n<span class=\"hljs-variable\">@Component</span>(<span class=\"hljs-regexp\">/* ... */</span>)\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookCard</span> </span>{}\n</code></pre>\n<p>Das Ziel dahinter: Angular-Anwendungen sollen weniger Boilerplate enthalten, und wir sollen uns bewusster mit der Benennung der Abstraktionen auseinandersetzen. Statt automatisch generierter Konstrukte wie <code>product-detail.component.ts</code>, ist nun mehr eigenes Nachdenken gefragt: Wie hei√üt diese Klasse? Was macht sie? Und wie viel sagt der Name allein aus? Wir begr√º√üen diese Entwicklung, denn sie f√ºhrt zu k√ºrzeren Datei- und Klassennamen, die gezielter gew√§hlt werden.</p>\n<p>Ein Beispiel aus der Praxis: Bei gerouteten Komponenten bevorzugen wir den Zusatz <code>page</code>, etwa <code>checkout-page.ts</code> (Klassenname <code>CheckoutPage</code>), weil er den Einsatzzweck klar macht ‚Äì ohne sich auf technische Details wie <code>Component</code> zu beziehen. Eine Komponente, die nur Inhalte anzeigt und keine Logik enth√§lt, k√∂nnten wir dann zum Beispiel <code>CheckoutView</code> nennen.</p>\n<p>Wer das bisherige Verhalten beibehalten m√∂chte, kann beim Generieren weiterhin einen <code>type</code> angeben, aus dem ein Suffix erzeugt wird.\nDiese Einstellung kann in der Datei <code>angular.json</code> auch permanent gesetzt werden.</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> component book-card --<span class=\"hljs-keyword\">type</span>=component\n</code></pre>\n<h2 id=\"zoneless-developer-preview\">Zoneless Developer Preview</h2>\n<p>Das Angular-Team arbeitet seit mehreren Jahren daran, die <em>Synchronization</em> (auch <em>Change Detection</em>) im Framework zu optimieren.\nEin Meilenstein auf diesem Weg war die Einf√ºhrung von Signals, die eine gezielte Erkennung von √Ñnderungen erm√∂glichen.\nIn Zukunft muss Angular also nicht mehr auf die Bibliothek <em>zone.js</em> setzen, um Browserschnittstellen zu patchen und so die Change Detection auszul√∂sen.</p>\n<p>Wir haben in unserem <a href=\"/blog/2024-06-angular18\">Blogpost zum Release von Angular 18</a> bereits ausf√ºhrlich √ºber die Change Detection und die Einstellung f√ºr eine &quot;Zoneless Application&quot; berichtet.</p>\n<p>Mit Angular 20 wird <em>zoneless</em> im Status <em>Developer Preview</em> ver√∂ffentlicht.\nDie Schnittstelle ist also weitgehend stabil. Trotzdem k√∂nnen kurzfristig √Ñnderungen vorgenommen werden, sodass ein Einsatz in produktiven Anwendungen sorgf√§ltig abgew√§gt werden sollte.</p>\n<p>Um die Zoneless Change Detection zu aktivieren, m√ºssen wir die Funktion <code>provideZonelessChangeDetection()</code> verwenden.\nDas Wort <code>experimental</code> wurde aus dem Funktionsnamen entfernt.\nZus√§tzlich wird empfohlen, einen globalen Error Handler zu aktivieren, der Exceptions abf√§ngt, die nicht im Anwendungscode behandelt werden.</p>\n<pre><code class=\"language-ts\">// app<span class=\"hljs-selector-class\">.config</span><span class=\"hljs-selector-class\">.ts</span>\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    <span class=\"hljs-built_in\">provideZonelessChangeDetection</span>(),\n    <span class=\"hljs-built_in\">provideBrowserGlobalErrorListeners</span>()\n};\n</code></pre>\n<p>Die Angular CLI bietet beim Anlegen eines neuen Projekts an, die Anwendung <em>zoneless</em> zu generieren:</p>\n<pre><code class=\"language-bash\">‚ûú  ~ ng <span class=\"hljs-built_in\">new</span> my-app\n‚úî <span class=\"hljs-keyword\">Do</span> you want <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">create</span> a <span class=\"hljs-string\">&#x27;zoneless&#x27;</span> application <span class=\"hljs-keyword\">without</span> <span class=\"hljs-type\">zone</span>.js (Developer Preview)? Yes\n</code></pre>\n<p>Die Einstellung kann auch √ºber den neuen Parameter <code>zoneless</code> gesteuert werden, der bei Bedarf mit <code>no</code> negiert werden kann:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">new</span> my-app <span class=\"hljs-comment\">--zoneless</span>\nng <span class=\"hljs-keyword\">new</span> my-app <span class=\"hljs-comment\">--no-zoneless</span>\n</code></pre>\n<h2 id=\"strukturdirektiven-ngif-ngfor-ngswitch\">Strukturdirektiven <code>ngIf</code>, <code>ngFor</code>, <code>ngSwitch</code></h2>\n<p>Mit Angular 20 werden die alten Direktiven <code>ngIf</code>, <code>ngFor</code> und <code>ngSwitch</code> als <em>deprecated</em> markiert.\nVoraussichtlich mit Angular 22 (in einem Jahr) werden diese Direktiven dann vollst√§ndig aus dem Framework entfernt.</p>\n<p>Hintergrund ist der neue Built-in Control Flow, der mit Angular 17 eingef√ºhrt wurde.\nDie Direktiven k√∂nnen also direkt durch die eingebauten Ausdr√ºcke von Angular ersetzt werden: <code>@if</code>, <code>@for</code>, <code>@switch</code> und <code>@let</code>.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!-- mit Direktive (deprecated) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;condition&quot;</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- mit Control Flow --&gt;</span>\n@if (condition) {<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>}\n</code></pre>\n<p>In unserem <a href=\"/blog/2023-11-angular17#neuer-control-flow-if-for-switch\">Blogpost zum Release von Angular 17</a> haben wir die Syntax zum Control Flow ausf√ºhrlich behandelt.\nDie Angular CLI bietet au√üerdem ein Migrationsskript an, sodass der Umstieg auf die neue Syntax nicht aufwendig sein sollte:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:control-flow\n</code></pre>\n<h2 id=\"experimenteller-test-builder-f√ºr-vitest\">Experimenteller Test-Builder f√ºr Vitest</h2>\n<p>Der Test-Runner Karma, der immer noch Standard f√ºr Unit- und Integrationstests in Angular ist, wird nicht mehr weiterentwickelt.\nSeit dieser Entscheidung arbeitet das Angular-Team daran, einen alternativen Test-Runner in die Angular CLI zu integrieren.\nSchon vor zwei Jahren wurden experimentelle Builder f√ºr <a href=\"https://blog.angular.dev/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca\">Jest und Web Test Runner ver√∂ffentlicht</a>.\nMit Angular 20 kommt eine weitere experimentelle Integration f√ºr <a href=\"https://vitest.dev\">Vitest</a> dazu:\nVitest hat sich bereits in anderen Web-Frameworks basierend auf dem Bundler <a href=\"https://vite.dev\">Vite</a> als fester Bestandteil etabliert.\nDer Build-Prozess von Angular basiert bereits <a href=\"/blog/2023-05-angular16#esbuild\">seit Version 16 auf ESBuild mit Vite</a>.\nMit dieser schrittweisen Umstellung des Unterbaus k√∂nnen wir nun auch auf Vitest zur√ºckgreifen, um Unit- und Integrationstests auszuf√ºhren.</p>\n<p>Welcher der experimentellen Test-Runner der neue Standard f√ºr Angular wird, ist damit noch nicht entschieden!\nAlle Ans√§tze sind experimentell und werden in den n√§chsten Monaten weiter evaluiert.</p>\n<p>Um Vitest mit der Angular CLI zu nutzen, m√ºssen wir zun√§chst die ben√∂tigten Abh√§ngigkeiten hinzuf√ºgen:</p>\n<pre><code class=\"language-sh\">npm <span class=\"hljs-selector-tag\">i</span> vitest jsdom <span class=\"hljs-attr\">--save-dev</span>\n</code></pre>\n<p>Anschlie√üend m√ºssen wir die Testing-Konfiguration in der Datei <code>angular.json</code> anpassen:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-string\">&quot;test&quot;</span>: {\n  <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>,\n  <span class=\"hljs-string\">&quot;options&quot;</span>: {\n      <span class=\"hljs-string\">&quot;tsConfig&quot;</span>: <span class=\"hljs-string\">&quot;tsconfig.spec.json&quot;</span>,\n      <span class=\"hljs-string\">&quot;buildTarget&quot;</span>: <span class=\"hljs-string\">&quot;::development&quot;</span>,\n      <span class=\"hljs-string\">&quot;runner&quot;</span>: <span class=\"hljs-string\">&quot;vitest&quot;</span>\n  }\n}\n</code></pre>\n<p>Jetzt m√ºssen wir in unseren Tests die Funktionen von Vitest verwenden. Dazu sind die folgenden Imports notwendig:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, beforeEach, it, expect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>Die Ausf√ºhrung erfolgt im Anschluss wie gewohnt mit <code>ng test</code>.</p>\n<p>Vitest ist zu einem gro√üen Teil mit den Schnittstellen von <a href=\"https://jestjs.io/\">Jest</a> und auch mit Karma kompatibel ‚Äì es lohnt sich auf jeden Fall, einmal den Umstieg auszuprobieren.\nIm Idealfall m√ºssen Sie in den Tests nur wenige Anpassungen vornehmen.</p>\n<p>In Zukunft wird sich vermutlich einer der drei experimentellen Build (Jest, Web Test Runner, Vitest) als der neue Standard etablieren.\nWir begr√º√üen den Schritt, k√ºnftig auf etablierte Standards au√üerhalb der Angular-Welt zu setzen und den eigens entwickelten Test-Runner Karma abzuschaffen. Wir halten Sie hierzu weiterhin auf dem Laufenden.</p>\n<h2 id=\"stabile-signal-apis-effect-linkedsignal-und-tosignal\">Stabile Signal-APIs: <code>effect</code>, <code>linkedSignal</code> und <code>toSignal</code></h2>\n<p>Seit Angular 16 stehen mit Signals die Weichen auf ein neues, reaktives Angular. In Angular 20 wurden nun weitere APIs aus dem Signals-√ñkosystem als stabil freigegeben: <code>effect</code>, <code>linkedSignal</code> und <code>toSignal</code>.</p>\n<p>Diese Funktionen waren bisher experimentell und sind nun offiziell als Teil des stabilen API-Sets nutzbar:</p>\n<ul>\n<li><code>effect()</code> reagiert automatisch auf Signal-√Ñnderungen und f√ºhrt dabei definierte Seiteneffekte aus ‚Äì ganz ohne Lifecycle-Hooks.</li>\n<li><code>linkedSignal()</code> erlaubt die bidirektionale Kopplung zwischen einem Signal und einer externen Quelle ‚Äì etwa einer Komponente oder einem FormControl.</li>\n<li><code>toSignal()</code> konvertiert Observable-Daten in ein lesbares Signal ‚Äì ideal zur Integration bestehender Streams.</li>\n</ul>\n<p>Weitere Details und Beispiele finden Sie in unserer Signals-Reihe:</p>\n<ul>\n<li><a href=\"https://angular-buch.com/blog/2024-11-linked-signal\">Neu in Angular 19: LinkedSignal f√ºr reaktive Zustandsverwaltung</a></li>\n<li><a href=\"https://angular.schule/blog/2024-11-effect-afterrendereffect\">Angular 19: Mastering effect and afterRenderEffect</a></li>\n</ul>\n<h2 id=\"httpresource-daten-laden-mit-signals\">httpResource: Daten laden mit Signals</h2>\n<p>Im Oktober 2024 wurde bereits die neue experimentelle Resource API vorgestellt. Wir haben dar√ºber ausf√ºhrlich <a href=\"https://angular-buch.com/blog/2024-10-resource-api\">in einem Blogpost</a> berichtet.\nSie verbindet die synchrone Welt von Signals mit asynchron abrufbaren Daten, z. B. mittels HTTP.\nDie Daten werden mithilfe eines Loaders asynchron geladen und √ºber Signals bereitgestellt.</p>\n<p>Vor einigen Wochen wurde eine weitere Variante der Resource vorgestellt: <code>httpResource</code>.\nSie nutzt unter der Haube den <code>HttpClient</code> von Angular, um direkt einen HTTP-Request zu stellen.\nEs ist damit nicht mehr notwendig, den Request selbst√§ndig zu formulieren ‚Äì darum k√ºmmert sich die Resource.</p>\n<pre><code class=\"language-ts\">booksResource = httpResource&lt;Book[]&gt;(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">&#x27;https://api.example.org/books&#x27;</span>,\n  { <span class=\"hljs-attr\">defaultValue</span>: [] }\n);\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(booksResource.value())\n</code></pre>\n<p>Der Request muss mithilfe einer Funktion generiert werden.\nHintergrund ist, dass es sich dabei um einen <em>Reactive Context</em> handelt: Verwenden wir darin Signals, wird der Request automatisch neu ausgef√ºhrt, sobald eins der Signals seinen Wert √§ndert.\nWeitere Details f√ºr den Request k√∂nnen in einem Optionsobjekt √ºbergeben werden.</p>\n<pre><code class=\"language-ts\">booksResource = httpResource&lt;Book[]&gt;(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n    url: <span class=\"hljs-string\">&#x27;https://api.example.org/books&#x27;</span>,\n    params: {\n      search: <span class=\"hljs-string\">&#x27;Angular&#x27;</span>\n    }\n  })\n);\n</code></pre>\n<p>Bitte beachten Sie, dass eine Resource ausschlie√ülich daf√ºr gedacht ist, Daten von einer Schnittstelle <em>abzurufen</em> und mit Signals bereitzustellen.\nSchreibende Operationen wie Erstellen, Aktualisieren oder L√∂schen k√∂nnen mit einer Resource nicht abgebildet werden.\nDaf√ºr m√ºssen wir weiterhin direkt den <code>HttpClient</code> verwenden.</p>\n<h2 id=\"anpassungen-bei-resource-und-rxresource\">Anpassungen bei <code>resource</code> und <code>rxResource</code></h2>\n<p>Die Resource API ist auch mit Angular 20 weiterhin noch als <em>experimental</em> markiert.\nDas bedeutet unter anderem, dass die Schnittstelle ohne offizielle Vorwarnung ge√§ndert werden kann.\nHier gab es k√ºrzlich zwei interessante Anpassungen.</p>\n<p>Wir haben unseren umfangreichen <a href=\"https://angular-buch.com/blog/2024-10-resource-api\">Blogpost zur Resource API</a> entsprechend aktualisiert, sodass Sie dort stets aktuelle Beispiele finden.</p>\n<h3 id=\"resource-params-statt-request\">resource: <code>params</code> statt <code>request</code></h3>\n<p>Die Parameter f√ºr eine Resource werden nun im Property <code>params</code> √ºbergeben, nicht mehr in <code>request</code>.\nAuch das Property im Interface <code>ResourceLoaderParams</code>, aus dem wir die Parameter auslesen, hei√üt nun <code>params</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-regexp\">//</span> ‚ùå VORHER\nbooksResource = resource({\n  request: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.isbn(),\n  loader: <span class=\"hljs-function\"><span class=\"hljs-params\">({ request })</span> =&gt;</span> this.<span class=\"hljs-comment\">#bs.getSingle(request)</span>\n});\n\n<span class=\"hljs-regexp\">//</span> ‚úÖ NACHHER\nbooksResource = resource({\n  params: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.isbn(),\n  loader: <span class=\"hljs-function\"><span class=\"hljs-params\">({ params })</span> =&gt;</span> this.<span class=\"hljs-comment\">#bs.getSingle(params)</span>\n});\n</code></pre>\n<p>Wir begr√º√üen diese √Ñnderung sehr, weil die Begriffe &quot;Request&quot; und &quot;Loader&quot; bisher leicht verwechselt werden konnten.\nMit dem Begriff &quot;Params&quot; ist nun klarer, dass es sich um Parameter sind, die den Loader triggern.</p>\n<h3 id=\"rxresource-stream-statt-loader\">rxResource: <code>stream</code> statt <code>loader</code></h3>\n<p>Die <code>rxResource</code> ist eine besondere Variante der Resource, die als Loader ein Observable aus RxJS verwendet (die einfache Resource erwartet eine Promise als Loader).\nEin Observable kann beliebig viele Elemente liefern, deshalb passt der Begriff &quot;Loader&quot; nicht in jedem Fall.\nDas Property wurde deshalb zu <code>stream</code> umbenannt.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-regexp\">//</span> ‚ùå VORHER\nbooksResource = rxResource({\n  loader: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.<span class=\"hljs-comment\">#bs.getAll()</span>\n});\n\n<span class=\"hljs-regexp\">//</span> ‚úÖ NACHHER\nbooksResource = rxResource({\n  stream: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.<span class=\"hljs-comment\">#bs.getAll()</span>\n});\n</code></pre>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Alle Details zu den Neuerungen finden Sie immer im Changelog von <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/main/CHANGELOG.md\">Angular CLI</a>.\nEinige interessante Aspekte haben wir hier zusammengetragen:</p>\n<ul>\n<li><strong><code>provideServerRouting()</code> deprecated:</strong> Die Funktion <code>provideServerRouting()</code> ist deprecated. Stattdessen wird die bestehende Funktion <code>provideServerRendering()</code> mit dem Feature <code>withRoutes()</code> verwendet. (siehe <a href=\"https://github.com/angular/angular-cli/commit/33b9de3eb1fa596a4d5a975d05275739f2f7b8ae\">Commit</a>)</li>\n<li><strong>Chrome DevTools:</strong> Die Integration von Angular in die Chrome Developer Tools wurde deutlich verbessert. Im <em>Performance</em>-Tab k√∂nnen die Change Detection und andere Performance-Parameter von Angular untersucht werden.</li>\n<li><strong>Offizielles Maskottchen:</strong> Das Angular-Team m√∂chte ein offizielles Maskottchen f√ºr das Framework einf√ºhren ‚Äì und hier ist die Community gefragt! Nutzen Sie die Chance, im <a href=\"https://github.com/angular/angular/discussions/61733\">RFC auf GitHub</a> f√ºr Ihren Favoriten abzustimmen oder Ihre ehrliche Meinung zu √§u√üern.</li>\n</ul>\n<hr>\n\n\n<p>Wir w√ºnschen Ihnen viel Spa√ü beim Entwickeln mit Angular 20!\nHaben Sie Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreiben Sie uns!</p>\n<p><strong>Viel Spa√ü w√ºnschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Morgenstimmung im Anklamer Stadtbruch. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 20 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2025-05-30T00:00:00.000Z","lastModified":"2025-06-18T00:00:00.000Z","keywords":["Angular","Angular 20","Strukturdirektiven","vitest","Component Suffix"],"language":"de","header":{"url":"angular20.jpg","width":2473,"height":1411},"sticky":false,"isUpdatePost":true}}
