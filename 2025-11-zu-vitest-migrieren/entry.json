{"slug":"2025-11-zu-vitest-migrieren","html":"<p>Mit Angular 21 gibt es eine bedeutende Änderung beim Unit-Testing:\nVitest ist jetzt der Standard, die bisherige Standardkombination aus Karma und Jasmine wird abgelöst.\nBeim Erzeugen eines neuen Projekts mit <code>ng new</code> verwendet Angular 21 nun standardmäßig <strong>Vitest</strong> als Test-Runner.\nVitest verspricht deutlich kürzere Startzeiten, moderne Features und eine einfache Jest-kompatible API.\nIn diesem Artikel zeigen wir, was Vitest für dich bedeutet, wie du bestehende Angular-Projekte migrieren kannst und welche Vorteile Vitest bietet.</p>\n<h2 id=\"inhalt\">Inhalt</h2>\n<ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#warum-angular-karma-und-jasmine-ersetzt\">Warum Angular Karma und Jasmine ersetzt</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#migrationsleitfaden-von-karmajasmine-zu-vitest\">Migrationsleitfaden: Von Karma/Jasmine zu Vitest</a><ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#manuelle-migrationsschritte\">Manuelle Migrationsschritte</a><ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#1-abh%C3%A4ngigkeiten-installieren\">1. Abhängigkeiten installieren</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#2-angularjson-aktualisieren\">2. <code>angular.json</code> aktualisieren</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#3-eigene-karmaconfjskonfiguration-ber%C3%BCcksichtigen\">3. Eigene <code>karma.conf.js</code>‑Konfiguration berücksichtigen</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#4-karma--und-testtsdateien-entfernen\">4. Karma- und <code>test.ts</code>‑Dateien entfernen</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#5-browsermodus-konfigurieren-optional\">5. Browser‑Modus konfigurieren (optional)</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#automatisches-testrefactoring-per-schematic\">Automatisches Test‑Refactoring per Schematic</a><ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#1-%C3%BCberblick\">1. Überblick</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#2-schematic-ausf%C3%BChren\">2. Schematic ausführen</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#3-nach-der-migration\">3. Nach der Migration</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#4-benutzerdefinierte-konfiguration-optional\">4. Benutzerdefinierte Konfiguration (optional)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#die-neue-syntax-und-apis\">Die neue Syntax und APIs</a><ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#globale-funktionen\">Globale Funktionen</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#matcher\">Matcher</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#spies-und-mocks\">Spies und Mocks</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#asynchronit%C3%A4t-ohne-zonejs-aber-mit-vitest-timer\">Asynchronität ohne Zone.js aber mit Vitest Timer</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#testbed-und-componentfixture\">TestBed und ComponentFixture</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#bekannte-einschr%C3%A4nkungen-und-fallstricke\">Bekannte Einschränkungen und Fallstricke</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#fazit\">Fazit</a></li>\n</ul>\n<h2 id=\"warum-angular-karma-und-jasmine-ersetzt\">Warum Angular Karma und Jasmine ersetzt</h2>\n<p><em>Karma und Jasmine</em> haben für Angular lange Jahre gute Dienste geleistet, vor allem wegen der Ausführung in einem echten Browser.\nEs gab aber Nachteile: die Ausführungsgeschwindigkeit war nie optimal und das Ökosystem ist veraltet (<a href=\"https://github.com/karma-runner/karma#karma-is-deprecated-and-is-not-accepting-new-features-or-general-bug-fixes\">Karma ist seit 2023 deprecated</a>). \nÜber mehrere Jahre prüfte das Angular-Team Alternativen (Jest, Web Test Runner usw.), ohne einen klaren Gewinner zu finden.\n<a href=\"https://vitest.dev/\">Vitest</a> wurde inzwischen äußerst populär und erwies sich als passende Lösung.</p>\n<p>Vitest passte besonders gut, da es einen echten Browser-Modus bietet.\nWie zuvor bei Karma können Tests in einem realen Browser mit &quot;echtem&quot; DOM und echten Ereignissen ausgeführt werden.\nDer Browser-Modus wurde erst kürzlich mit Vitest 4 im Oktober 2025 <a href=\"https://vitest.dev/blog/vitest-4.html#browser-mode-is-stable\">als stabil deklariert</a>.\nGleichzeitig ist Vitest schnell und modern: Es baut auf <a href=\"https://vite.dev/\">Vite</a> auf, ist ESM- und TypeScript-first und sorgt für äußerst kurze Start- und Wiederholungszeiten.\nDazu kommt eine sehr mächtige API mit Snapshot-Tests, flexiblen <a href=\"https://vitest.dev/guide/mocking/timers.html\">Fake-Timern</a>, dem wirklich nützlichen Helfer <a href=\"https://vitest.dev/api/expect.html#poll\"><code>expect.poll</code></a>, <a href=\"https://vitest.dev/guide/test-context\">Test-Fixtures</a> und Jest-kompatiblen Matchern.\nNicht zuletzt ist Vitest im gesamten Frontend-Ökosystem weit verbreitet, wodurch vorhandenes Know-how gut übertragen werden kann.\nKurz gesagt: Der Wechsel sorgt für Tempo, eine deutlich bessere Developer Experience und Zukunftssicherheit und hält dabei weiterhin die Möglichkeit echter Browser-Tests offen.</p>\n<h2 id=\"migrationsleitfaden-von-karmajasmine-zu-vitest\">Migrationsleitfaden: Von Karma/Jasmine zu Vitest</h2>\n<!-- Quelle: https://github.com/angular/angular/blob/6178e3ebfbc69a2afa04dd19ea4d6d8b1bfb0649/adev/src/content/guide/testing/migrating-to-vitest.md -->\n\n<p>Wenn du ein <strong>neues Projekt</strong> mit Angular 21 erzeugen möchtest, nutzt die Angular CLI standardmäßig den neuen Test-Runner Vitest.\nDie Wahl kannst du über die Option <code>--test-runner</code> beeinflussen:\nMit <code>--test-runner=vitest</code> erhältst du die neue, schnellere und modernere Standardlösung. \nMöchtest du dagegen weiterhin bei der bewährten Karma/Jasmine-Kombination bleiben, verwende die Option <code>--test-runner=karma</code>.\nOhne explizite Angabe der Option wird automatisch Vitest verwendet.</p>\n<p>Um ein <strong>bestehendes Projekt</strong> auf Angular 21 und Vitest zu migrieren, musst du zunächst das Projekt mittels <code>ng update</code> auf Version 21 aktualisieren.\nBeachte dabei, dass die Migration bestehender Projekte zu Vitest aktuell noch <strong>experimentell</strong> ist.\nAußerdem setzt dieser Prozess das <code>application</code>-Buildsystem von Angular voraus, das bei neu erstellten Projekten standardmäßig aktiviert ist.\nNachdem dein Projekt auf Version 21 aktualisiert wurde, kannst du mit den folgenden Schritten fortfahren.</p>\n<h3 id=\"manuelle-migrationsschritte\">Manuelle Migrationsschritte</h3>\n<p>Bevor du das automatische Refactoring‑Schematic verwendest, musst du dein Projekt manuell so anpassen, dass Vitest als Test‑Runner verwendet wird.</p>\n<h4 id=\"1-abhängigkeiten-installieren\">1. Abhängigkeiten installieren</h4>\n<p>Installiere <code>vitest</code> sowie eine DOM‑Emulationsbibliothek. \nObwohl Tests weiterhin im Browser ausgeführt werden können (siehe Schritt 5), verwendet Vitest standardmäßig eine DOM‑Emulation, um eine Browserumgebung in Node.js zu simulieren und Tests schneller auszuführen. \nDie CLI erkennt automatisch <code>happy-dom</code>, falls es installiert ist; ansonsten greift sie auf <code>jsdom</code> zurück. \nEines der beiden Pakete muss vorhanden sein.</p>\n<pre><code class=\"language-bash\">npm install --<span class=\"hljs-built_in\">save</span>-<span class=\"hljs-built_in\">dev</span> vitest jsdom\n</code></pre>\n<h4 id=\"2-angularjson-aktualisieren\">2. <code>angular.json</code> aktualisieren</h4>\n<p>Suche in der Datei <code>angular.json</code> das <code>test</code>-Target deines Projekts und setze den <code>builder</code> auf <code>@angular/build:unit-test</code>.</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Der <code>unit-test</code>‑Builder verwendet standardmäßig <code>&quot;tsConfig&quot;: &quot;tsconfig.spec.json&quot;</code> und <code>&quot;buildTarget&quot;: &quot;::development&quot;</code>. \nFalls dein Projekt andere Werte benötigt, etwa weil die <code>development</code>-Konfiguration fehlt oder spezielle Test‑Einstellungen nötig sind, kannst du eine eigene Build-Konfiguration anlegen und zuweisen, z. B. <code>testing</code>.</p>\n<p>Der vorherige Builder <code>@angular/build:karma</code> erlaubte es, Build‑Optionen (wie <code>polyfills</code>, <code>assets</code>, <code>styles</code>) direkt im <code>test</code>-Target zu definieren. Der neue Builder <code>@angular/build:unit-test</code> unterstützt das nicht. \nFalls sich deine Test‑Build‑Optionen von der <code>development</code>-Konfiguration unterscheiden, musst du diese Optionen in eine eigene Build-Konfiguration verschieben. \nStimmen sie bereits mit <code>development</code> überein, ist kein weiterer Schritt notwendig.</p>\n<blockquote>\n<p><strong>Tipp:</strong> Alternativ kannst du einfach ein neues Projekt mittels <code>ng new</code> erzeugen und die relevanten Abschnitte aus der neu generierten <code>angular.json</code> in dein bestehendes Projekt übernehmen. \nSo erhältst du automatisch eine saubere Vorlage für die Vitest-Konfiguration.</p>\n</blockquote>\n<h4 id=\"3-eigene-karmaconfjskonfiguration-berücksichtigen\">3. Eigene <code>karma.conf.js</code>‑Konfiguration berücksichtigen</h4>\n<p>Eigene Einstellungen aus der Datei <code>karma.conf.js</code> werden nicht automatisch migriert. \nPrüfe diese Datei, bevor du sie löschst, und übertrage relevante Optionen manuell.\nViele Karma‑Optionen besitzen Vitest‑Entsprechungen, die du in einer <code>vitest.config.ts</code> definieren kannst und dann über <code>runnerConfig</code> in der <code>angular.json</code> einbindest.</p>\n<p>Typische Migrationspfade:</p>\n<ul>\n<li><strong>Reporter:</strong> Karma‑Reporter müssen durch Vitest‑kompatible Reporter ersetzt werden. Viele davon können direkt in <code>angular.json</code> unter <code>test.options.reporters</code> konfiguriert werden. Für komplexere Fälle nutze <code>vitest.config.ts</code>.</li>\n<li><strong>Plugins:</strong> Karma‑Plugins erfordern passende Vitest‑Alternativen. Beachte, dass Code‑Coverage in der Angular CLI bereits integriert ist und über <code>ng test --coverage</code> aktiviert werden kann.</li>\n<li><strong>Eigene Browser‑Launcher:</strong> Diese werden durch die Option <code>browsers</code> in der <code>angular.json</code> und die Installation eines Browser‑Providers wie <code>@vitest/browser-playwright</code> ersetzt.</li>\n</ul>\n<p>Weitere Einstellungen findest du in der offiziellen <a href=\"https://vitest.dev/config/\">Vitest‑Dokumentation</a>.</p>\n<h4 id=\"4-karma--und-testtsdateien-entfernen\">4. Karma- und <code>test.ts</code>‑Dateien entfernen</h4>\n<p>Du kannst nun die Dateien <code>karma.conf.js</code> sowie <code>src/test.ts</code> löschen und alle Karma‑bezogenen Pakete deinstallieren. \nDie folgenden Befehle entsprechen einem Standard‑Angular‑Projekt.\nIn deinem Projekt können weitere Pakete vorhanden sein.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> uninstall karma karma-chrome-launcher karma-coverage karma-jasmine karma-jasmine-html-reporter\n</code></pre>\n<h4 id=\"5-browsermodus-konfigurieren-optional\">5. Browser‑Modus konfigurieren (optional)</h4>\n<p>Falls du Tests in einem echten Browser ausführen möchtest, musst du einen Browser-Provider installieren und die <code>angular.json</code> anpassen.\nWähle je nach Bedarf:</p>\n<ul>\n<li><strong>Playwright:</strong> <code>@vitest/browser-playwright</code> für Chromium, Firefox und WebKit</li>\n<li><strong>WebdriverIO:</strong> <code>@vitest/browser-webdriverio</code> für Chrome, Firefox, Safari und Edge</li>\n<li><strong>Preview:</strong> <code>@vitest/browser-preview</code> für WebContainer-Umgebungen wie StackBlitz</li>\n</ul>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> install --save-dev @vitest/browser-playwright\n</code></pre>\n<p>Danach musst du noch die <code>angular.json</code> erweitern.\nFüge im <code>test</code>-Target die Option <code>browsers</code> hinzu.\nDer Browsername hängt vom verwendeten Provider ab (z. B. <code>chromium</code> bei Playwright).</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>,\n          <span class=\"hljs-string\">&quot;options&quot;</span>: {\n            <span class=\"hljs-string\">&quot;browsers&quot;</span>: [<span class=\"hljs-string\">&quot;chromium&quot;</span>]\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Der Headless‑Modus wird automatisch aktiviert, wenn die Umgebungsvariable <code>CI</code> gesetzt ist oder der Browsername &quot;Headless&quot; enthält (z. B. <code>ChromeHeadless</code>). \nAndernfalls läuft der Browser sichtbar.</p>\n<h3 id=\"automatisches-testrefactoring-per-schematic\">Automatisches Test‑Refactoring per Schematic</h3>\n<p>Das Angular CLI stellt ein Schematic bereit, das deine Jasmine‑Tests automatisch auf Vitest umstellt.</p>\n<p><strong>WICHTIG:</strong> Das Schematic <code>refactor-jasmine-vitest</code> ist experimentell und deckt nicht alle Patterns ab.\nÜberprüfe die Änderungen immer manuell.</p>\n<h4 id=\"1-überblick\">1. Überblick</h4>\n<p>Derzeit führt das Schematic folgende Umwandlungen in Dateien mit der Endung <code>.spec.ts</code> durch:</p>\n<ul>\n<li><code>fit</code>/<code>fdescribe</code> → <code>it.only</code>/<code>describe.only</code></li>\n<li><code>xit</code>/<code>xdescribe</code> → <code>it.skip</code>/<code>describe.skip</code></li>\n<li><code>spyOn</code> → <code>vi.spyOn</code></li>\n<li><code>jasmine.objectContaining</code> → <code>expect.objectContaining</code></li>\n<li><code>jasmine.any</code> → <code>expect.any</code></li>\n<li><code>jasmine.createSpy</code> → <code>vi.fn</code></li>\n<li>Umstellung der Lifecycle‑Hooks (<code>beforeAll</code>, <code>beforeEach</code>, etc.) auf Vitest‑Varianten</li>\n<li><code>fail()</code> → <code>vi.fail()</code></li>\n<li>Anpassung von Matchern an die Vitest‑API</li>\n<li><a href=\"https://github.com/angular/angular-cli/pull/31469\">TODO-Kommentare</a> für nicht automatisch konvertierbare Stellen</li>\n<li>Tests mit <code>done</code>-Callback werden in <code>async</code>/<code>await</code>-Tests umgeschrieben<!--(siehe PR https://github.com/angular/angular-cli/pull/31435 und folgende --></li>\n</ul>\n<p>Das Schematic führt bestimmte Aufgaben bewusst nicht durch.\nEs installiert weder Vitest noch andere erforderliche Abhängigkeiten.\nAußerdem nimmt es keine Änderungen an der <code>angular.json</code> vor, um den Vitest‑Builder zu aktivieren.\nEbenso entfernt es keine Karma‑Dateien aus dem Projekt.\nSchließlich konvertiert das Schematic auch keine komplexen Spy‑Szenarien, die daher weiterhin manuell überarbeitet werden müssen.\nDie manuelle Umstellung (wie oben beschrieben) bleibt uns leider nicht erspart.</p>\n<h4 id=\"2-schematic-ausführen\">2. Schematic ausführen</h4>\n<p>Wenn dein Projekt für Vitest konfiguriert ist, kannst du das automatische Refactoring starten:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">ng</span> g <span class=\"hljs-variable\">@schematics</span>/angular:refactor-jasmine-vitest\n</code></pre>\n<p>Das Schematic bietet eine Reihe von zusätzlichen Optionen:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--project &lt;name&gt;</code></td>\n<td>Wählt ein bestimmtes Projekt in einem Workspace aus.</td>\n</tr>\n<tr>\n<td><code>--include &lt;path&gt;</code></td>\n<td>Beschränkt das Refactoring auf eine Datei oder ein Verzeichnis.</td>\n</tr>\n<tr>\n<td><code>--file-suffix</code></td>\n<td>Legt eine andere Dateiendung für Testdateien fest.</td>\n</tr>\n<tr>\n<td><code>--add-imports</code></td>\n<td>Fügt explizite Vitest-Im­porte hinzu.</td>\n</tr>\n<tr>\n<td><code>--verbose</code></td>\n<td>Aktiviert detailliertes Logging der durchgeführten Änderungen.</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-nach-der-migration\">3. Nach der Migration</h4>\n<ol>\n<li><strong>Tests ausführen:</strong> Nutze <code>ng test</code>, um sicherzustellen, dass alle Tests weiterhin funktionieren.</li>\n<li><strong>Änderungen prüfen:</strong> Sieh dir die Anpassungen an, besonders bei komplexen Spys oder asynchronen Tests.</li>\n</ol>\n<p><code>ng test</code> führt Tests im <strong>Watch‑Modus</strong> aus, sofern das Terminal interaktiv ist.\nIn CI-Umgebungen führt der Test-Runner die Tests automatisch im Single-Run-Modus aus.</p>\n<h4 id=\"4-benutzerdefinierte-konfiguration-optional\">4. Benutzerdefinierte Konfiguration (optional)</h4>\n<p>Die Angular CLI erzeugt die Vitest‑Konfiguration im Hintergrund basierend auf den Optionen in <code>angular.json</code>.</p>\n<p>Wem die vorgesehenen Optionen nicht ausreichen, der kann eine benutzerdefinierte Konfiguration verwenden.\nDamit werden zwar erweiterte Optionen verfügbar, das Angular-Team bietet jedoch keinen direkten Support für die spezifischen Inhalte der Konfigurationsdatei oder darin verwendete Plugins von Drittanbietern.\nDie CLI überschreibt außerdem bestimmte Eigenschaften (<code>test.projects</code>, <code>test.include</code>), um einen ordnungsgemäßen Betrieb sicherzustellen.</p>\n<p>Du kannst bei Bedarf eine eigene Vitest-Konfigurationsdatei (<code>vitest.config.ts</code>) einbinden, um weitergehende Anpassungen vorzunehmen, die über die Standardoptionen hinausgehen.\nDabei gibt es zwei mögliche Wege: Entweder verweist du direkt auf eine bestimmte Konfigurationsdatei, indem du den exakten Pfad in der <code>angular.json</code> angibst:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>,\n          <span class=\"hljs-string\">&quot;options&quot;</span>: {\n            <span class=\"hljs-string\">&quot;runnerConfig&quot;</span>: <span class=\"hljs-string\">&quot;vitest.config.ts&quot;</span>\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Alternativ kannst du die Angular CLI automatisch suchen lassen.\nBei automatischer Suche setzt du <code>&quot;runnerConfig&quot;: true</code> in der <code>angular.json</code>. \nDer Builder sucht dann selbstständig nach einer Datei namens <code>vitest-base.config.*</code>, zunächst im Projektverzeichnis und anschließend im Workspace-Root. \nSo kannst du beispielsweise gemeinsame Einstellungen zentral definieren und bequem wiederverwenden.</p>\n<h2 id=\"die-neue-syntax-und-apis\">Die neue Syntax und APIs</h2>\n<p>Die meisten Specs laufen unverändert, denn <strong>TestBed, ComponentFixture &amp; Co.</strong> bleiben bestehen.\nBei der Migration von Jasmine zu Vitest bleiben viele Testmuster vertraut, gleichzeitig ändert sich an einigen Stellen die konkrete API.\nNeu lernen musst du vor allem Jasmine‑spezifische Stellen.</p>\n<h3 id=\"globale-funktionen\">Globale Funktionen</h3>\n<p>Die bekannten globalen Testfunktionen wie <code>describe</code>, <code>it</code> bzw. <code>test</code>, <code>beforeEach</code>, <code>afterEach</code> und <code>expect</code> bleiben in Vitest unverändert erhalten. \nSie stehen ohne weitere Importe zur Verfügung, sofern in deiner <code>tsconfig.spec.json</code> der Eintrag <code>types: [&quot;vitest/globals&quot;]</code> gesetzt ist. \nTrotzdem empfehlen wir, diese Funktionen explizit zu importieren.\nDadurch vermeidest du mögliche Namenskollisionen, etwa mit gleichnamigen Funktionen aus Cypress, was in der Vergangenheit regelmäßig zu verwirrenden Problemen geführt hat.</p>\n<h3 id=\"matcher\">Matcher</h3>\n<p>Die üblichen Matcher wie <code>toBe</code>, <code>toEqual</code>, <code>toContain</code> oder <code>toHaveBeenCalledWith</code> stehen in Vitest weiterhin zur Verfügung. Wenn du in Jasmine <code>jasmine.any(...)</code> verwendet hast, nutzt du in Vitest <code>expect.any(...)</code>.\nWichtig: Vitest hat nicht das Ziel, eine mit Jasmine kompatible API zu schaffen.\nStattdessen bietet Vitest eine möglichst <a href=\"https://vitest.dev/api/expect.html\"><strong>Jest‑kompatible</strong> Expect-API</a> auf Basis von Chai an.\nDas Testframework Jest hat wiederum das Ziel, einigermaßen kompatibel zu Jasmine zu sein.\nWeil aber Vitest nur mit Jest kompatibel sein will, ergeben sich folgende Herausforderungen, da einige Matcher schlicht fehlen:</p>\n<h4 id=\"1-tobetrue--tobefalse-gibt-es-in-jestvitest-nicht\">1) <code>toBeTrue()</code> / <code>toBeFalse()</code> gibt es in Jest/Vitest nicht</h4>\n<p>Jasmine bringt die strikten Bool‑Matcher <code>toBeTrue()</code> und <code>toBeFalse()</code> mit.\nIn Jest (und damit Vitest) existieren sie nicht.\nDu kannst stattdessen einfach den Matcher <a href=\"https://vitest.dev/api/expect.html#tobe\"><code>toBe(true)</code></a> bzw. <code>toBe(false)</code> verwenden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-built_in\">expect</span>(result)<span class=\"hljs-selector-class\">.toBeTrue</span>();\n<span class=\"hljs-built_in\">expect</span>(flag)<span class=\"hljs-selector-class\">.toBeFalse</span>();\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-built_in\">expect</span>(result)<span class=\"hljs-selector-class\">.toBe</span>(true);\n<span class=\"hljs-built_in\">expect</span>(flag)<span class=\"hljs-selector-class\">.toBe</span>(false);\n</code></pre>\n<h4 id=\"2-tohavebeencalledoncewith-gibt-es-in-jestvitest-nicht\">2) <code>toHaveBeenCalledOnceWith()</code> gibt es in Jest/Vitest nicht</h4>\n<p>Jasmine hat einen praktischen Matcher für einen Spy mit der Prüfung auf &quot;genau einmal und genau mit diesen Argumenten&quot;. \nAls Ersatz verwendest du einfach <a href=\"https://vitest.dev/api/expect.html#tohavebeencalledexactlyoncewith\"><code>toHaveBeenCalledExactlyOnceWith()</code></a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">var</span> book = {};\n\n<span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-keyword\">expect</span>(spy).toHaveBeenCalledOnceWith(book);\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-keyword\">expect</span>(spy).toHaveBeenCalledExactlyOnceWith(book);\n</code></pre>\n<h4 id=\"3-asynchrone-matchers-expectasync-jasmine-vs-resolvesrejects-jestvitest\">3) Asynchrone Matchers: <code>expectAsync(...)</code> (Jasmine) vs. <code>.resolves/.rejects</code> (Jest/Vitest)</h4>\n<p>Jasmine hat eine <a href=\"https://jasmine.github.io/api/5.12/async-matchers\">eigene Async-API</a>: <code>await expectAsync(promise).toBeResolved() / toBeRejectedWith(...)</code>. \nJest/Vitest nutzen stattdessen das Muster <a href=\"https://vitest.dev/api/expect.html#resolves\"><code>await expect(promise).resolves/...</code></a> bzw. <a href=\"https://vitest.dev/api/expect.html#rejects\"><code>.rejects/...</code></a>. \nBeim Umstieg müssen diese Expectations umgeschrieben werden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeResolved</span>();\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeResolvedTo</span>(&#x27;OK&#x27;);\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeRejectedWithError</span>(&#x27;Boom&#x27;);\n\n<span class=\"hljs-comment\">// Jest/Vitest</span>\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.resolves</span><span class=\"hljs-selector-class\">.toBeDefined</span>();\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.resolves</span><span class=\"hljs-selector-class\">.toBe</span>(&#x27;OK&#x27;);\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.rejects</span><span class=\"hljs-selector-class\">.toThrow</span>(&#x27;Boom&#x27;);\n</code></pre>\n<p>Vitest zielt also bei den Matchern auf Jest‑Kompatibilität ab. \nKompatibilität mit Jasmine steht hingegen überhaupt nicht im Fokus. \nIn der Praxis ist der Anpassungsaufwand meist gering (vor allem bei <code>toBeTrue</code>/<code>toBeFalse</code> und <code>toHaveBeenCalledOnceWith</code>), aber er existiert. \nBei asynchronen Erwartungen unterscheidet sich das Pattern sogar deutlich. \nAber keine Sorge: Die Wahrscheinlichkeit, dass dein Projekt <code>expectAsync</code> verwendet, ist sehr gering, da in der Angular-Dokumentation stattdessen immer Angular-spezifische Hilfsfunktionen gezeigt wurden.\nDaher dürfte in den meisten Projekten hier wahrscheinlich gar keine zusätzliche Arbeit anfallen.</p>\n<h3 id=\"spys-und-mocks\">Spys und Mocks</h3>\n<p>Das Spying-Konzept funktioniert nahezu identisch wie bei Jasmine, wird jedoch über das <a href=\"https://vitest.dev/api/vi.html#vi-spyon\"><code>vi</code>‑Objekt bereitgestellt</a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-built_in\">spyOn</span>(service, &#x27;loadData&#x27;)<span class=\"hljs-selector-class\">.and</span><span class=\"hljs-selector-class\">.returnValue</span>(of([]));\n\n<span class=\"hljs-comment\">// Vitest</span>\nvi<span class=\"hljs-selector-class\">.spyOn</span>(service, &#x27;loadData&#x27;)<span class=\"hljs-selector-class\">.mockReturnValue</span>(of([]));\n</code></pre>\n<p>Für Spys, die bei Jasmine mit <code>jasmine.createSpy()</code> erzeugt wurden, verwendest du in Vitest jetzt einfach <a href=\"https://vitest.dev/api/vi.html#vi-fn\"><code>vi.fn()</code></a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-keyword\">const</span> onItem = jasmine.createSpy().and.returnValue(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-keyword\">const</span> onItem = vi.fn().mockReturnValue(<span class=\"hljs-literal\">true</span>);\n</code></pre>\n<p>In Jasmine kann man mit dem ersten Argument einen Namen für den Spy vergeben.\nDies dient dazu, in Fehlermeldungen und Reports aussagekräftigere Texte anzuzeigen (siehe <a href=\"https://jasmine.github.io/api/5.12/jasmine#.createSpy\">Doku</a>).\nFalls du in Vitest ebenfalls einem Spy einen sprechenden Namen geben möchtest, kannst du dies mit <code>.mockName(&#39;onItem&#39;)</code> tun.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine - mit Name</span>\n<span class=\"hljs-keyword\">const</span> onItem = jasmine.createSpy(<span class=\"hljs-string\">&#x27;onItem&#x27;</span>).and.returnValue(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// Vitest - mit Name</span>\n<span class=\"hljs-keyword\">const</span> onItem = vi.fn().mockName(<span class=\"hljs-string\">&#x27;onItem&#x27;</span>).mockReturnValue(<span class=\"hljs-literal\">true</span>);\n</code></pre>\n<h3 id=\"asynchronität-ohne-zonejs-mit-vitest-timer\">Asynchronität ohne Zone.js mit Vitest Timer</h3>\n<p>Seit Angular 21 laufen Unit-Tests standardmäßig zoneless. \nDas bedeutet: Die früheren Angular-Hilfsfunktionen <code>waitForAsync()</code> und <code>fakeAsync()</code>/<code>tick()</code> funktionieren nicht mehr automatisch, weil sie auf Zone.js basieren. \nEntscheidend ist: Das hat nichts mit Vitest zu tun.\nAuch unter Jasmine hätte man in einer zonenlosen Umgebung auf diese Utilitys verzichten müssen.</p>\n<p>Für einfache asynchrone Tests ersetzt man <code>waitForAsync()</code> daher durch ganz normales <code>async/await</code>, das seit vielen Jahren auch mit Jasmine möglich ist.\nFolgendes Update funktioniert also unabhängig vom Test-Runner:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// FRÜHER: waitsForAsync + Zone.js</span>\nit(<span class=\"hljs-string\">&#x27;should load data&#x27;</span>, waitForAsync(() =&gt; {\n  service.getData().then(result =&gt; {\n    expect(result.title).toContain(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);\n  });\n}));\n\n<span class=\"hljs-comment\">// MODERN: zoneless + async/await</span>\nit(<span class=\"hljs-string\">&#x27;should load data&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> service.getData();\n  expect(result.title).toContain(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);\n});\n</code></pre>\n<p>Ggf. muss der Service für dieses Beispiel &quot;ausgemockt&quot; werden, damit es funktioniert.\nHier bleibt alles unverändert.\nModern ist nur die Schreibweise, bei der es zwischen Jasmine und Vitest keinen Unterschied gibt.</p>\n<p>Der zweite Angular-Klassiker <a href=\"https://angular.dev/api/core/testing/fakeAsync\"><code>fakeAsync()</code></a> und <a href=\"https://angular.dev/api/core/testing/tick\"><code>tick()</code></a> braucht hingegen einen echten Ersatz.\n(Hinweis: Diese beiden Helfer sind nicht Bestandteil von Jasmine, sondern kommen aus <code>@angular/core/testing</code>.)\nVitest bringt ein eigenes <a href=\"https://vitest.dev/api/vi.html#fake-timers\">Fake-Timer-System</a> mit.\nDie Nutzung erfordert etwas Einarbeitung, denn nicht alle Timer funktionieren gleich und nicht jeder Test braucht dieselben Werkzeuge. \nBeginnen wir mit einem einfachen zeitbasierten Beispiel. \nDie folgende Funktion erhöht einen Counter nach genau fünf Sekunden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startFiveSecondTimer</span>(<span class=\"hljs-params\">counter: { value: number }</span>) {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    counter.<span class=\"hljs-property\">value</span>++;\n  }, <span class=\"hljs-number\">5000</span>);\n}\n</code></pre>\n<p>Für solche Fälle ist <code>vi.advanceTimersByTime()</code> ideal, denn man kann gezielt simulieren, dass exakt eine bestimmte Zeit verstrichen ist. Ganz ähnlich wie früher <code>tick(5000)</code>, aber ohne <code>fakeAsync()</code>-Zone:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startFiveSecondTimer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-basic&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startFiveSecondTimer&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;erhöht den Counter nach exakt 5 Sekunden&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    vi.useFakeTimers();\n\n    const counter = { value: <span class=\"hljs-number\">0</span> };\n    startFiveSecondTimer(counter);\n\n    <span class=\"hljs-regexp\">//</span> simuliert das Vergehen von <span class=\"hljs-number\">5</span> Sekunden\n    vi.advanceTimersByTime(<span class=\"hljs-number\">5000</span>);\n\n    expect(counter.value).toBe(<span class=\"hljs-number\">1</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre>\n<p><code>advanceTimersByTime()</code> ist damit der unmittelbare Ersatz für <code>tick()</code>.\nEs eignet sich besonders gut, wenn du eine ganz bestimmte Zeitspanne simulieren oder mehrere Timer in korrekt getakteter Reihenfolge ablaufen lassen möchtest.</p>\n<p>Doch nicht alle Timer sind so einfach. \nManchmal besteht der Code nur aus timerbasierten Aktionen, aber ohne zusätzliche Promises. Das folgende Beispiel inkrementiert einen Counter mehrfach, indem es ausschließlich Timeouts und Intervals nutzt:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> function startSyncSequence(counter: { value: number }) {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { counter.value++; }, <span class=\"hljs-number\">300</span>);\n  const interval = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    counter.value++;\n    <span class=\"hljs-keyword\">if</span> (counter.value === <span class=\"hljs-number\">3</span>) {\n      <span class=\"hljs-built_in\">clearInterval</span>(interval);\n    }\n  }, <span class=\"hljs-number\">200</span>);\n}\n</code></pre>\n<p>In Fällen, in denen du <em>alle</em> Timer der Reihe nach abarbeiten willst, ohne manuell Zeit vorzuspulen, nutzt du <code>vi.runAllTimers()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startSyncSequence } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-sync&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startSyncSequence&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;führt alle synchronen Timer vollständig aus&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    vi.useFakeTimers();\n\n    const counter = { value: <span class=\"hljs-number\">0</span> };\n    startSyncSequence(counter);\n\n    <span class=\"hljs-regexp\">//</span> führt alle Timer und Intervals aus, bis die Timer-Queue leer ist\n    vi.runAllTimers();\n\n    expect(counter.value).toBe(<span class=\"hljs-number\">3</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre>\n<p>Hier wäre <code>advanceTimersByTime()</code> zwar möglich, aber unnötig kompliziert. <code>runAllTimers()</code> löst einfach jedes Timeout und jedes Interval aus, bis nichts mehr übrig ist.</p>\n<p>Noch interessanter wird es, wenn Timer-Callbacks selbst wieder asynchron arbeiten, beispielsweise durch ein <code>await</code> oder Promise-Ketten.\nDann reicht <code>runAllTimers()</code> nicht mehr aus. Das folgende Beispiel zeigt ein typisches Muster aus realen Anwendungen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startAsyncJob</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&lt;string&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-title function_\">async</span> () =&gt; {\n      <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;done&#x27;</span>); <span class=\"hljs-comment\">// asynchroner Schritt im Callback</span>\n      <span class=\"hljs-title function_\">resolve</span>(data);\n    }, <span class=\"hljs-number\">100</span>);\n  });\n}\n</code></pre>\n<p>Damit der Test nicht nur den Timeout, sondern auch das <code>await</code> im Callback vollständig abarbeitet, bietet Vitest <code>runAllTimersAsync()</code> an:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startAsyncJob } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-async&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startAsyncJob&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;führt Timer und async-Callbacks vollständig aus&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n    vi.useFakeTimers();\n\n    const promise = startAsyncJob();\n\n    <span class=\"hljs-regexp\">//</span> führt Timer UND asynchrone Logik innerhalb der Timer-Callbacks aus\n    <span class=\"hljs-keyword\">await</span> vi.runAllTimersAsync();\n\n    <span class=\"hljs-keyword\">await</span> expect(promise).resolves.toBe(<span class=\"hljs-string\">&#x27;done&#x27;</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre>\n<p><code>runAllTimersAsync()</code> ist damit ein guter Ersatz für Tests, bei denen bisher <code>fakeAsync()</code> und <code>tick()</code> in Kombination mit Microtask-Flushing verwendet wurden. </p>\n<h3 id=\"testbed-und-componentfixture\">TestBed und ComponentFixture</h3>\n<p>Nach all den kleinen, aber subtilen Unterschieden zwischen Jasmine und Vitest gibt es hier gute Nachrichten: \nDie Verwendung von <code>TestBed</code> und <code>ComponentFixture</code> bleibt vollständig unverändert, da dies kein Thema ist, das Vitest berührt. \nDu erzeugst weiterhin deine Komponenten oder Services mithilfe von <code>TestBed</code>.\nAuch der explizite Aufruf von <code>fixture.detectChanges()</code> ist unverändert notwendig, um die Change Detection manuell anzustoßen.</p>\n<h2 id=\"bekannte-einschränkungen-und-fallstricke\">Bekannte Einschränkungen und Fallstricke</h2>\n<p>Spezielle Karma-Anwendungsfälle wie eigene Karma-Plugins oder individuelle Browser‑Launcher lassen sich erwartungsgemäß nicht direkt auf Vitest übertragen.\nDu wirst im Vitest-Ökosystem nach Alternativen suchen müssen.</p>\n<p>Bei der Umstellung auf Vitest kann eine kurze Gewöhnungsphase im Team nötig sein, da bestimmte neue API-Konzepte wie <code>vi.spyOn</code>, <code>vi.fn</code> oder Strategien zum Zurücksetzen von Mocks zwar leicht zu erlernen sind, sich aber dennoch von Jasmine unterscheiden. \nAchte deshalb darauf, dass deine Tests mögliche Manipulationen an globalen Objekten vollständig aufräumen und verwende dafür idealerweise Methoden wie <a href=\"https://vitest.dev/api/#aftereach\"><code>afterEach</code></a> mit <a href=\"https://vitest.dev/api/vi.html#vi-restoreallmocks\"><code>vi.restoreAllMocks()</code></a>.</p>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Mit Vitest als Standard in Angular 21 wird das Testen deutlich moderner und schneller. \nDie Umstellung ist meist unkompliziert, die Migrations‑Schematics helfen beim Einstieg. \nWo früher <code>fakeAsync</code> und Zone.js‑Magie nötig waren, reichen heute <code>async/await</code> und flexible Fake‑Timer. \nUnd wenn es realistisch sein muss, steht dir der Browser‑Modus zur Verfügung.\nInsgesamt bedeutet das: kürzere Feedback‑Schleifen, robustere Tests und weniger Reibung im Alltag. Viel Spaß beim Testen!</p>\n<hr>\n\n<p><small>Vielen Dank an Ferdinand Malcher und Danny Koppenhagen für das Review und das wertvolle Feedback!</small></p>\n","meta":{"title":"Vitest in Angular 21: Was ist neu und wie kann man migrieren?","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2025-11-18T00:00:00.000Z","lastModified":"2025-11-20T00:00:00.000Z","keywords":["Angular","Angular 21","Vitest","Karma","Jasmine"],"language":"de","header":{"url":"angular-vitest.jpg","width":2000,"height":1089}}}
