{"slug":"2025-11-zu-vitest-migrieren","html":"<p>Mit Angular¬†21 gibt es eine bedeutende √Ñnderung beim Unit-Testing:\nVitest ist jetzt der Standard, die bisherige Standardkombination aus Karma und Jasmine wird abgel√∂st.\nBeim Erzeugen eines neuen Projekts mit <code>ng new</code> verwendet Angular¬†21 nun standardm√§√üig <strong>Vitest</strong> als Test-Runner.\nVitest verspricht deutlich k√ºrzere Startzeiten, moderne Features und eine einfache Jest-kompatible API.\nIn diesem Artikel zeigen wir, was Vitest f√ºr dich bedeutet, wie du bestehende Angular-Projekte migrieren kannst und welche Vorteile Vitest bietet.</p>\n<blockquote>\n<p><strong>üá¨üáß This article is available in English language here: <a href=\"https://angular.schule/blog/2025-11-migrate-to-vitest\">Vitest in Angular 21: What&#39;s new and how to migrate?</a></strong></p>\n</blockquote>\n<h2 id=\"inhalt\">Inhalt</h2>\n<ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#warum-angular-karma-und-jasmine-ersetzt\">Warum Angular Karma und Jasmine ersetzt</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#migrationsleitfaden-von-karmajasmine-zu-vitest\">Migrationsleitfaden: Von Karma/Jasmine zu Vitest</a><ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#manuelle-migrationsschritte\">Manuelle Migrationsschritte</a><ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#1-abh%C3%A4ngigkeiten-installieren\">1. Abh√§ngigkeiten installieren</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#2-angularjson-aktualisieren\">2. <code>angular.json</code> aktualisieren</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#3-eigene-karmaconfjskonfiguration-ber%C3%BCcksichtigen\">3. Eigene <code>karma.conf.js</code>‚ÄëKonfiguration ber√ºcksichtigen</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#4-karma--und-testtsdateien-entfernen\">4. Karma- und <code>test.ts</code>‚ÄëDateien entfernen</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#5-browsermodus-konfigurieren-optional\">5. Browser‚ÄëModus konfigurieren (optional)</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#automatisches-testrefactoring-per-schematic\">Automatisches Test‚ÄëRefactoring per Schematic</a><ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#1-%C3%BCberblick\">1. √úberblick</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#2-schematic-ausf%C3%BChren\">2. Schematic ausf√ºhren</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#3-nach-der-migration\">3. Nach der Migration</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#4-benutzerdefinierte-konfiguration-optional\">4. Benutzerdefinierte Konfiguration (optional)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#die-neue-syntax-und-apis\">Die neue Syntax und APIs</a><ul>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#globale-funktionen\">Globale Funktionen</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#matcher\">Matcher</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#spies-und-mocks\">Spies und Mocks</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#asynchronit%C3%A4t-ohne-zonejs-aber-mit-vitest-timer\">Asynchronit√§t ohne Zone.js aber mit Vitest Timer</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#testbed-und-componentfixture\">TestBed und ComponentFixture</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#bekannte-einschr%C3%A4nkungen-und-fallstricke\">Bekannte Einschr√§nkungen und Fallstricke</a></li>\n<li><a href=\"/blog/2025-11-zu-vitest-migrieren#fazit\">Fazit</a></li>\n</ul>\n<h2 id=\"warum-angular-karma-und-jasmine-ersetzt\">Warum Angular Karma und Jasmine ersetzt</h2>\n<p><em>Karma und Jasmine</em> haben f√ºr Angular lange Jahre gute Dienste geleistet, vor allem wegen der Ausf√ºhrung in einem echten Browser.\nEs gab aber Nachteile: die Ausf√ºhrungsgeschwindigkeit war nie optimal und das √ñkosystem ist veraltet (<a href=\"https://github.com/karma-runner/karma#karma-is-deprecated-and-is-not-accepting-new-features-or-general-bug-fixes\">Karma ist seit 2023 deprecated</a>). \n√úber mehrere Jahre pr√ºfte das Angular-Team Alternativen (Jest, Web Test Runner usw.), ohne einen klaren Gewinner zu finden.\n<a href=\"https://vitest.dev/\">Vitest</a> wurde inzwischen √§u√üerst popul√§r und erwies sich als passende L√∂sung.</p>\n<p>Vitest passte besonders gut, da es einen echten Browser-Modus bietet.\nWie zuvor bei Karma k√∂nnen Tests in einem realen Browser mit &quot;echtem&quot; DOM und echten Ereignissen ausgef√ºhrt werden.\nDer Browser-Modus wurde erst k√ºrzlich mit Vitest 4 im Oktober 2025 <a href=\"https://vitest.dev/blog/vitest-4.html#browser-mode-is-stable\">als stabil deklariert</a>.\nGleichzeitig ist Vitest schnell und modern: Es baut auf <a href=\"https://vite.dev/\">Vite</a> auf, ist ESM- und TypeScript-first und sorgt f√ºr √§u√üerst kurze Start- und Wiederholungszeiten.\nDazu kommt eine sehr m√§chtige API mit Snapshot-Tests, flexiblen <a href=\"https://vitest.dev/guide/mocking/timers.html\">Fake-Timern</a>, dem wirklich n√ºtzlichen Helfer <a href=\"https://vitest.dev/api/expect.html#poll\"><code>expect.poll</code></a>, <a href=\"https://vitest.dev/guide/test-context\">Test-Fixtures</a> und Jest-kompatiblen Matchern.\nNicht zuletzt ist Vitest im gesamten Frontend-√ñkosystem weit verbreitet, wodurch vorhandenes Know-how gut √ºbertragen werden kann.\nKurz gesagt: Der Wechsel sorgt f√ºr Tempo, eine deutlich bessere Developer Experience und Zukunftssicherheit und h√§lt dabei weiterhin die M√∂glichkeit echter Browser-Tests offen.</p>\n<h2 id=\"migrationsleitfaden-von-karmajasmine-zu-vitest\">Migrationsleitfaden: Von Karma/Jasmine zu Vitest</h2>\n<!-- Quelle: https://github.com/angular/angular/blob/6178e3ebfbc69a2afa04dd19ea4d6d8b1bfb0649/adev/src/content/guide/testing/migrating-to-vitest.md -->\n\n<p>Wenn du ein <strong>neues Projekt</strong> mit Angular¬†21 erzeugen m√∂chtest, nutzt die Angular CLI standardm√§√üig den neuen Test-Runner Vitest.\nDie Wahl kannst du √ºber die Option <code>--test-runner</code> beeinflussen:\nMit <code>--test-runner=vitest</code> erh√§ltst du die neue, schnellere und modernere Standardl√∂sung. \nM√∂chtest du dagegen weiterhin bei der bew√§hrten Karma/Jasmine-Kombination bleiben, verwende die Option <code>--test-runner=karma</code>.\nOhne explizite Angabe der Option wird automatisch Vitest verwendet.</p>\n<p>Um ein <strong>bestehendes Projekt</strong> auf Angular¬†21 und Vitest zu migrieren, musst du zun√§chst das Projekt mittels <code>ng update</code> auf Version¬†21 aktualisieren.\nBeachte dabei, dass die Migration bestehender Projekte zu Vitest aktuell noch <strong>experimentell</strong> ist.\nAu√üerdem setzt dieser Prozess das <code>application</code>-Buildsystem von Angular voraus, das bei neu erstellten Projekten standardm√§√üig aktiviert ist.\nNachdem dein Projekt auf Version 21 aktualisiert wurde, kannst du mit den folgenden Schritten fortfahren.</p>\n<h3 id=\"manuelle-migrationsschritte\">Manuelle Migrationsschritte</h3>\n<p>Bevor du das automatische Refactoring‚ÄëSchematic verwendest, musst du dein Projekt manuell so anpassen, dass Vitest als Test‚ÄëRunner verwendet wird.</p>\n<h4 id=\"1-abh√§ngigkeiten-installieren\">1. Abh√§ngigkeiten installieren</h4>\n<p>Installiere <code>vitest</code> sowie eine DOM‚ÄëEmulationsbibliothek. \nObwohl Tests weiterhin im Browser ausgef√ºhrt werden k√∂nnen (siehe Schritt 5), verwendet Vitest standardm√§√üig eine DOM‚ÄëEmulation, um eine Browserumgebung in Node.js zu simulieren und Tests schneller auszuf√ºhren. \nDie CLI erkennt automatisch <code>happy-dom</code>, falls es installiert ist; ansonsten greift sie auf <code>jsdom</code> zur√ºck. \nEines der beiden Pakete muss vorhanden sein.</p>\n<pre><code class=\"language-bash\">npm install --<span class=\"hljs-built_in\">save</span>-<span class=\"hljs-built_in\">dev</span> vitest jsdom\n</code></pre>\n<h4 id=\"2-angularjson-aktualisieren\">2. <code>angular.json</code> aktualisieren</h4>\n<p>Suche in der Datei <code>angular.json</code> das <code>test</code>-Target deines Projekts und setze den <code>builder</code> auf <code>@angular/build:unit-test</code>.</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Der <code>unit-test</code>‚ÄëBuilder verwendet standardm√§√üig <code>&quot;tsConfig&quot;: &quot;tsconfig.spec.json&quot;</code> und <code>&quot;buildTarget&quot;: &quot;::development&quot;</code>. \nFalls dein Projekt andere Werte ben√∂tigt, etwa weil die <code>development</code>-Konfiguration fehlt oder spezielle Test‚ÄëEinstellungen n√∂tig sind, kannst du eine eigene Build-Konfiguration anlegen und zuweisen, z. B. <code>testing</code>.</p>\n<p>Der vorherige Builder <code>@angular/build:karma</code> erlaubte es, Build‚ÄëOptionen (wie <code>polyfills</code>, <code>assets</code>, <code>styles</code>) direkt im <code>test</code>-Target zu definieren. Der neue Builder <code>@angular/build:unit-test</code> unterst√ºtzt das nicht. \nFalls sich deine Test‚ÄëBuild‚ÄëOptionen von der <code>development</code>-Konfiguration unterscheiden, musst du diese Optionen in eine eigene Build-Konfiguration verschieben. \nStimmen sie bereits mit <code>development</code> √ºberein, ist kein weiterer Schritt notwendig.</p>\n<blockquote>\n<p><strong>Tipp:</strong> Alternativ kannst du einfach ein neues Projekt mittels <code>ng new</code> erzeugen und die relevanten Abschnitte aus der neu generierten <code>angular.json</code> in dein bestehendes Projekt √ºbernehmen. \nSo erh√§ltst du automatisch eine saubere Vorlage f√ºr die Vitest-Konfiguration.</p>\n</blockquote>\n<h4 id=\"3-eigene-karmaconfjskonfiguration-ber√ºcksichtigen\">3. Eigene <code>karma.conf.js</code>‚ÄëKonfiguration ber√ºcksichtigen</h4>\n<p>Eigene Einstellungen aus der Datei <code>karma.conf.js</code> werden nicht automatisch migriert. \nPr√ºfe diese Datei, bevor du sie l√∂schst, und √ºbertrage relevante Optionen manuell.\nViele Karma‚ÄëOptionen besitzen Vitest‚ÄëEntsprechungen, die du in einer <code>vitest.config.ts</code> definieren kannst und dann √ºber <code>runnerConfig</code> in der <code>angular.json</code> einbindest.</p>\n<p>Typische Migrationspfade:</p>\n<ul>\n<li><strong>Reporter:</strong> Karma‚ÄëReporter m√ºssen durch Vitest‚Äëkompatible Reporter ersetzt werden. Viele davon k√∂nnen direkt in <code>angular.json</code> unter <code>test.options.reporters</code> konfiguriert werden. F√ºr komplexere F√§lle nutze <code>vitest.config.ts</code>.</li>\n<li><strong>Plugins:</strong> Karma‚ÄëPlugins erfordern passende Vitest‚ÄëAlternativen. Beachte, dass Code‚ÄëCoverage in der Angular CLI bereits integriert ist und √ºber <code>ng test --coverage</code> aktiviert werden kann.</li>\n<li><strong>Eigene Browser‚ÄëLauncher:</strong> Diese werden durch die Option <code>browsers</code> in der <code>angular.json</code> und die Installation eines Browser‚ÄëProviders wie <code>@vitest/browser-playwright</code> ersetzt.</li>\n</ul>\n<p>Weitere Einstellungen findest du in der offiziellen <a href=\"https://vitest.dev/config/\">Vitest‚ÄëDokumentation</a>.</p>\n<h4 id=\"4-karma--und-testtsdateien-entfernen\">4. Karma- und <code>test.ts</code>‚ÄëDateien entfernen</h4>\n<p>Du kannst nun die Dateien <code>karma.conf.js</code> sowie <code>src/test.ts</code> l√∂schen und alle Karma‚Äëbezogenen Pakete deinstallieren. \nDie folgenden Befehle entsprechen einem Standard‚ÄëAngular‚ÄëProjekt.\nIn deinem Projekt k√∂nnen weitere Pakete vorhanden sein.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> uninstall karma karma-chrome-launcher karma-coverage karma-jasmine karma-jasmine-html-reporter\n</code></pre>\n<h4 id=\"5-browsermodus-konfigurieren-optional\">5. Browser‚ÄëModus konfigurieren (optional)</h4>\n<p>Falls du Tests in einem echten Browser ausf√ºhren m√∂chtest, musst du einen Browser-Provider installieren und die <code>angular.json</code> anpassen.\nW√§hle je nach Bedarf:</p>\n<ul>\n<li><strong>Playwright:</strong> <code>@vitest/browser-playwright</code> f√ºr Chromium, Firefox und WebKit</li>\n<li><strong>WebdriverIO:</strong> <code>@vitest/browser-webdriverio</code> f√ºr Chrome, Firefox, Safari und Edge</li>\n<li><strong>Preview:</strong> <code>@vitest/browser-preview</code> f√ºr WebContainer-Umgebungen wie StackBlitz</li>\n</ul>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> install --save-dev @vitest/browser-playwright\n</code></pre>\n<p>Danach musst du noch die <code>angular.json</code> erweitern.\nF√ºge im <code>test</code>-Target die Option <code>browsers</code> hinzu.\nDer Browsername h√§ngt vom verwendeten Provider ab (z.‚ÄØB. <code>chromium</code> bei Playwright).</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>,\n          <span class=\"hljs-string\">&quot;options&quot;</span>: {\n            <span class=\"hljs-string\">&quot;browsers&quot;</span>: [<span class=\"hljs-string\">&quot;chromium&quot;</span>]\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Der Headless‚ÄëModus wird automatisch aktiviert, wenn die Umgebungsvariable <code>CI</code> gesetzt ist oder der Browsername &quot;Headless&quot; enth√§lt (z.‚ÄØB. <code>ChromeHeadless</code>). \nAndernfalls l√§uft der Browser sichtbar.</p>\n<h3 id=\"automatisches-testrefactoring-per-schematic\">Automatisches Test‚ÄëRefactoring per Schematic</h3>\n<p>Das Angular CLI stellt ein Schematic bereit, das deine Jasmine‚ÄëTests automatisch auf Vitest umstellt.</p>\n<p><strong>WICHTIG:</strong> Das Schematic <code>refactor-jasmine-vitest</code> ist experimentell und deckt nicht alle Patterns ab.\n√úberpr√ºfe die √Ñnderungen immer manuell.</p>\n<h4 id=\"1-√ºberblick\">1. √úberblick</h4>\n<p>Derzeit f√ºhrt das Schematic folgende Umwandlungen in Dateien mit der Endung <code>.spec.ts</code> durch:</p>\n<ul>\n<li><code>fit</code>/<code>fdescribe</code> ‚Üí <code>it.only</code>/<code>describe.only</code></li>\n<li><code>xit</code>/<code>xdescribe</code> ‚Üí <code>it.skip</code>/<code>describe.skip</code></li>\n<li><code>spyOn</code> ‚Üí <code>vi.spyOn</code></li>\n<li><code>jasmine.objectContaining</code> ‚Üí <code>expect.objectContaining</code></li>\n<li><code>jasmine.any</code> ‚Üí <code>expect.any</code></li>\n<li><code>jasmine.createSpy</code> ‚Üí <code>vi.fn</code></li>\n<li>Umstellung der Lifecycle‚ÄëHooks (<code>beforeAll</code>, <code>beforeEach</code>, etc.) auf Vitest‚ÄëVarianten</li>\n<li><code>fail()</code> ‚Üí <code>vi.fail()</code></li>\n<li>Anpassung von Matchern an die Vitest‚ÄëAPI</li>\n<li><a href=\"https://github.com/angular/angular-cli/pull/31469\">TODO-Kommentare</a> f√ºr nicht automatisch konvertierbare Stellen</li>\n<li>Tests mit <code>done</code>-Callback werden in <code>async</code>/<code>await</code>-Tests umgeschrieben<!--(siehe PR https://github.com/angular/angular-cli/pull/31435 und folgende --></li>\n</ul>\n<p>Das Schematic f√ºhrt bestimmte Aufgaben bewusst nicht durch.\nEs installiert weder Vitest noch andere erforderliche Abh√§ngigkeiten.\nAu√üerdem nimmt es keine √Ñnderungen an der <code>angular.json</code> vor, um den Vitest‚ÄëBuilder zu aktivieren.\nEbenso entfernt es keine Karma‚ÄëDateien aus dem Projekt.\nSchlie√ülich konvertiert das Schematic auch keine komplexen Spy‚ÄëSzenarien, die daher weiterhin manuell √ºberarbeitet werden m√ºssen.\nDie manuelle Umstellung (wie oben beschrieben) bleibt uns leider nicht erspart.</p>\n<h4 id=\"2-schematic-ausf√ºhren\">2. Schematic ausf√ºhren</h4>\n<p>Wenn dein Projekt f√ºr Vitest konfiguriert ist, kannst du das automatische Refactoring starten:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">ng</span> g <span class=\"hljs-variable\">@schematics</span>/angular:refactor-jasmine-vitest\n</code></pre>\n<p>Das Schematic bietet eine Reihe von zus√§tzlichen Optionen:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--project &lt;name&gt;</code></td>\n<td>W√§hlt ein bestimmtes Projekt in einem Workspace aus.</td>\n</tr>\n<tr>\n<td><code>--include &lt;path&gt;</code></td>\n<td>Beschr√§nkt das Refactoring auf eine Datei oder ein Verzeichnis.</td>\n</tr>\n<tr>\n<td><code>--file-suffix</code></td>\n<td>Legt eine andere Dateiendung f√ºr Testdateien fest.</td>\n</tr>\n<tr>\n<td><code>--add-imports</code></td>\n<td>F√ºgt explizite Vitest-Im¬≠porte hinzu.</td>\n</tr>\n<tr>\n<td><code>--verbose</code></td>\n<td>Aktiviert detailliertes Logging der durchgef√ºhrten √Ñnderungen.</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-nach-der-migration\">3. Nach der Migration</h4>\n<ol>\n<li><strong>Tests ausf√ºhren:</strong> Nutze <code>ng test</code>, um sicherzustellen, dass alle Tests weiterhin funktionieren.</li>\n<li><strong>√Ñnderungen pr√ºfen:</strong> Sieh dir die Anpassungen an, besonders bei komplexen Spys oder asynchronen Tests.</li>\n</ol>\n<p><code>ng test</code> f√ºhrt Tests im <strong>Watch‚ÄëModus</strong> aus, sofern das Terminal interaktiv ist.\nIn CI-Umgebungen f√ºhrt der Test-Runner die Tests automatisch im Single-Run-Modus aus.</p>\n<h4 id=\"4-benutzerdefinierte-konfiguration-optional\">4. Benutzerdefinierte Konfiguration (optional)</h4>\n<p>Die Angular CLI erzeugt die Vitest‚ÄëKonfiguration im Hintergrund basierend auf den Optionen in <code>angular.json</code>.</p>\n<p>Wem die vorgesehenen Optionen nicht ausreichen, der kann eine benutzerdefinierte Konfiguration verwenden.\nDamit werden zwar erweiterte Optionen verf√ºgbar, das Angular-Team bietet jedoch keinen direkten Support f√ºr die spezifischen Inhalte der Konfigurationsdatei oder darin verwendete Plugins von Drittanbietern.\nDie CLI √ºberschreibt au√üerdem bestimmte Eigenschaften (<code>test.projects</code>, <code>test.include</code>), um einen ordnungsgem√§√üen Betrieb sicherzustellen.</p>\n<p>Du kannst bei Bedarf eine eigene Vitest-Konfigurationsdatei (<code>vitest.config.ts</code>) einbinden, um weitergehende Anpassungen vorzunehmen, die √ºber die Standardoptionen hinausgehen.\nDabei gibt es zwei m√∂gliche Wege: Entweder verweist du direkt auf eine bestimmte Konfigurationsdatei, indem du den exakten Pfad in der <code>angular.json</code> angibst:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>,\n          <span class=\"hljs-string\">&quot;options&quot;</span>: {\n            <span class=\"hljs-string\">&quot;runnerConfig&quot;</span>: <span class=\"hljs-string\">&quot;vitest.config.ts&quot;</span>\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Alternativ kannst du die Angular CLI automatisch suchen lassen.\nBei automatischer Suche setzt du <code>&quot;runnerConfig&quot;: true</code> in der <code>angular.json</code>. \nDer Builder sucht dann selbstst√§ndig nach einer Datei namens <code>vitest-base.config.*</code>, zun√§chst im Projektverzeichnis und anschlie√üend im Workspace-Root. \nSo kannst du beispielsweise gemeinsame Einstellungen zentral definieren und bequem wiederverwenden.</p>\n<h2 id=\"die-neue-syntax-und-apis\">Die neue Syntax und APIs</h2>\n<p>Die meisten Specs laufen unver√§ndert, denn <strong>TestBed, ComponentFixture &amp; Co.</strong> bleiben bestehen.\nBei der Migration von Jasmine zu Vitest bleiben viele Testmuster vertraut, gleichzeitig √§ndert sich an einigen Stellen die konkrete API.\nNeu lernen musst du vor allem Jasmine‚Äëspezifische Stellen.</p>\n<h3 id=\"globale-funktionen\">Globale Funktionen</h3>\n<p>Die bekannten globalen Testfunktionen wie <code>describe</code>, <code>it</code> bzw. <code>test</code>, <code>beforeEach</code>, <code>afterEach</code> und <code>expect</code> bleiben in Vitest unver√§ndert erhalten. \nSie stehen ohne weitere Importe zur Verf√ºgung, sofern in deiner <code>tsconfig.spec.json</code> der Eintrag <code>types: [&quot;vitest/globals&quot;]</code> gesetzt ist. \nTrotzdem empfehlen wir, diese Funktionen explizit zu importieren.\nDadurch vermeidest du m√∂gliche Namenskollisionen, etwa mit gleichnamigen Funktionen aus Cypress, was in der Vergangenheit regelm√§√üig zu verwirrenden Problemen gef√ºhrt hat.</p>\n<h3 id=\"matcher\">Matcher</h3>\n<p>Die √ºblichen Matcher wie <code>toBe</code>, <code>toEqual</code>, <code>toContain</code> oder <code>toHaveBeenCalledWith</code> stehen in Vitest weiterhin zur Verf√ºgung. Wenn du in Jasmine <code>jasmine.any(...)</code> verwendet hast, nutzt du in Vitest <code>expect.any(...)</code>.\nWichtig: Vitest hat nicht das Ziel, eine mit Jasmine kompatible API zu schaffen.\nStattdessen bietet Vitest eine m√∂glichst <a href=\"https://vitest.dev/api/expect.html\"><strong>Jest‚Äëkompatible</strong> Expect-API</a> auf Basis von Chai an.\nDas Testframework Jest hat wiederum das Ziel, einigerma√üen kompatibel zu Jasmine zu sein.\nWeil aber Vitest nur mit Jest kompatibel sein will, ergeben sich folgende Herausforderungen, da einige Matcher schlicht fehlen:</p>\n<h4 id=\"1-tobetrue--tobefalse-gibt-es-in-jestvitest-nicht\">1) <code>toBeTrue()</code> / <code>toBeFalse()</code> gibt es in Jest/Vitest nicht</h4>\n<p>Jasmine bringt die strikten Bool‚ÄëMatcher <code>toBeTrue()</code> und <code>toBeFalse()</code> mit.\nIn Jest (und damit Vitest) existieren sie nicht.\nDu kannst stattdessen einfach den Matcher <a href=\"https://vitest.dev/api/expect.html#tobe\"><code>toBe(true)</code></a> bzw. <code>toBe(false)</code> verwenden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-built_in\">expect</span>(result)<span class=\"hljs-selector-class\">.toBeTrue</span>();\n<span class=\"hljs-built_in\">expect</span>(flag)<span class=\"hljs-selector-class\">.toBeFalse</span>();\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-built_in\">expect</span>(result)<span class=\"hljs-selector-class\">.toBe</span>(true);\n<span class=\"hljs-built_in\">expect</span>(flag)<span class=\"hljs-selector-class\">.toBe</span>(false);\n</code></pre>\n<h4 id=\"2-tohavebeencalledoncewith-gibt-es-in-jestvitest-nicht\">2) <code>toHaveBeenCalledOnceWith()</code> gibt es in Jest/Vitest nicht</h4>\n<p>Jasmine hat einen praktischen Matcher f√ºr einen Spy mit der Pr√ºfung auf &quot;genau einmal und genau mit diesen Argumenten&quot;. \nAls Ersatz verwendest du einfach <a href=\"https://vitest.dev/api/expect.html#tohavebeencalledexactlyoncewith\"><code>toHaveBeenCalledExactlyOnceWith()</code></a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">var</span> book = {};\n\n<span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-keyword\">expect</span>(spy).toHaveBeenCalledOnceWith(book);\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-keyword\">expect</span>(spy).toHaveBeenCalledExactlyOnceWith(book);\n</code></pre>\n<h4 id=\"3-asynchrone-matchers-expectasync-jasmine-vs-resolvesrejects-jestvitest\">3) Asynchrone Matchers: <code>expectAsync(...)</code> (Jasmine) vs. <code>.resolves/.rejects</code> (Jest/Vitest)</h4>\n<p>Jasmine hat eine <a href=\"https://jasmine.github.io/api/5.12/async-matchers\">eigene Async-API</a>: <code>await expectAsync(promise).toBeResolved() / toBeRejectedWith(...)</code>. \nJest/Vitest nutzen stattdessen das Muster <a href=\"https://vitest.dev/api/expect.html#resolves\"><code>await expect(promise).resolves/...</code></a> bzw. <a href=\"https://vitest.dev/api/expect.html#rejects\"><code>.rejects/...</code></a>. \nBeim Umstieg m√ºssen diese Expectations umgeschrieben werden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeResolved</span>();\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeResolvedTo</span>(&#x27;OK&#x27;);\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeRejectedWithError</span>(&#x27;Boom&#x27;);\n\n<span class=\"hljs-comment\">// Jest/Vitest</span>\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.resolves</span><span class=\"hljs-selector-class\">.toBeDefined</span>();\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.resolves</span><span class=\"hljs-selector-class\">.toBe</span>(&#x27;OK&#x27;);\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.rejects</span><span class=\"hljs-selector-class\">.toThrow</span>(&#x27;Boom&#x27;);\n</code></pre>\n<p>Vitest zielt also bei den Matchern auf Jest‚ÄëKompatibilit√§t ab. \nKompatibilit√§t mit Jasmine steht hingegen √ºberhaupt nicht im Fokus. \nIn der Praxis ist der Anpassungsaufwand meist gering (vor allem bei <code>toBeTrue</code>/<code>toBeFalse</code> und <code>toHaveBeenCalledOnceWith</code>), aber er existiert. \nBei asynchronen Erwartungen unterscheidet sich das Pattern sogar deutlich. \nAber keine Sorge: Die Wahrscheinlichkeit, dass dein Projekt <code>expectAsync</code> verwendet, ist sehr gering, da in der Angular-Dokumentation stattdessen immer Angular-spezifische Hilfsfunktionen gezeigt wurden.\nDaher d√ºrfte in den meisten Projekten hier wahrscheinlich gar keine zus√§tzliche Arbeit anfallen.</p>\n<h3 id=\"spys-und-mocks\">Spys und Mocks</h3>\n<p>Das Spying-Konzept funktioniert nahezu identisch wie bei Jasmine, wird jedoch √ºber das <a href=\"https://vitest.dev/api/vi.html#vi-spyon\"><code>vi</code>‚ÄëObjekt bereitgestellt</a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-built_in\">spyOn</span>(service, &#x27;loadData&#x27;)<span class=\"hljs-selector-class\">.and</span><span class=\"hljs-selector-class\">.returnValue</span>(of([]));\n\n<span class=\"hljs-comment\">// Vitest</span>\nvi<span class=\"hljs-selector-class\">.spyOn</span>(service, &#x27;loadData&#x27;)<span class=\"hljs-selector-class\">.mockReturnValue</span>(of([]));\n</code></pre>\n<p>F√ºr Spys, die bei Jasmine mit <code>jasmine.createSpy()</code> erzeugt wurden, verwendest du in Vitest jetzt einfach <a href=\"https://vitest.dev/api/vi.html#vi-fn\"><code>vi.fn()</code></a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-keyword\">const</span> onItem = jasmine.createSpy().and.returnValue(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-keyword\">const</span> onItem = vi.fn().mockReturnValue(<span class=\"hljs-literal\">true</span>);\n</code></pre>\n<p>In Jasmine kann man mit dem ersten Argument einen Namen f√ºr den Spy vergeben.\nDies dient dazu, in Fehlermeldungen und Reports aussagekr√§ftigere Texte anzuzeigen (siehe <a href=\"https://jasmine.github.io/api/5.12/jasmine#.createSpy\">Doku</a>).\nFalls du in Vitest ebenfalls einem Spy einen sprechenden Namen geben m√∂chtest, kannst du dies mit <code>.mockName(&#39;onItem&#39;)</code> tun.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine - mit Name</span>\n<span class=\"hljs-keyword\">const</span> onItem = jasmine.createSpy(<span class=\"hljs-string\">&#x27;onItem&#x27;</span>).and.returnValue(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// Vitest - mit Name</span>\n<span class=\"hljs-keyword\">const</span> onItem = vi.fn().mockName(<span class=\"hljs-string\">&#x27;onItem&#x27;</span>).mockReturnValue(<span class=\"hljs-literal\">true</span>);\n</code></pre>\n<h3 id=\"asynchronit√§t-ohne-zonejs-mit-vitest-timer\">Asynchronit√§t ohne Zone.js mit Vitest Timer</h3>\n<p>Seit Angular 21 laufen Unit-Tests standardm√§√üig zoneless. \nDas bedeutet: Die fr√ºheren Angular-Hilfsfunktionen <code>waitForAsync()</code> und <code>fakeAsync()</code>/<code>tick()</code> funktionieren nicht mehr automatisch, weil sie auf Zone.js basieren. \nEntscheidend ist: Das hat nichts mit Vitest zu tun.\nAuch unter Jasmine h√§tte man in einer zonenlosen Umgebung auf diese Utilitys verzichten m√ºssen.</p>\n<p>F√ºr einfache asynchrone Tests ersetzt man <code>waitForAsync()</code> daher durch ganz normales <code>async/await</code>, das seit vielen Jahren auch mit Jasmine m√∂glich ist.\nFolgendes Update funktioniert also unabh√§ngig vom Test-Runner:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// FR√úHER: waitsForAsync + Zone.js</span>\nit(<span class=\"hljs-string\">&#x27;should load data&#x27;</span>, waitForAsync(() =&gt; {\n  service.getData().then(result =&gt; {\n    expect(result.title).toContain(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);\n  });\n}));\n\n<span class=\"hljs-comment\">// MODERN: zoneless + async/await</span>\nit(<span class=\"hljs-string\">&#x27;should load data&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> service.getData();\n  expect(result.title).toContain(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);\n});\n</code></pre>\n<p>Ggf. muss der Service f√ºr dieses Beispiel &quot;ausgemockt&quot; werden, damit es funktioniert.\nHier bleibt alles unver√§ndert.\nModern ist nur die Schreibweise, bei der es zwischen Jasmine und Vitest keinen Unterschied gibt.</p>\n<p>Der zweite Angular-Klassiker <a href=\"https://angular.dev/api/core/testing/fakeAsync\"><code>fakeAsync()</code></a> und <a href=\"https://angular.dev/api/core/testing/tick\"><code>tick()</code></a> braucht hingegen einen echten Ersatz.\n(Hinweis: Diese beiden Helfer sind nicht Bestandteil von Jasmine, sondern kommen aus <code>@angular/core/testing</code>.)\nVitest bringt ein eigenes <a href=\"https://vitest.dev/api/vi.html#fake-timers\">Fake-Timer-System</a> mit.\nDie Nutzung erfordert etwas Einarbeitung, denn nicht alle Timer funktionieren gleich und nicht jeder Test braucht dieselben Werkzeuge. \nBeginnen wir mit einem einfachen zeitbasierten Beispiel. \nDie folgende Funktion erh√∂ht einen Counter nach genau f√ºnf Sekunden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startFiveSecondTimer</span>(<span class=\"hljs-params\">counter: { value: number }</span>) {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    counter.<span class=\"hljs-property\">value</span>++;\n  }, <span class=\"hljs-number\">5000</span>);\n}\n</code></pre>\n<p>F√ºr solche F√§lle ist <code>vi.advanceTimersByTime()</code> ideal, denn man kann gezielt simulieren, dass exakt eine bestimmte Zeit verstrichen ist. Ganz √§hnlich wie fr√ºher <code>tick(5000)</code>, aber ohne <code>fakeAsync()</code>-Zone:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startFiveSecondTimer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-basic&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startFiveSecondTimer&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;erh√∂ht den Counter nach exakt 5 Sekunden&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    vi.useFakeTimers();\n\n    const counter = { value: <span class=\"hljs-number\">0</span> };\n    startFiveSecondTimer(counter);\n\n    <span class=\"hljs-regexp\">//</span> simuliert das Vergehen von <span class=\"hljs-number\">5</span> Sekunden\n    vi.advanceTimersByTime(<span class=\"hljs-number\">5000</span>);\n\n    expect(counter.value).toBe(<span class=\"hljs-number\">1</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre>\n<p><code>advanceTimersByTime()</code> ist damit der unmittelbare Ersatz f√ºr <code>tick()</code>.\nEs eignet sich besonders gut, wenn du eine ganz bestimmte Zeitspanne simulieren oder mehrere Timer in korrekt getakteter Reihenfolge ablaufen lassen m√∂chtest.</p>\n<p>Doch nicht alle Timer sind so einfach. \nManchmal besteht der Code nur aus timerbasierten Aktionen, aber ohne zus√§tzliche Promises. Das folgende Beispiel inkrementiert einen Counter mehrfach, indem es ausschlie√ülich Timeouts und Intervals nutzt:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> function startSyncSequence(counter: { value: number }) {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { counter.value++; }, <span class=\"hljs-number\">300</span>);\n  const interval = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    counter.value++;\n    <span class=\"hljs-keyword\">if</span> (counter.value === <span class=\"hljs-number\">3</span>) {\n      <span class=\"hljs-built_in\">clearInterval</span>(interval);\n    }\n  }, <span class=\"hljs-number\">200</span>);\n}\n</code></pre>\n<p>In F√§llen, in denen du <em>alle</em> Timer der Reihe nach abarbeiten willst, ohne manuell Zeit vorzuspulen, nutzt du <code>vi.runAllTimers()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startSyncSequence } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-sync&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startSyncSequence&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;f√ºhrt alle synchronen Timer vollst√§ndig aus&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    vi.useFakeTimers();\n\n    const counter = { value: <span class=\"hljs-number\">0</span> };\n    startSyncSequence(counter);\n\n    <span class=\"hljs-regexp\">//</span> f√ºhrt alle Timer und Intervals aus, bis die Timer-Queue leer ist\n    vi.runAllTimers();\n\n    expect(counter.value).toBe(<span class=\"hljs-number\">3</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre>\n<p>Hier w√§re <code>advanceTimersByTime()</code> zwar m√∂glich, aber unn√∂tig kompliziert. <code>runAllTimers()</code> l√∂st einfach jedes Timeout und jedes Interval aus, bis nichts mehr √ºbrig ist.</p>\n<p>Noch interessanter wird es, wenn Timer-Callbacks selbst wieder asynchron arbeiten, beispielsweise durch ein <code>await</code> oder Promise-Ketten.\nDann reicht <code>runAllTimers()</code> nicht mehr aus. Das folgende Beispiel zeigt ein typisches Muster aus realen Anwendungen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startAsyncJob</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&lt;string&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-title function_\">async</span> () =&gt; {\n      <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;done&#x27;</span>); <span class=\"hljs-comment\">// asynchroner Schritt im Callback</span>\n      <span class=\"hljs-title function_\">resolve</span>(data);\n    }, <span class=\"hljs-number\">100</span>);\n  });\n}\n</code></pre>\n<p>Damit der Test nicht nur den Timeout, sondern auch das <code>await</code> im Callback vollst√§ndig abarbeitet, bietet Vitest <code>runAllTimersAsync()</code> an:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startAsyncJob } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-async&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startAsyncJob&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;f√ºhrt Timer und async-Callbacks vollst√§ndig aus&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n    vi.useFakeTimers();\n\n    const promise = startAsyncJob();\n\n    <span class=\"hljs-regexp\">//</span> f√ºhrt Timer UND asynchrone Logik innerhalb der Timer-Callbacks aus\n    <span class=\"hljs-keyword\">await</span> vi.runAllTimersAsync();\n\n    <span class=\"hljs-keyword\">await</span> expect(promise).resolves.toBe(<span class=\"hljs-string\">&#x27;done&#x27;</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre>\n<p><code>runAllTimersAsync()</code> ist damit ein guter Ersatz f√ºr Tests, bei denen bisher <code>fakeAsync()</code> und <code>tick()</code> in Kombination mit Microtask-Flushing verwendet wurden. </p>\n<h3 id=\"testbed-und-componentfixture\">TestBed und ComponentFixture</h3>\n<p>Nach all den kleinen, aber subtilen Unterschieden zwischen Jasmine und Vitest gibt es hier gute Nachrichten: \nDie Verwendung von <code>TestBed</code> und <code>ComponentFixture</code> bleibt vollst√§ndig unver√§ndert, da dies kein Thema ist, das Vitest ber√ºhrt. \nDu erzeugst weiterhin deine Komponenten oder Services mithilfe von <code>TestBed</code>.\nAuch der explizite Aufruf von <code>fixture.detectChanges()</code> ist unver√§ndert notwendig, um die Change Detection manuell anzusto√üen.</p>\n<h2 id=\"bekannte-einschr√§nkungen-und-fallstricke\">Bekannte Einschr√§nkungen und Fallstricke</h2>\n<p>Spezielle Karma-Anwendungsf√§lle wie eigene Karma-Plugins oder individuelle Browser‚ÄëLauncher lassen sich erwartungsgem√§√ü nicht direkt auf Vitest √ºbertragen.\nDu wirst im Vitest-√ñkosystem nach Alternativen suchen m√ºssen.</p>\n<p>Bei der Umstellung auf Vitest kann eine kurze Gew√∂hnungsphase im Team n√∂tig sein, da bestimmte neue API-Konzepte wie <code>vi.spyOn</code>, <code>vi.fn</code> oder Strategien zum Zur√ºcksetzen von Mocks zwar leicht zu erlernen sind, sich aber dennoch von Jasmine unterscheiden. \nAchte deshalb darauf, dass deine Tests m√∂gliche Manipulationen an globalen Objekten vollst√§ndig aufr√§umen und verwende daf√ºr idealerweise Methoden wie <a href=\"https://vitest.dev/api/#aftereach\"><code>afterEach</code></a> mit <a href=\"https://vitest.dev/api/vi.html#vi-restoreallmocks\"><code>vi.restoreAllMocks()</code></a>.</p>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Mit Vitest als Standard in Angular¬†21 wird das Testen deutlich moderner und schneller. \nDie Umstellung ist meist unkompliziert, die Migrations‚ÄëSchematics helfen beim Einstieg. \nWo fr√ºher <code>fakeAsync</code> und Zone.js‚ÄëMagie n√∂tig waren, reichen heute <code>async/await</code> und flexible Fake‚ÄëTimer. \nUnd wenn es realistisch sein muss, steht dir der Browser‚ÄëModus zur Verf√ºgung.\nInsgesamt bedeutet das: k√ºrzere Feedback‚ÄëSchleifen, robustere Tests und weniger Reibung im Alltag. Viel Spa√ü beim Testen!</p>\n<hr>\n\n<p><small>Vielen Dank an Ferdinand Malcher und Danny Koppenhagen f√ºr das Review und das wertvolle Feedback!</small></p>\n","meta":{"title":"Vitest in Angular 21: Was ist neu und wie kann man migrieren?","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2025-11-18T00:00:00.000Z","lastModified":"2025-11-20T00:00:00.000Z","keywords":["Angular","Angular 21","Vitest","Karma","Jasmine"],"language":"de","header":{"url":"angular-vitest.jpg","width":2000,"height":1089}}}
