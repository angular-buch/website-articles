{"slug":"2025-11-angular21","html":"<p>Bevor wir uns in den Trubel zum Jahresende stürzen, gibt es Neuigkeiten aus der Angular-Welt:\nAm <strong>19. November 2025</strong> wurde <strong>Angular 21</strong> veröffentlicht!\nDie wichtigsten Neuigkeiten: Signal Forms, Zoneless Apps, Testing mit Vitest und das neue Paket <code>@angular/aria</code>.</p>\n<!--Die offiziellen Release-Informationen finden Sie wie immer im [Angular-Blog](TODO).-->\n\n<p>Die Migration eines bestehenden Projekts auf Angular 21 kann mit dem Befehl <code>ng update</code> durchgeführt werden.\nDetaillierte Infos zu den Schritten liefert der <a href=\"https://angular.dev/update-guide\">Angular Update Guide</a>.</p>\n<h2 id=\"versionen-von-typescript-und-nodejs\">Versionen von TypeScript und Node.js</h2>\n<p>Die folgenden Versionen von TypeScript und Node.js sind für Angular 21 notwendig:</p>\n<ul>\n<li>TypeScript: &gt;=5.9.0 &lt;6.0.0</li>\n<li>Node.js: ^20.19.0 || ^22.12.0 || ^24.0.0</li>\n</ul>\n<p>Ausführliche Infos zu den unterstützten Versionen findest du der <a href=\"https://angular.dev/reference/versions\">Angular-Dokumentation</a>.</p>\n<h2 id=\"zoneless-change-detection-der-neue-standard\">Zoneless Change Detection: der neue Standard</h2>\n<p>Schon seit einiger Zeit unterstützt Angular die zonenlose Change Detection.\nFrüher wurde die Bibiothek Zone.js verwendet, um Änderungen an Daten zu ermitteln.\nMit Signals als neuem Grundbaustein hat sich das Vorgehen deutlich geändert: Signals teilen explizit mit, dass sich ein Wert geändert hat.\nWir haben darüber ausführlich im <a href=\"/blog/2024-05-angular18\">Blogpost zu Angular 18</a> berichtet.</p>\n<p>Nun gibt es zu dem Thema großartige Neuigkeiten: Zoneless Change Detection ist der neue Standard!\nNeue Anwendungen mit Angular 21 setzen also per Default auf den neuen Mechanismus.\nBeim Anlegen einer Anwendung mit <code>ng new</code> müssen wir nicht mehr die Option <code>--zoneless</code> verwenden.\nEs ist auch nicht mehr notwendig, die Funktion <code>provideZonelessChangeDetection()</code> in der <code>app.config.ts</code> aufzurufen.</p>\n<p>Möchte man aus Kompatibilitätsgründen doch noch die alte Umsetzung der mit Zone.js verwenden, lässt sich die Change Detection in der <code>app.config.ts</code> konfigurieren.\nZusätzlich muss Zone.js installiert sein und unter <code>polyfills</code> in der <code>angular.json</code> eingetragen werden – so wie es früher in allen Anwendungen der Fall war.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-type\">const</span> appConfig: ApplicationConfig = {\n  providers: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-comment\">// VERALTETE Change Detection mit Zone.js aktivieren</span>\n    <span class=\"hljs-built_in\">provideZoneChangeDetection</span>({ eventCoalescing: <span class=\"hljs-literal\">true</span> }),\n};\n</code></pre>\n<h2 id=\"signal-based-forms\">Signal-based Forms</h2>\n<p>Die aktuellen Ansätze für Formularverarbeitung in Angular sind nicht für das Zusammenspiel mit Signals ausgelegt.\nNun wurde ein neuer experimenteller Ansatz vorgestellt: <em>Signal Forms</em>.\nDiese Variante integriert nicht nur breitflächig Signals, sondern soll die Erstellung und Verwaltung von Formularen grundlegend vereinfachen.</p>\n<p>Die Grundidee: Die Daten liegen in einem einfachen Signal vor, das von uns verwaltet wird.\nAngular leitet aus den Daten die Struktur des Formulars ab.\nDie Regeln zur Validierung werden in Form eines Schemas definiert, das als Code notiert wird.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { schema, form, <span class=\"hljs-title class_\">Field</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> bookSchema = schema&lt;<span class=\"hljs-title class_\">Book</span>&gt;(<span class=\"hljs-function\"><span class=\"hljs-params\">fieldPath</span> =&gt;</span> {\n  <span class=\"hljs-title function_\">required</span>(fieldPath.<span class=\"hljs-property\">isbn</span>);\n  <span class=\"hljs-title function_\">minLength</span>(fieldPath.<span class=\"hljs-property\">isbn</span>, <span class=\"hljs-number\">10</span>);\n  <span class=\"hljs-title function_\">maxLength</span>(fieldPath.<span class=\"hljs-property\">isbn</span>, <span class=\"hljs-number\">13</span>);\n  <span class=\"hljs-title function_\">required</span>(fieldPath.<span class=\"hljs-property\">title</span>);\n});\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">Field</span>]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyForm</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> bookData = signal&lt;<span class=\"hljs-title class_\">Book</span>&gt;({\n    <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>\n  });\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> bookForm = <span class=\"hljs-title function_\">form</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookData</span>, bookFormSchema);\n}\n</code></pre>\n<p>Im Template erstellen wir die Datenbindungen mithilfe einer einzigen Direktive:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> [<span class=\"hljs-attr\">field</span>]=<span class=\"hljs-string\">&quot;bookForm.isbn&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> [<span class=\"hljs-attr\">field</span>]=<span class=\"hljs-string\">&quot;bookForm.title&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></pre>\n<p>Wir haben ausführliche Blogposts in englischer Sprache zu Signal Forms veröffentlicht:</p>\n<ul>\n<li><strong>Part 1: Getting Started with the Basics:</strong> <a href=\"https://angular-buch.com/blog/2025-10-signal-forms-part1\">https://angular-buch.com/blog/2025-10-signal-forms-part1</a></li>\n<li><strong>Part 2: Advanced Validation and Schema Patterns:</strong> <a href=\"https://angular-buch.com/blog/2025-10-signal-forms-part2\">https://angular-buch.com/blog/2025-10-signal-forms-part2</a></li>\n<li><strong>Part 3: Child Forms and Custom UI Controls:</strong> <a href=\"https://angular-buch.com/blog/2025-10-signal-forms-part3\">https://angular-buch.com/blog/2025-10-signal-forms-part3</a></li>\n</ul>\n<p>Perspektivisch könnten mit dem neuen Ansatz die älteren Varianten <em>Reactive Forms</em> und <em>Template-Driven Forms</em> verdrängt werden.\nDas Angular-Team legt außerdem großen Wert auf Abwärtskompatibilität, sodass die Migration auf ein Signal-basiertes Formular kein großes Problem sein sollte.\nNoch ist der neue Ansatz aber experimentell, sodass sich die Schnittstellen und Konzepte noch ändern können.</p>\n<h2 id=\"vitest-der-neue-test-runner\">Vitest: der neue Test-Runner</h2>\n<p>Mit Angular 21 gibt es einen der größten Umbrüche im Testing seit vielen Jahren: \n<a href=\"https://vitest.dev\">Vitest</a> ersetzt &quot;offiziell&quot; Karma und Jasmine als Standard-Test-Runner. \nVitest ist für neue Projekte mit <code>ng new</code> die Voreinstellung.\nFür neue Projekte führt der Weg also klar zu Vitest, du kannst auf Wunsch aber weiterhin Karma/Jasmine wählen:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Projekt mit Karma als Testrunner anlegen</span>\nng new <span class=\"hljs-keyword\">my</span>-project <span class=\"hljs-comment\">--test-runner=karma</span>\n</code></pre>\n<p>Vitest bringt spürbare Vorteile: deutlich schnellere Testausführung, moderne APIs, eine Jest‑ähnliche Expect‑Syntax, flexible Fake‑Timer, und bei Bedarf sogar einen echten Browser-Modus.\nDer Browser-Modus ist ähnlich wie zuvor unter Karma und ideal für realitätsnahe UI-Tests.\nDie meisten Specs sollten weiterhin unverändert funktionieren, da Angulars <code>TestBed</code> und <code>ComponentFixture</code> vollständig gleich bleiben.\nAnpassungen betreffen hauptsächlich Jasmine-spezifische Matcher oder Spys.</p>\n<p>Die eigentliche Umstellung erfolgt zunächst über den neuen Builder <code>unit-test</code> in der <code>angular.json</code>.\nDanach kannst du für bestehende Tests ein experimentelles Schematic verwenden, das viele Jasmine-Patterns automatisch nach Vitest überführt.</p>\n<p>Eine ausführliche Anleitung zur Migration, inklusive praktischer Beispiele zu Fake-Timern, Matchern und async/await, haben wir hier zusammengestellt:\n<strong><a href=\"/blog/2025-11-zu-vitest-migrieren\">Vitest in Angular 21: Was ist neu und wie kann man migrieren?</a></strong></p>\n<h2 id=\"angulararia-barrierefreie-komponenten-leicht-gemacht\">@angular/aria: barrierefreie Komponenten leicht gemacht</h2>\n<p>Mit Angular 21 wurde das neue Package <a href=\"https://angular.dev/guide/aria/overview\"><code>@angular/aria</code></a> eingeführt: eine Sammlung von Direktiven, die gängige <a href=\"https://www.w3.org/WAI/ARIA/apg/patterns/\">WAI-ARIA-Patterns</a> implementieren.\nDas Package übernimmt die komplexe Arbeit der Barrierefreiheit, insbesondere für komplexere, häufig verwendete Patterns, die über die Standard-HTML-Elemente hinausgehen.\nTastaturinteraktionen, ARIA-Attribute, Fokus-Management und Screen-Reader-Unterstützung werden unter der Haube der Direktiven berücksichtigt.</p>\n<p>Die Installation des neuen Pakets erfolgt wie gewohnt über die Angular CLI:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> @angular/aria</span>\n</code></pre>\n<p>In der ersten Version bietet <code>@angular/aria</code> Direktiven für die folgenden interaktiven Patterns:</p>\n<table>\n<thead>\n<tr>\n<th>Komponente</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Accordion</strong></td>\n<td>Aufklappbereiche (Akkordeon), die einzeln oder exklusiv erweitert werden können</td>\n</tr>\n<tr>\n<td><strong>Autocomplete</strong></td>\n<td>Texteingabe mit gefilterten Vorschlägen während der Eingabe</td>\n</tr>\n<tr>\n<td><strong>Combobox</strong></td>\n<td>Kombination aus Textfeld und Popup mit Suchergebnissen</td>\n</tr>\n<tr>\n<td><strong>Grid</strong></td>\n<td>Zweidimensionale Datenanzeige mit zellenweiser Tastaturnavigation</td>\n</tr>\n<tr>\n<td><strong>Listbox</strong></td>\n<td>Ein- oder Mehrfachauswahl-Optionslisten mit Tastaturnavigation</td>\n</tr>\n<tr>\n<td><strong>Menu</strong></td>\n<td>Dropdown-Menüs mit verschachtelten Untermenüs und Tastaturkürzeln</td>\n</tr>\n<tr>\n<td><strong>Multiselect</strong></td>\n<td>Mehrfachauswahl-Dropdown-Pattern mit kompakter Anzeige</td>\n</tr>\n<tr>\n<td><strong>Select</strong></td>\n<td>Einfachauswahl-Dropdown-Pattern mit Tastaturnavigation</td>\n</tr>\n<tr>\n<td><strong>Tabs</strong></td>\n<td>Tab-Interfaces mit automatischen oder manuellen Aktivierungsmodi</td>\n</tr>\n<tr>\n<td><strong>Toolbar</strong></td>\n<td>Gruppierte Steuerelemente mit logischer Tastaturnavigation</td>\n</tr>\n<tr>\n<td><strong>Tree</strong></td>\n<td>Hierarchische Listen mit Erweitern/Einklappen-Funktionalität</td>\n</tr>\n</tbody></table>\n<p>Das neue Package eignet sich insbesondere dann, wenn wir komplexe Komponenten entwickeln und nicht auf bestehende barrierefreie Komponentenbibliotheken zurückgreifen können, z. B. weil sich diese zum Beispiel hinsichtlich ihres Stylings nicht anpassen lassen.\nDie Direktiven bringen keinerlei Visualität mit sich, sorgen aber für ein konsistentes Verhalten sowie eine barrierefreie Tastaturnavigation, Fokus-Handling und Screenreader-Optimierung.</p>\n<blockquote>\n<p>Einige der Bausteine gab es schon zuvor in ähnlicher Form im <a href=\"https://material.angular.dev/cdk/dialog/overview\">Component Development Kit (CDK)</a> von Angular. Das CDK war der Unterbau der Komponentenbibliothek Angular Material.\nMit <code>@angular/aria</code> bringt das Angular-Team den Kern dieser Sammlung ein Stück näher an die Angular-Basis und stärkt das Thema Barrierefreiheit.</p>\n</blockquote>\n<h2 id=\"providers-für-httpclient\">Providers für <code>HttpClient</code></h2>\n<p>Mit Angular 21 werden die Providers für den <code>HttpClient</code> automatisch eingebunden.\nEs ist also nicht mehr zwingend notwendig, in der <code>app.config.ts</code> die Funktion <code>provideHttpClient()</code> aufzurufen.</p>\n<p>Wollen wir die HTTP-Integration konfigurieren, z. B. mit Interceptors oder der Funktion <code>withFetch()</code>, müssen wir die Funktion allerdings weiterhin verwenden:</p>\n<pre><code class=\"language-ts\">// app<span class=\"hljs-selector-class\">.config</span><span class=\"hljs-selector-class\">.ts</span>\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    // ...\n    <span class=\"hljs-built_in\">provideHttpClient</span>(\n      <span class=\"hljs-built_in\">withFetch</span>(),\n      <span class=\"hljs-built_in\">withInterceptors</span>([ <span class=\"hljs-comment\">/* ... */</span> ])\n    )\n  ]\n};\n</code></pre>\n<h2 id=\"migrationsskripte\">Migrationsskripte</h2>\n<p>Es wird nicht mehr empfohlen, die Direktive <code>ngClass</code> zu verwenden. \nWir haben darüber schon vor einem Jahr <a href=\"https://angular.schule/blog/2024-11-ngclass-ngstyle\">in einem Blogposzt berichtet</a>.\nZur Umstellung auf direkte Class Bindings mit <code>[class]</code> bietet Angular ein Migrationsskript an:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:ngclass-to-<span class=\"hljs-keyword\">class</span>\n</code></pre>\n<p>Das <code>RouterTestingModule</code> für Unit-Tests wird ebenfalls nicht mehr unterstützt.\nEin Migrationsskript kann die Tests auf das neuere <code>provideRouterTesting()</code> umstellen, siehe <a href=\"https://github.com/angular/angular/commit/861cee34e0e9b5562cfe70d245f30b7ddea7d8fd\">Commit</a>.</p>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Alle Details zu den Neuerungen findest du immer im Changelog von <a href=\"https://github.com/angular/angular/releases\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/releases\">Angular CLI</a>.\nEinige interessante Aspekte haben wir hier zusammengetragen:</p>\n<ul>\n<li><strong>Bindings für ARIA-Attribute:</strong> Bisher mussten wir für ARIA-Attribute immer ein Attribute Binding verwenden: <code>[attr.aria-label]=&quot;myLabel&quot;</code>. Die Attribute können nun auch direkt gebunden werden: <code>[aria-label]=&quot;myLabel&quot;</code>.</li>\n<li><strong>Tailwind-Support für <code>ng new</code>:</strong> Angular unterstützt schon länger direkt TailwindCSS. Nun kann das Framework auch direkt beim Anlegen einer Anwendung konfiguriert werden: <code>ng new --style=tailwind</code>, (siehe <a href=\"https://github.com/angular/angular-cli/commit/4912f39906b11a3212f11d5a00d577e2a0bacab4\">Commit</a>).</li>\n<li><strong>MCP-Tool für Zoneless Migration:</strong> Der MCP-Server der Angular CLI bietet ein Werkzeug an, um Anwendungen auf Zoneless Change Detection zu migrieren (siehe <a href=\"https://github.com/angular/angular-cli/commit/1be35b3433179481be85ea1cb892d66170e0aebe\">Commit</a>).</li>\n<li><strong>MCP-Tool zum Lernen von Angular:</strong> Angular bietet das MCP-Tool <code>ai-tutor</code> an. Der Chat-Agent leitet schrittweise durch die Arbeit mit Angular und soll den Einstieg vereinfachen (siehe <a href=\"https://github.com/angular/angular-cli/commit/6d3a3c5799bde1bab5c3878e0783ffa6854e36ad\">Commit</a>).</li>\n</ul>\n<hr>\n\n\n<p>Wir wünschen dir viel Spaß beim Entwickeln mit Angular 21!\nHast du Fragen zur neuen Version zu Angular oder zu unserem Buch? Schreibe uns!</p>\n<p><strong>Viel Spaß wünschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Drei Zinnen, Dolomiten, Italien. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 21 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2025-11-19T00:00:00.000Z","lastModified":"2025-11-19T00:00:00.000Z","keywords":["Angular","Angular 21","ARIA","Zoneless","Signal Forms","Vitest","Karma"],"language":"de","header":{"url":"angular21.jpg","width":2000,"height":1009},"sticky":true,"isUpdatePost":true}}
