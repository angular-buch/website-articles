{"slug":"2025-11-angular21","html":"<p>Bevor wir uns in den Trubel zum Jahresende st√ºrzen, gibt es Neuigkeiten aus der Angular-Welt:\nAm <strong>19. November 2025</strong> wurde <strong>Angular 21</strong> ver√∂ffentlicht!\nDie wichtigsten Neuigkeiten: Signal Forms, Zoneless Apps, Testing mit Vitest, das neue Paket <code>@angular/aria</code> und mehr Unterst√ºtzung f√ºr AI-Assistenten.</p>\n<p>Die offiziellen Release-Informationen findest du wie immer im <a href=\"https://blog.angular.dev/announcing-angular-v21-57946c34f14b\">Angular-Blog</a>.\nDie Migration eines bestehenden Projekts auf Angular 21 kann mit dem Befehl <code>ng update</code> durchgef√ºhrt werden.\nDetaillierte Infos zu den Schritten liefert der <a href=\"https://angular.dev/update-guide\">Angular Update Guide</a>.</p>\n<blockquote>\n<p><strong>üá¨üáß This article is available in English language here: <a href=\"https://angular.schule/blog/2025-11-angular21\">Angular 21 is here!</a></strong></p>\n</blockquote>\n<h2 id=\"versionen-von-typescript-und-nodejs\">Versionen von TypeScript und Node.js</h2>\n<p>Die folgenden Versionen von TypeScript und Node.js sind f√ºr Angular 21 notwendig:</p>\n<ul>\n<li>TypeScript: &gt;=5.9.0 &lt;6.0.0</li>\n<li>Node.js: ^20.19.0 || ^22.12.0 || ^24.0.0</li>\n</ul>\n<p>Ausf√ºhrliche Infos zu den unterst√ºtzten Versionen findest du in der <a href=\"https://angular.dev/reference/versions\">Angular-Dokumentation</a>.</p>\n<h2 id=\"zoneless-change-detection-der-neue-standard\">Zoneless Change Detection: der neue Standard</h2>\n<p>Schon seit einiger Zeit unterst√ºtzt Angular die zonenlose Change Detection.\nFr√ºher wurde die Bibliothek Zone.js verwendet, um √Ñnderungen an Daten zu ermitteln.\nMit Signals als neuem Grundbaustein hat sich das Vorgehen deutlich ge√§ndert: Signals teilen explizit mit, dass sich ein Wert ge√§ndert hat.\nWir haben dar√ºber ausf√ºhrlich im <a href=\"/blog/2024-05-angular18\">Blogpost zu Angular 18</a> berichtet.</p>\n<p>Nun gibt es zu dem Thema gro√üartige Neuigkeiten: Zoneless Change Detection ist der neue Standard!\nNeue Anwendungen mit Angular 21 setzen also per Default auf den neuen Mechanismus.\nBeim Anlegen einer Anwendung mit <code>ng new</code> m√ºssen wir nicht mehr die Option <code>--zoneless</code> verwenden.\nEs ist auch nicht mehr notwendig, die Funktion <code>provideZonelessChangeDetection()</code> in der <code>app.config.ts</code> aufzurufen.</p>\n<p>M√∂chte man aus Kompatibilit√§tsgr√ºnden doch noch die alte Umsetzung mit Zone.js verwenden, l√§sst sich die Change Detection in der <code>app.config.ts</code> konfigurieren.\nZus√§tzlich muss Zone.js installiert sein und unter <code>polyfills</code> in der <code>angular.json</code> eingetragen werden ‚Äì so wie es fr√ºher in allen Anwendungen der Fall war.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-type\">const</span> appConfig: ApplicationConfig = {\n  providers: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-comment\">// VERALTETE Change Detection mit Zone.js aktivieren</span>\n    <span class=\"hljs-built_in\">provideZoneChangeDetection</span>({ eventCoalescing: <span class=\"hljs-literal\">true</span> }),\n};\n</code></pre>\n<h2 id=\"signal-based-forms\">Signal-based Forms</h2>\n<p>Die aktuellen Ans√§tze f√ºr Formularverarbeitung in Angular sind nicht f√ºr das Zusammenspiel mit Signals ausgelegt.\nNun wurde ein neuer experimenteller Ansatz vorgestellt: <em>Signal Forms</em>.\nDiese Variante integriert nicht nur breitfl√§chig Signals, sondern soll die Erstellung und Verwaltung von Formularen grundlegend vereinfachen.</p>\n<p>Die Grundidee: Die Daten liegen in einem einfachen Signal vor, das von uns verwaltet wird.\nAngular leitet aus den Daten die Struktur des Formulars ab.\nDie Regeln zur Validierung werden in Form eines Schemas definiert, das als Code notiert wird.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { schema, form, <span class=\"hljs-title class_\">Field</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms/signals&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> bookFormSchema = schema&lt;<span class=\"hljs-title class_\">Book</span>&gt;(<span class=\"hljs-function\"><span class=\"hljs-params\">fieldPath</span> =&gt;</span> {\n  <span class=\"hljs-title function_\">required</span>(fieldPath.<span class=\"hljs-property\">isbn</span>);\n  <span class=\"hljs-title function_\">minLength</span>(fieldPath.<span class=\"hljs-property\">isbn</span>, <span class=\"hljs-number\">10</span>);\n  <span class=\"hljs-title function_\">maxLength</span>(fieldPath.<span class=\"hljs-property\">isbn</span>, <span class=\"hljs-number\">13</span>);\n  <span class=\"hljs-title function_\">required</span>(fieldPath.<span class=\"hljs-property\">title</span>);\n});\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">Field</span>]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyForm</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> bookData = signal&lt;<span class=\"hljs-title class_\">Book</span>&gt;({\n    <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>\n  });\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">readonly</span> bookForm = <span class=\"hljs-title function_\">form</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookData</span>, bookFormSchema);\n}\n</code></pre>\n<p>Im Template erstellen wir die Datenbindungen mithilfe einer einzigen Direktive:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> [<span class=\"hljs-attr\">field</span>]=<span class=\"hljs-string\">&quot;bookForm.isbn&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> [<span class=\"hljs-attr\">field</span>]=<span class=\"hljs-string\">&quot;bookForm.title&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></pre>\n<p>Wir haben ausf√ºhrliche Blogposts in englischer Sprache zu Signal Forms ver√∂ffentlicht:</p>\n<ul>\n<li><a href=\"https://angular-buch.com/blog/2025-10-signal-forms-part1\"><strong>Part 1: Getting Started with the Basics</strong></a></li>\n<li><a href=\"https://angular-buch.com/blog/2025-10-signal-forms-part2\"><strong>Part 2: Advanced Validation and Schema Patterns</strong></a></li>\n<li><a href=\"https://angular-buch.com/blog/2025-10-signal-forms-part3\"><strong>Part 3: Child Forms and Custom UI Controls</strong></a></li>\n</ul>\n<p>Perspektivisch k√∂nnten mit dem neuen Ansatz die √§lteren Varianten <em>Reactive Forms</em> und <em>Template-Driven Forms</em> verdr√§ngt werden.\nDas Angular-Team legt au√üerdem gro√üen Wert auf Abw√§rtskompatibilit√§t, sodass die Migration auf ein Signal-basiertes Formular kein gro√ües Problem sein sollte.\nNoch ist der neue Ansatz aber experimentell, sodass sich die Schnittstellen und Konzepte noch √§ndern k√∂nnen.</p>\n<h2 id=\"vitest-der-neue-test-runner\">Vitest: der neue Test-Runner</h2>\n<p>Mit Angular¬†21 gibt es einen der gr√∂√üten Umbr√ºche im Testing seit vielen Jahren: \n<a href=\"https://vitest.dev\">Vitest</a> ersetzt &quot;offiziell&quot; Karma und Jasmine als Standard-Test-Runner. \nVitest wurde bereits mit <a href=\"https://angular-buch.com/blog/2025-05-angular20#experimenteller-test-builder-f%C3%BCr-vitest\">Angular 20 (Mai 2025) als experimenteller Test-Runner eingef√ºhrt</a>.\nMit Angular 21 ist Vitest nun offiziell stabil und nicht mehr als experimentell gekennzeichnet.</p>\n<p>Vitest wurde damit gleichzeitig f√ºr neue Projekte mit <code>ng new</code> zur Voreinstellung.\nF√ºr neue Projekte f√ºhrt der Weg also klar zu Vitest, du kannst auf Wunsch aber weiterhin Karma/Jasmine w√§hlen:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Projekt mit Vitest als Testrunner anlegen</span>\nng new <span class=\"hljs-keyword\">my</span>-project\n\n<span class=\"hljs-comment\"># Projekt mit Karma als Testrunner anlegen</span>\nng new <span class=\"hljs-keyword\">my</span>-project <span class=\"hljs-comment\">--test-runner=karma</span>\n</code></pre>\n<p>Vitest bringt sp√ºrbare Vorteile: deutlich schnellere Testausf√ºhrung, moderne APIs, eine Jest‚Äë√§hnliche Expect‚ÄëSyntax, flexible Fake‚ÄëTimer, und bei Bedarf sogar einen echten Browser-Modus.\nDer Browser-Modus ist √§hnlich wie zuvor unter Karma und ideal f√ºr realit√§tsnahe UI-Tests.\nDie meisten Specs sollten weiterhin unver√§ndert funktionieren, da Angulars <code>TestBed</code> und <code>ComponentFixture</code> vollst√§ndig gleich bleiben.\nAnpassungen betreffen haupts√§chlich Jasmine-spezifische Matcher oder Spys.</p>\n<p>Die eigentliche Umstellung erfolgt zun√§chst √ºber den neuen Builder <code>unit-test</code> in der <code>angular.json</code>.\nDanach kannst du f√ºr bestehende Tests ein experimentelles Schematic verwenden, das viele Jasmine-Patterns automatisch nach Vitest √ºberf√ºhrt:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">ng</span> g <span class=\"hljs-variable\">@schematics</span>/angular:refactor-jasmine-vitest\n</code></pre>\n<p>Gleichzeitig hat das Angular-Team die Unterst√ºtzung f√ºr die Test-Runner Jest und Web Test Runner als <strong>deprecated</strong> markiert.\nEine ausf√ºhrliche Anleitung zur Migration, inklusive praktischer Beispiele zu Fake-Timern, Matchern und async/await, haben wir hier zusammengestellt:</p>\n<ul>\n<li><strong><a href=\"/blog/2025-11-zu-vitest-migrieren\">Vitest in Angular 21: Was ist neu und wie kann man migrieren?</a></strong></li>\n</ul>\n<h2 id=\"angulararia-barrierefreie-komponenten-leicht-gemacht\">@angular/aria: barrierefreie Komponenten leicht gemacht</h2>\n<p>Mit Angular 21 wurde das neue Package <a href=\"https://angular.dev/guide/aria/overview\"><code>@angular/aria</code></a> eingef√ºhrt: eine Sammlung von Direktiven, die g√§ngige <a href=\"https://www.w3.org/WAI/ARIA/apg/patterns/\">WAI-ARIA-Patterns</a> implementieren.\nDas Package √ºbernimmt die komplexe Arbeit der Barrierefreiheit, insbesondere f√ºr komplexere, h√§ufig verwendete Patterns, die √ºber die Standard-HTML-Elemente hinausgehen.\nTastaturinteraktionen, ARIA-Attribute, Fokus-Management und Screen-Reader-Unterst√ºtzung werden unter der Haube der Direktiven ber√ºcksichtigt.</p>\n<p>Die Installation des neuen Pakets erfolgt wie gewohnt √ºber die Angular CLI:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> @angular/aria</span>\n</code></pre>\n<p>In der ersten Version bietet <code>@angular/aria</code> Direktiven f√ºr die folgenden interaktiven Patterns:</p>\n<table>\n<thead>\n<tr>\n<th>Komponente</th>\n<th>Beschreibung</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Accordion</strong></td>\n<td>Aufklappbereiche (Akkordeon), die einzeln oder exklusiv erweitert werden k√∂nnen</td>\n</tr>\n<tr>\n<td><strong>Autocomplete</strong></td>\n<td>Texteingabe mit gefilterten Vorschl√§gen w√§hrend der Eingabe</td>\n</tr>\n<tr>\n<td><strong>Combobox</strong></td>\n<td>Kombination aus Textfeld und Popup mit Suchergebnissen</td>\n</tr>\n<tr>\n<td><strong>Grid</strong></td>\n<td>Zweidimensionale Datenanzeige mit zellenweiser Tastaturnavigation</td>\n</tr>\n<tr>\n<td><strong>Listbox</strong></td>\n<td>Ein- oder Mehrfachauswahl-Optionslisten mit Tastaturnavigation</td>\n</tr>\n<tr>\n<td><strong>Menu</strong></td>\n<td>Dropdown-Men√ºs mit verschachtelten Untermen√ºs und Tastaturk√ºrzeln</td>\n</tr>\n<tr>\n<td><strong>Multiselect</strong></td>\n<td>Mehrfachauswahl-Dropdown-Pattern mit kompakter Anzeige</td>\n</tr>\n<tr>\n<td><strong>Select</strong></td>\n<td>Einfachauswahl-Dropdown-Pattern mit Tastaturnavigation</td>\n</tr>\n<tr>\n<td><strong>Tabs</strong></td>\n<td>Tab-Interfaces mit automatischen oder manuellen Aktivierungsmodi</td>\n</tr>\n<tr>\n<td><strong>Toolbar</strong></td>\n<td>Gruppierte Steuerelemente mit logischer Tastaturnavigation</td>\n</tr>\n<tr>\n<td><strong>Tree</strong></td>\n<td>Hierarchische Listen mit Erweitern/Einklappen-Funktionalit√§t</td>\n</tr>\n</tbody></table>\n<p>Das neue Package eignet sich insbesondere dann, wenn wir komplexe Komponenten entwickeln und nicht auf bestehende barrierefreie Komponentenbibliotheken zur√ºckgreifen k√∂nnen, z. B. weil sich diese zum Beispiel hinsichtlich ihres Stylings nicht anpassen lassen.\nDie Direktiven bringen keinerlei Visualit√§t mit sich, sorgen aber f√ºr ein konsistentes Verhalten sowie eine barrierefreie Tastaturnavigation, Fokus-Handling und Screenreader-Optimierung.</p>\n<p>In der Angular-Dokumentation findest du weitere Infos zu den neuen Direktiven: <a href=\"https://angular.dev/guide/aria/overview\">Angular Aria Guide</a></p>\n<blockquote>\n<p>Einige der Bausteine gab es schon zuvor in √§hnlicher Form im <a href=\"https://material.angular.dev/cdk/dialog/overview\">Component Development Kit (CDK)</a> von Angular. Das CDK war der Unterbau der Komponentenbibliothek Angular Material.\nMit <code>@angular/aria</code> bringt das Angular-Team den Kern dieser Sammlung ein St√ºck n√§her an die Angular-Basis und st√§rkt das Thema Barrierefreiheit.</p>\n</blockquote>\n<h2 id=\"providers-f√ºr-httpclient\">Providers f√ºr <code>HttpClient</code></h2>\n<p>Mit Angular 21 werden die Providers f√ºr den <code>HttpClient</code> automatisch eingebunden.\nEs ist also nicht mehr zwingend notwendig, in der <code>app.config.ts</code> die Funktion <code>provideHttpClient()</code> aufzurufen.</p>\n<p>Wollen wir die HTTP-Integration konfigurieren, z. B. mit Interceptors oder der Funktion <code>withFetch()</code>, m√ºssen wir die Funktion allerdings weiterhin verwenden:</p>\n<pre><code class=\"language-ts\">// app<span class=\"hljs-selector-class\">.config</span><span class=\"hljs-selector-class\">.ts</span>\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    // ...\n    <span class=\"hljs-built_in\">provideHttpClient</span>(\n      <span class=\"hljs-built_in\">withFetch</span>(),\n      <span class=\"hljs-built_in\">withInterceptors</span>([ <span class=\"hljs-comment\">/* ... */</span> ])\n    )\n  ]\n};\n</code></pre>\n<h2 id=\"angulars-unterst√ºtzung-f√ºr-ai-assistenten\">Angulars Unterst√ºtzung f√ºr AI-Assistenten</h2>\n<p>Beim Anlegen einer neuen Anwendung (<code>ng new</code>) fragt der interaktive Prompt jetzt nach, ob du eine Config f√ºr ein bestimmtes KI-Werkzeug generieren m√∂chtest (Kommandozeilenoption <code>--ai-config</code>). \nDadurch wird eine Datei erzeugt, die als <em>Custom Prompt</em> automatisch in AI-Assistenten wie Claude Code, GitHub Copilot, Cursor und vielen weiteren eingelesen wird und diese mit aktuellen Angular Best Practices versorgt:</p>\n<pre><code class=\"language-bash\">? Which AI tools <span class=\"hljs-keyword\">do</span> you want to configure with Angular best practices? https:<span class=\"hljs-regexp\">//</span>angular.dev<span class=\"hljs-regexp\">/ai/</span>develop-with-ai\n ‚óâ None\n ‚óØ Agents.md      [ https:<span class=\"hljs-regexp\">//</span>agents.md/                                               ]\n‚ùØ‚óØ Claude         [ https:<span class=\"hljs-regexp\">//</span>docs.anthropic.com<span class=\"hljs-regexp\">/en/</span>docs<span class=\"hljs-regexp\">/claude-code/m</span>emory            ]\n ‚óØ Cursor         [ https:<span class=\"hljs-regexp\">//</span>docs.cursor.com<span class=\"hljs-regexp\">/en/</span>context/rules                         ]\n ‚óØ Gemini         [ https:<span class=\"hljs-regexp\">//</span>ai.google.dev<span class=\"hljs-regexp\">/gemini-api/</span>docs                            ]\n ‚óØ GitHub Copilot [ https:<span class=\"hljs-regexp\">//</span>code.visualstudio.com<span class=\"hljs-regexp\">/docs/</span>copilot/copilot-customization ]\n ‚óØ JetBrains AI   [ https:<span class=\"hljs-regexp\">//</span>www.jetbrains.com<span class=\"hljs-regexp\">/help/</span>junie/customize-guidelines.html   ]\n\n‚Üë‚Üì navigate ‚Ä¢ space select ‚Ä¢ a all ‚Ä¢ i invert ‚Ä¢ ‚èé submit\n</code></pre>\n<p>Je nach ausgew√§hltem Tool variiert der Dateiname und der Speicherort, etwa <code>.claude/CLAUDE.md</code> f√ºr Claude, <code>.gemini/GEMINI.md</code> f√ºr Gemini oder <code>AGENTS.md</code> nach dem <a href=\"https://agents.md/\">neuen Standard</a> sowie optional ein Frontmatter.\nDer eigentliche Inhalt mit den Angular Best Practices bleibt identisch.</p>\n<p>Allerdings gibt es auch Herausforderungen: Custom Prompts werden bei l√§ngeren Sessions h√§ufig vergessen, und das begrenzte Kontextfenster f√ºhrt zu inkonsistenten Ergebnissen.\nUm dieses Problem besser zu beherrschen, bietet Angular zus√§tzlich einen eigenen MCP-Server an, der mit Angular 21 nun stabil ist. \nDer Server erm√∂glicht AI-Agenten strukturierten Zugriff auf sieben Tools.\nDamit wird die &quot;Wissensl√ºcke&quot; zwischen dem trainierten Modell und den aktuellen Best Practices geschlossen: \nLLMs k√∂nnen so auch brandneue Features wie Signal Forms und Angular Aria nutzen, obwohl sie zum Zeitpunkt des Trainings noch nicht existierten.</p>\n<p>Der MCP-Server bietet aktuell sieben Tools an:</p>\n<ol>\n<li>Mit einem interaktiven KI-Tutor Angular kennenlernen (<code>ai_tutor</code>). Siehe auch die Dokumentation unter <a href=\"https://angular.dev/ai/ai-tutor\">&quot;Angular AI Tutor&quot;</a>.</li>\n<li>Moderne Angular-Pattern-Beispiele finden (<code>find_examples</code>).</li>\n<li>Best Practices bereitstellen (<code>get_best_practices</code>).</li>\n<li>Alle Projekte im Workspace auflisten (<code>list_projects</code>).</li>\n<li>Die Anwendung auf Zoneless Change Detection migrieren (<code>onpush_zoneless_migration</code>).</li>\n<li>Die Dokumentation durchsuchen (<code>search_documentation</code>).</li>\n<li>Code-Migrationen mit Schematics durchf√ºhren (<code>modernize</code>, <strong>experimentell</strong>).</li>\n</ol>\n<!-- Mehr Details zu `AGENTS.md`, MCP und praktischen Erfahrungen findest du in unserem ausf√ºhrlichen Artikel √ºber [Vibe-Coding mit Angular](/blog/2025-11-ai-mcp-vibe-coding). -->\n\n\n<h2 id=\"migrationsskripte\">Migrationsskripte</h2>\n<p>Es wird nicht mehr empfohlen, die Direktive <code>ngClass</code> zu verwenden. \nWir haben dar√ºber schon vor einem Jahr <a href=\"https://angular.schule/blog/2024-11-ngclass-ngstyle\">in einem Blogpost berichtet</a>.\nZur Umstellung auf direkte Class Bindings mit <code>[class]</code> bietet Angular ein Migrationsskript an:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:ngclass-to-<span class=\"hljs-keyword\">class</span>\n</code></pre>\n<p>Das <code>RouterTestingModule</code> f√ºr Unit-Tests wird ebenfalls nicht mehr unterst√ºtzt.\nEin Migrationsskript kann die Tests auf das neuere <code>provideRouterTesting()</code> umstellen, siehe <a href=\"https://github.com/angular/angular/commit/861cee34e0e9b5562cfe70d245f30b7ddea7d8fd\">Commit</a>.</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> @angular/core:router-testing-<span class=\"hljs-keyword\">module</span>-migration\n</code></pre>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Alle Details zu den Neuerungen findest du immer im Changelog von <a href=\"https://github.com/angular/angular/releases\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/releases\">Angular CLI</a>.\nEinige interessante Aspekte haben wir hier zusammengetragen:</p>\n<ul>\n<li><strong>Bindings f√ºr ARIA-Attribute:</strong> Bisher mussten wir f√ºr ARIA-Attribute immer ein Attribute Binding verwenden: <code>[attr.aria-label]=&quot;myLabel&quot;</code>. Die Attribute k√∂nnen nun auch direkt gebunden werden: <code>[aria-label]=&quot;myLabel&quot;</code>.</li>\n<li><strong>Regul√§re Ausdr√ºcke in Templates:</strong> Angular unterst√ºtzt jetzt regul√§re Ausdr√ºcke direkt in Templates (siehe <a href=\"https://github.com/angular/angular/pull/63857\">PR</a>).</li>\n<li><strong>Tailwind-Support f√ºr <code>ng new</code>:</strong> Angular unterst√ºtzt schon l√§nger direkt TailwindCSS. Nun kann das Framework auch direkt beim Anlegen einer Anwendung konfiguriert werden: <code>ng new --style=tailwind</code> (siehe <a href=\"https://github.com/angular/angular-cli/commit/4912f39906b11a3212f11d5a00d577e2a0bacab4\">Commit</a>).</li>\n</ul>\n<hr>\n\n\n<p>Wir w√ºnschen dir viel Spa√ü beim Entwickeln mit Angular 21!\nHast du Fragen zur neuen Version von Angular oder zu unserem Buch? Schreibe uns!</p>\n<p><strong>Viel Spa√ü w√ºnschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Drei Zinnen, Dolomiten, Italien. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 21 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2025-11-19T00:00:00.000Z","lastModified":"2025-11-20T00:00:00.000Z","keywords":["Angular","Angular 21","MCP-Server","ARIA","Zoneless","Signal Forms","Vitest","Karma"],"language":"de","header":{"url":"angular21.jpg","width":2000,"height":1009},"sticky":true,"isUpdatePost":true}}
