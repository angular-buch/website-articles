{"slug":"2022-06-angular14","html":"<p>Noch bevor die Sommer- und Urlaubszeit beginnt, wartet Angular mit tollen Neuigkeiten auf: Am 2. Juni 2022 erschien die neue Major-Version <strong>Angular 14</strong>!\nWährend die letzten Hauptreleases vor allem interne Verbesserungen für das Tooling mitbrachten, hat Angular 14 einige spannende neue Features mit an Bord.</p>\n<p>In diesem Blogpost fassen wir wie immer die wichtigsten Neuigkeiten zusammen.\nIm englischsprachigen <a href=\"https://blog.angular.io/angular-v14-is-now-available-391a6db736af\">Angular-Blog</a> finden Sie außerdem die offizielle Mitteilung des Angular-Teams.\nAußerdem empfehlen wir Ihnen einen Blick in die Changelogs von <a href=\"https://github.com/angular/angular/blob/master/CHANGELOG.md\">Angular</a> und der <a href=\"https://github.com/angular/angular-cli/blob/master/CHANGELOG.md\">Angular CLI</a>.</p>\n<blockquote>\n<p><strong>Die Update-Infos für neuere Versionen von Angular finden Sie in separaten Blogartikeln. Wenn Sie das Update durchführen möchten, lesen Sie bitte alle Artikel in der gegebenen Reihenfolge.</strong></p>\n<ul>\n<li><a href=\"/blog/2022-11-angular15\">Angular 15 ist da!</a></li>\n<li><a href=\"/blog/2023-05-angular16\">Angular 16 ist da!</a></li>\n<li><a href=\"/blog/2023-11-angular17\">Angular 17 ist da!</a></li>\n</ul>\n</blockquote>\n<h2 id=\"projekt-updaten\">Projekt updaten</h2>\n<p>Um ein existierendes Projekt zu aktualisieren, nutzen Sie bitte den <a href=\"https://update.angular.io/?v=13.0-14.0\">Angular Update Guide</a>.\nDer Befehl <code>ng update</code> liefert außerdem Infos zu möglichen Updates direkt im Projekt.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># Projekt auf Angular 14 aktualisieren</span>\nng update <span class=\"hljs-variable\">@angular</span>/core<span class=\"hljs-variable\">@14</span> <span class=\"hljs-variable\">@angular</span>/cli<span class=\"hljs-variable\">@1</span>4\n</code></pre>\n<p>Dadurch werden nicht nur die Pakete aktualisiert, sondern auch notwendige Migrationen im Code durchgeführt.\nPrüfen Sie danach am Besten mithilfe der Differenzansicht von Git die Änderungen.</p>\n<h2 id=\"standalone-components\">Standalone Components</h2>\n<p>Damit eine Komponente genutzt werden kann, musste sie bisher immer in einem NgModule deklariert werden.\nInsbesondere bei wiederverwendbaren Komponenten führte das leicht zu unübersichtlichem Code.\nDas Konzept der NgModules mit allen Details (insbesondere Imports, Exports, Providers) erschwert außerdem den Einstieg in das Framework Angular.</p>\n<p>Mit Angular 14 wurde dieses lang diskutierte Thema angegangen: Angular unterstützt nun <em>Standalone Components</em>.</p>\n<p>Komponenten, Pipes und Direktiven müssen damit nicht mehr in einem Modul deklariert werden, sondern können alleinstehend verwendet werden.\nDamit eine Komponente genutzt werden kann, wird sie direkt am Ort der Verwendung importiert.\nIm folgenden Codebeispiel möchte die <code>AppComponent</code> die andere Komponente <code>DashboardComponent</code> in ihrem Template nutzen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  selector: <span class=\"hljs-string\">&#x27;app-root&#x27;</span>,\n  standalone: true,\n  imports: [DashboardComponent]\n  // ...\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> </span>{}\n</code></pre>\n<p>Dadurch vereinfacht sich die Struktur der Anwendung, denn die Gruppierung in NgModules entfällt.\nNgModules und Standalone Components sind kompatibel, können also auch in Kombination genutzt werden.</p>\n<p>Das neue Feature ist zunächst als <em>Developer Preview</em> verfügbar.\nDas bedeutet, dass die Schnittstelle vor dem finalen Release noch verändert werden kann.</p>\n<blockquote>\n<p>Wir behandeln das Thema ausführlich in einem separaten Blogpost:<br>\n<strong><a href=\"https://angular.schule/blog/2022-05-standalone-components\">Standalone Components – neu ab Angular 14</a></strong></p>\n</blockquote>\n<h2 id=\"strikt-typisierte-formulare\">Strikt typisierte Formulare</h2>\n<p>Reactive Forms sind ein mächtiger Ansatz, um komplexe Formulare mit Angular zu entwickeln.\nDie bisherige Umsetzung hatte allerdings Schwächen, denn die Modelle waren stets mit <code>any</code> typisiert:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> myForm = <span class=\"hljs-keyword\">new</span> FormGroup({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">const</span> value = myForm.value; <span class=\"hljs-comment\">// any ❌</span>\n</code></pre>\n<p>Mit Angular 14 ändert sich dieses Verhalten: Die Formularmodelle für Reactive Forms sind jetzt strikt typisiert!\nDas Design für die neue Typisierung war nicht trivial, deshalb wurde der Prozess von einem <a href=\"https://github.com/angular/angular/discussions/44513\">öffentlichen RFC</a> begleitet.</p>\n<blockquote>\n<p>Wir behandeln das Thema ausführlich in einem separaten Blogpost:<br>\n<strong><a href=\"https://angular.schule/blog/2022-05-typed-forms\">Typisierte Reactive Forms – neu ab Angular 14</a></strong></p>\n</blockquote>\n<p>Beim Update auf Angular 14 werden bestehende Formulare automatisch auf eine untypisierte Variante migriert, z. B. wird <code>FormControl</code> ersetzt durch <code>UntypedFormControl</code>.\nAlte Formulare können so zunächst unverändert bleiben, und die Migration zum neuen Ansatz kann schrittweise durchgeführt werden.</p>\n<h2 id=\"seitentitel-setzen-mit-dem-router\">Seitentitel setzen mit dem Router</h2>\n<p>Um den Titel der Seite mit Angular zu setzen, existiert schon seit einiger Zeit der Service <code>Title</code>.\nDer Nachteil an dieser Strategie ist, dass man das tatsächliche Setzen des Titels selbst in der Anwendung implementieren muss.\nDazu muss entweder jede geroutete Komponente die passende Funktionalität mitbringen, oder wir müssen in einem Service selbst eine zentrale Logik dafür platzieren.</p>\n<p>Seit Angular 14 bringt der Router eine passende Funktionalität mit, um den Titel der Seite automatisch zu setzen.\nDazu können wir in den Routen das Property <code>title</code> definieren, und der Seitentitel wird beim Aktivieren der Route automatisch angepasst:</p>\n<pre><code class=\"language-ts\">const routes: Routes = [\n  {\n    <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;admin/create&#x27;</span>,\n    component: BookCreateComponent,\n    title: <span class=\"hljs-string\">&#x27;Buch erstellen&#x27;</span>\n  },\n  {\n    <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;admin/edit/:isbn&#x27;</span>,\n    component: BookEditComponent,\n    title: <span class=\"hljs-string\">&#x27;Buch bearbeiten&#x27;</span>\n  }\n];\n</code></pre>\n<p>Leider wird der Titel nur verändert, wenn eine Route einen Eintrag <code>title</code> hat.\nBetreten wir also eine Route ohne Titel, bleibt der zuletzt gesetzte Titel erhalten.</p>\n<p>Um komplexere Anwendungsfälle zu lösen, können wir die Logik des Routers überschreiben.\nDafür müssen wir eine eigene <code>TitleStrategy</code> implementieren.\nDie folgende Klasse setzt zum Beispiel den Titel auf den in der Route definierten Wert – oder auf den Default <code>BookMonkey</code>, wenn kein Titel gegeben ist:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomTitleStrategy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">TitleStrategy</span> </span>{\n  constructor(<span class=\"hljs-keyword\">private</span> title: <span class=\"hljs-type\">Title</span>) {\n    <span class=\"hljs-keyword\">super</span>();\n  }\n\n  updateTitle(routerState: <span class=\"hljs-type\">RouterStateSnapshot</span>) {\n    const title = <span class=\"hljs-keyword\">this</span>.buildTitle(routerState) ?? &#x27;<span class=\"hljs-type\">BookMonkey</span>&#x27;;\n    <span class=\"hljs-keyword\">this</span>.title.setTitle(title);\n  }\n}\n</code></pre>\n<p>So können wir zum Beispiel den Titel auch nach einem bestimmten Muster zusammensetzen, sodass immer der Text <code>BookMonkey</code> erhalten ist:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-title function_\">updateTitle</span>(<span class=\"hljs-params\">routerState: RouterStateSnapshot</span>) {\n  <span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">buildTitle</span>(routerState);\n  <span class=\"hljs-keyword\">if</span> (title) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">title</span>.<span class=\"hljs-title function_\">setTitle</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${title}</span> | BookMonkey`</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">title</span>.<span class=\"hljs-title function_\">setTitle</span>(<span class=\"hljs-string\">&#x27;BookMonkey&#x27;</span>)\n  }\n}\n</code></pre>\n<p>Die selbst definierte <code>TitleStrategy</code> muss mithilfe eines Providers bekannt gemacht werden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@NgModule</span>({\n  <span class=\"hljs-attribute\">imports</span>: [RouterModule.<span class=\"hljs-built_in\">forRoot</span>(routes)],\n  <span class=\"hljs-attribute\">exports</span>: [RouterModule],\n  <span class=\"hljs-attribute\">providers</span>: [\n    { <span class=\"hljs-attribute\">provide</span>: TitleStrategy, <span class=\"hljs-attribute\">useClass</span>: CustomTitleStrategy }\n  ]\n})\nexport class AppRoutingModule { }\n</code></pre>\n<blockquote>\n<p>Für eine ausführlichere Auseinandersetzung empfehlen wir den folgenden Blogartikel von Brandon Roberts:<br>\n<strong><a href=\"https://dev.to/brandontroberts/setting-page-titles-natively-with-the-angular-router-393j\">Setting Page Titles Natively With The Angular Router</a></strong></p>\n</blockquote>\n<h2 id=\"autovervollständigung-mit-der-angular-cli\">Autovervollständigung mit der Angular CLI</h2>\n<p>Die Angular CLI bietet ein praktisches neues Feature an: eine integrierte automatische Vervollständigung für die Kommandozeile.\nZur Einrichtung muss einmalig der Befehl <code>ng completion</code> ansgeführt werden.\nEr ergänzt die Konfiguration der Kommandozeile (z. B. <code>.bashrc</code> oder <code>.zshrc</code>), sodass für die Autovervollständigung automatisch im Hintergrund die Angular CLI aufgerufen wird.</p>\n<p>Tippen wir also z. B. in der Kommandozeile den Befehl <code>ng</code> und drücken die Tab-Taste, erhalten wir automatisch passende Vorschläge:</p>\n<pre><code class=\"language-bash\">➜  book-monkey git:(main) ng\n<span class=\"hljs-built_in\">add</span>           <span class=\"hljs-comment\">-- Adds support for an external library to your project.</span>\nbuild         <span class=\"hljs-comment\">-- Compiles an Angular application or library into an output directory named dist/ at the given output</span>\ncache         <span class=\"hljs-comment\">-- Configure persistent disk cache and retrieve cache statistics.</span>\ncompletion    <span class=\"hljs-comment\">-- Set up Angular CLI autocompletion for your terminal.</span>\nconfig        <span class=\"hljs-comment\">-- Retrieves or sets Angular configuration values in the angular.json file for the workspace.</span>\ndeploy        <span class=\"hljs-comment\">-- Invokes the deploy builder for a specified project or for the default project in the workspace.</span>\ndoc           <span class=\"hljs-comment\">-- Opens the official Angular documentation (angular.io) in a browser, and searches for a given keyword</span>\ne2e           <span class=\"hljs-comment\">-- Builds and serves an Angular application, then runs end-to-end tests.</span>\nextract-i18n  <span class=\"hljs-comment\">-- Extracts i18n messages from source code.</span>\ngenerate      <span class=\"hljs-comment\">-- Generates and/or modifies files based on a schematic.</span>\n<span class=\"hljs-comment\"># ...</span>\n</code></pre>\n<p>Dadurch, dass die Autovervollständigung stets die Angular CLI nutzt, bezieht sich die Vervollständigung auf den aktuellen Kontext.\nZum Beispiel liefert die Vervollständigung für <code>ng generate</code> alle möglichen Schematics, die wir im Projekt installiert haben.\nDamit verbessert sich sich Developer Experience enorm.</p>\n<h2 id=\"neue-funktion-inject\">Neue Funktion <code>inject()</code></h2>\n<p>Um Abhängigkeiten per Dependency Injection anzufordern, wird üblicherweise der Konstruktor von Komponenten und Services verwendet:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{\n  constructor(private service: BookStoreService) {}\n}\n</code></pre>\n<p>Alternativ konnte auch bisher schon die Klasse <code>Injector</code> mit der Methode <code>get()</code> verwendet werden.\nDiese Klasse musste aber wiederum auch mittels Dependency Injection angefordert werden:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injector</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">injector</span>: <span class=\"hljs-title class_\">Injector</span></span>) {\n    <span class=\"hljs-keyword\">const</span> service = injector.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-title class_\">BookStoreService</span>);\n  }\n}\n</code></pre>\n<p>In Angular 14 kommt die neue Funktion <code>inject()</code> hinzu.\nIm Gegensatz zum <code>Injector</code> muss sie nicht erst über Dependency Injection angefordert werden, sondern kann komplett eigenständig verwendet werden.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getService</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookStoreService</span>);\n}\n\n@<span class=\"hljs-title class_\">Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> service = <span class=\"hljs-title function_\">getService</span>();\n  }\n}\n</code></pre>\n<p>Eine Einschränkung ist hierbei zu beachten: Der Aufruf von <code>inject()</code> muss immer indirekt über den Konstruktor erfolgen, also aus einem sogenannten <em>Injection Context</em>. Tut man das nicht, wird der folgende Fehler geworfen:</p>\n<blockquote>\n<p><code>ERROR Error: NG0203: inject() must be called from an injection context</code></p>\n</blockquote>\n<p>Durch die Unabhängigkeit von der Komponentenklasse ergeben sich viele spannende Möglichkeiten zur Komposition.\n<del>Es gilt jedoch abzuwarten, wie sich die neuen Patterns etablieren werden.\nWir empfehlen also, Abhängigkeiten zunächst weiterhin direkt über den Konstruktor anzufordern.</del></p>\n<blockquote>\n<p>Update März 2024: Mittlerweile hat sich <code>inject()</code> etabliert, und der Verwendung steht nichts im Wege.</p>\n</blockquote>\n<blockquote>\n<p>Für einige Ideen zur Funktion <code>inject()</code> möchten wir auf einen Blogartikel von Younes Jaaidi verweisen:<br>\n<strong><a href=\"https://marmicode.io/blog/angular-inject-and-injection-functions\">Angular Inject &amp; Injection Functions - Patterns &amp; Anti-Patterns</a></strong></p>\n</blockquote>\n<h2 id=\"sonstiges\">Sonstiges</h2>\n<p>Neben den großen neuen Features hat das neue Release viele kleine Verbesserungen und Bug Fixes an Bord.\nEine Auswahl haben wir hier zusammengestellt:</p>\n<ul>\n<li><strong>TypeScript-Unterstützung:</strong> Angular unterstützt offiziell TypeScript in der Version 4.7, siehe <a href=\"https://github.com/angular/angular/commit/29039fcdbcb8cab040d88dabe2dcb1abae34cb4e\">Commit</a>. Ältere Versionen als 4.6 werden hingegen nicht mehr supportet, siehe <a href=\"https://github.com/angular/angular/commit/c9d566ce4b6e9097d9eceb7ac3964a0b25c404ad\">Commit</a>.</li>\n<li><strong>Types für Router Events:</strong> Die Events des Routers (über <code>Router.events</code>) besitzen jetzt ein neues Property <code>type</code>. Um bestimmte Events zu filtern, war es bisher immer notwendig, mithilfe von <code>instanceof</code> nach der Klasse zu filtern. Das neue Property vereinfacht den Umgang, siehe <a href=\"https://github.com/angular/angular/commit/41e2a68e30c12e5ad3e26047c3a4032e9aa1a6e1\">Commit</a>.</li>\n<li><strong>Schematics Default Collection:</strong> In der <code>angular.json</code> konnte mit dem Property <code>defaultCollection</code> die Standard-Kollektion definiert werden, die für die Schematics (z. B. <code>ng generate</code>) genutzt wird. Bei der Installation von Drittbibliotheken wie <code>@ngrx/schematics</code> konnte diese Einstellung gesetzt werden. Dieses Property wurde nun ersetzt durch <code>schematicCollections</code>. Hier kann ein Array mit mehreren Collections definiert werden, die in der angegebenen Reihenfolge durchsucht werden. Damit entfällt bei wiederholten Befehlen die Notwendigkeit, die Collection manuell anzugeben. Siehe <a href=\"https://github.com/angular/angular-cli/commit/366cabc66c3dd836e2fdfea8dad6c4c7c2096b1d\">Commit</a>.</li>\n<li><strong>defaultProject:</strong> Die Einstellung <code>defaultProject</code> in der <code>angular.json</code> ist deprecated. Stattdessen wird das aktuelle Projekt jetzt anhand des Arbeitsverzeichnisses ermittelt, siehe <a href=\"https://github.com/angular/angular-cli/commit/036327e9ca838f9ef3f117fbd18949d9d357e68d\">Commit</a>.</li>\n<li><strong>Protected Propertys:</strong> In Komponenten ist es jetzt auch möglich, Propertys und Methoden im Template zu binden, die als <code>protected</code> markiert sind. Bisher funktionierte das nur für <code>public</code>.</li>\n<li><strong>Angular DevTools für Firefox:</strong> Die offizielle Browser-Extension zum Debuggen von Angular-Anwendungen ist jetzt auch für Firefox verfügbar. Der Download ist über <a href=\"https://addons.mozilla.org/en-US/firefox/addon/angular-devtools/\">das offizielle Verzeichnis von Mozilla</a> möglich.</li>\n</ul>\n<br>\n<br>\n\n<p>Die Roadmap für die zukünftige Entwicklung von Angular wird regelmäßig in der Dokumentation veröffentlicht: <a href=\"https://angular.io/guide/roadmap\">https://angular.io/guide/roadmap</a>.</p>\n<p>Wir wünschen Ihnen viel Spaß mit Angular 14!\nHaben Sie Fragen zur neuen Version, zum Update oder zu Angular? Schreiben Sie uns!</p>\n<p><strong>Viel Spaß wünschen\nFerdinand, Danny und Johannes</strong></p>\n<hr>\n\n<p><small><strong>Titelbild:</strong> Yosemite National Park, California, 2019. Foto von Ferdinand Malcher</small></p>\n","meta":{"title":"Angular 14 ist da!","author":"Angular Buch Team","mail":"team@angular-buch.com","published":"2022-06-02T00:00:00.000Z","lastModified":"2022-06-02T00:00:00.000Z","keywords":["Angular","Angular 14","Typed Forms","Standalone Components","TitleStrategy","Update"],"language":"de","thumbnail":"https://website-articles.angular-buch.com/2022-06-angular14/angular14.jpg","sticky":false}}
